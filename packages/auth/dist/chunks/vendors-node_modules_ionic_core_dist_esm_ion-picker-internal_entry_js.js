"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_ionic_core_dist_esm_ion-picker-internal_entry_js"],{

/***/ "../node_modules/@ionic/core/dist/esm/ion-picker-internal.entry.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@ionic/core/dist/esm/ion-picker-internal.entry.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_picker_internal": () => (/* binding */ PickerInternal)
/* harmony export */ });
/* harmony import */ var _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-06cd27b1.js */ "../node_modules/@ionic/core/dist/esm/index-06cd27b1.js");
/* harmony import */ var _helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers-eed79a2b.js */ "../node_modules/@ionic/core/dist/esm/helpers-eed79a2b.js");
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */



const pickerInternalIosCss = ":host{display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:200px;z-index:0}:host .picker-before,:host .picker-after{position:absolute;width:100%;z-index:1;pointer-events:none}:host .picker-before{left:0;top:0;height:83px}:host-context([dir=rtl]){left:unset;right:unset;right:0}:host .picker-after{left:0;top:116px;height:84px}:host-context([dir=rtl]){left:unset;right:unset;right:0}:host .picker-highlight{border-radius:8px;left:0;right:0;top:50%;bottom:0;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;position:absolute;width:calc(100% - 16px);height:34px;-webkit-transform:translateY(-50%);transform:translateY(-50%);z-index:-1}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host .picker-highlight{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}:host input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}:host ::slotted(ion-picker-column-internal:first-of-type){text-align:start}:host ::slotted(ion-picker-column-internal:last-of-type){text-align:end}:host .picker-before{background:-webkit-gradient(linear, left top, left bottom, color-stop(20%, var(--background, var(--ion-background-color, #fff))), to(rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8)));background:linear-gradient(to bottom, var(--background, var(--ion-background-color, #fff)) 20%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8) 100%)}:host .picker-after{background:-webkit-gradient(linear, left bottom, left top, color-stop(20%, var(--background, var(--ion-background-color, #fff))), to(rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8)));background:linear-gradient(to top, var(--background, var(--ion-background-color, #fff)) 20%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8) 100%)}:host .picker-highlight{background:var(--ion-color-step-150, #eeeeef)}";

const pickerInternalMdCss = ":host{display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:200px;z-index:0}:host .picker-before,:host .picker-after{position:absolute;width:100%;z-index:1;pointer-events:none}:host .picker-before{left:0;top:0;height:83px}:host-context([dir=rtl]){left:unset;right:unset;right:0}:host .picker-after{left:0;top:116px;height:84px}:host-context([dir=rtl]){left:unset;right:unset;right:0}:host .picker-highlight{border-radius:8px;left:0;right:0;top:50%;bottom:0;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;position:absolute;width:calc(100% - 16px);height:34px;-webkit-transform:translateY(-50%);transform:translateY(-50%);z-index:-1}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host .picker-highlight{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}:host input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}:host ::slotted(ion-picker-column-internal:first-of-type){text-align:start}:host ::slotted(ion-picker-column-internal:last-of-type){text-align:end}:host .picker-before{background:-webkit-gradient(linear, left top, left bottom, color-stop(20%, var(--background, var(--ion-background-color, #fff))), color-stop(90%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0)));background:linear-gradient(to bottom, var(--background, var(--ion-background-color, #fff)) 20%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0) 90%)}:host .picker-after{background:-webkit-gradient(linear, left bottom, left top, color-stop(30%, var(--background, var(--ion-background-color, #fff))), color-stop(90%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0)));background:linear-gradient(to top, var(--background, var(--ion-background-color, #fff)) 30%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0) 90%)}";

let PickerInternal = class {
  constructor(hostRef) {
    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.ionInputModeChange = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionInputModeChange", 7);
    this.useInputMode = false;
    this.isInHighlightBounds = (ev) => {
      const { highlightEl } = this;
      if (!highlightEl) {
        return false;
      }
      const bbox = highlightEl.getBoundingClientRect();
      /**
       * Check to see if the user clicked
       * outside the bounds of the highlight.
       */
      const outsideX = ev.clientX < bbox.left || ev.clientX > bbox.right;
      const outsideY = ev.clientY < bbox.top || ev.clientY > bbox.bottom;
      if (outsideX || outsideY) {
        return false;
      }
      return true;
    };
    /**
     * If we are no longer focused
     * on a picker column, then we should
     * exit input mode. An exception is made
     * for the input in the picker since having
     * that focused means we are still in input mode.
     */
    this.onFocusOut = (ev) => {
      const { relatedTarget } = ev;
      if (!relatedTarget ||
        relatedTarget.tagName !== 'ION-PICKER-COLUMN-INTERNAL' && relatedTarget !== this.inputEl) {
        this.exitInputMode();
      }
    };
    /**
     * When picker columns receive focus
     * the parent picker needs to determine
     * whether to enter/exit input mode.
     */
    this.onFocusIn = (ev) => {
      const { target } = ev;
      /**
       * Due to browser differences in how/when focus
       * is dispatched on certain elements, we need to
       * make sure that this function only ever runs when
       * focusing a picker column.
       */
      if (target.tagName !== 'ION-PICKER-COLUMN-INTERNAL') {
        return;
      }
      /**
       * If we have actionOnClick
       * then this means the user focused
       * a picker column via mouse or
       * touch (i.e. a PointerEvent). As a result,
       * we should not enter/exit input mode
       * until the click event has fired, which happens
       * after the `focusin` event.
       *
       * Otherwise, the user likely focused
       * the column using their keyboard and
       * we should enter/exit input mode automatically.
       */
      if (!this.actionOnClick) {
        const columnEl = target;
        const allowInput = columnEl.numericInput;
        if (allowInput) {
          this.enterInputMode(columnEl, false);
        }
        else {
          this.exitInputMode();
        }
      }
    };
    /**
     * On click we need to run an actionOnClick
     * function that has been set in onPointerDown
     * so that we enter/exit input mode correctly.
     */
    this.onClick = () => {
      const { actionOnClick } = this;
      if (actionOnClick) {
        actionOnClick();
        this.actionOnClick = undefined;
      }
    };
    /**
     * Clicking a column also focuses the column on
     * certain browsers, so we use onPointerDown
     * to tell the onFocusIn function that users
     * are trying to click the column rather than
     * focus the column using the keyboard. When the
     * user completes the click, the onClick function
     * runs and runs the actionOnClick callback.
     */
    this.onPointerDown = (ev) => {
      const { useInputMode, inputModeColumn, el } = this;
      if (this.isInHighlightBounds(ev)) {
        /**
         * If we were already in
         * input mode, then we should determine
         * if we tapped a particular column and
         * should switch to input mode for
         * that specific column.
         */
        if (useInputMode) {
          /**
           * If we tapped a picker column
           * then we should either switch to input
           * mode for that column or all columns.
           * Otherwise we should exit input mode
           * since we just tapped the highlight and
           * not a column.
           */
          if (ev.target.tagName === 'ION-PICKER-COLUMN-INTERNAL') {
            /**
             * If user taps 2 different columns
             * then we should just switch to input mode
             * for the new column rather than switching to
             * input mode for all columns.
             */
            if (inputModeColumn && inputModeColumn === ev.target) {
              this.actionOnClick = () => {
                this.enterInputMode();
              };
            }
            else {
              this.actionOnClick = () => {
                this.enterInputMode(ev.target);
              };
            }
          }
          else {
            this.actionOnClick = () => {
              this.exitInputMode();
            };
          }
          /**
           * If we were not already in
           * input mode, then we should
           * enter input mode for all columns.
           */
        }
        else {
          /**
           * If there is only 1 numeric input column
           * then we should skip multi column input.
           */
          const columns = el.querySelectorAll('ion-picker-column-internal.picker-column-numeric-input');
          const columnEl = (columns.length === 1) ? ev.target : undefined;
          this.actionOnClick = () => {
            this.enterInputMode(columnEl);
          };
        }
        return;
      }
      this.actionOnClick = () => {
        this.exitInputMode();
      };
    };
    /**
     * Enters input mode to allow
     * for text entry of numeric values.
     * If on mobile, we focus a hidden input
     * field so that the on screen keyboard
     * is brought up. When tabbing using a
     * keyboard, picker columns receive an outline
     * to indicate they are focused. As a result,
     * we should not focus the hidden input as it
     * would cause the outline to go away, preventing
     * users from having any visual indication of which
     * column is focused.
     */
    this.enterInputMode = (columnEl, focusInput = true) => {
      const { inputEl, el } = this;
      if (!inputEl) {
        return;
      }
      /**
       * Only active input mode if there is at
       * least one column that accepts numeric input.
       */
      const hasInputColumn = el.querySelector('ion-picker-column-internal.picker-column-numeric-input');
      if (!hasInputColumn) {
        return;
      }
      /**
       * If columnEl is undefined then
       * it is assumed that all numeric pickers
       * are eligible for text entry.
       * (i.e. hour and minute columns)
       */
      this.useInputMode = true;
      this.inputModeColumn = columnEl;
      /**
       * Users with a keyboard and mouse can
       * activate input mode where the input is
       * focused as well as when it is not focused,
       * so we need to make sure we clean up any
       * old listeners.
       */
      if (focusInput) {
        if (this.destroyKeypressListener) {
          this.destroyKeypressListener();
          this.destroyKeypressListener = undefined;
        }
        inputEl.focus();
      }
      else {
        el.addEventListener('keypress', this.onKeyPress);
        this.destroyKeypressListener = () => {
          el.removeEventListener('keypress', this.onKeyPress);
        };
      }
      this.emitInputModeChange();
    };
    this.exitInputMode = () => {
      const { inputEl, useInputMode } = this;
      if (!useInputMode || !inputEl) {
        return;
      }
      this.useInputMode = false;
      this.inputModeColumn = undefined;
      inputEl.blur();
      inputEl.value = '';
      if (this.destroyKeypressListener) {
        this.destroyKeypressListener();
        this.destroyKeypressListener = undefined;
      }
      this.emitInputModeChange();
    };
    this.onKeyPress = (ev) => {
      const { inputEl } = this;
      if (!inputEl) {
        return;
      }
      const parsedValue = parseInt(ev.key, 10);
      /**
       * Only numbers should be allowed
       */
      if (!Number.isNaN(parsedValue)) {
        inputEl.value += ev.key;
        this.onInputChange();
      }
    };
    this.selectSingleColumn = () => {
      const { inputEl, inputModeColumn, singleColumnSearchTimeout } = this;
      if (!inputEl || !inputModeColumn) {
        return;
      }
      const values = inputModeColumn.items;
      /**
       * If users pause for a bit, the search
       * value should be reset similar to how a
       * <select> behaves. So typing "34", waiting,
       * then typing "5" should select "05".
       */
      if (singleColumnSearchTimeout) {
        clearTimeout(singleColumnSearchTimeout);
      }
      this.singleColumnSearchTimeout = setTimeout(() => {
        inputEl.value = '';
        this.singleColumnSearchTimeout = undefined;
      }, 1000);
      /**
       * For values that are longer than 2 digits long
       * we should shift the value over 1 character
       * to the left. So typing "456" would result in "56".
       * TODO: If we want to support more than just
       * time entry, we should update this value to be
       * the max length of all of the picker items.
       */
      if (inputEl.value.length >= 3) {
        const startIndex = inputEl.value.length - 2;
        const newString = inputEl.value.substring(startIndex);
        inputEl.value = newString;
        this.selectSingleColumn();
        return;
      }
      /**
       * Checking the value of the input gets priority
       * first. For example, if the value of the input
       * is "1" and we entered "2", then the complete value
       * is "12" and we should select hour 12.
       *
       * Regex removes any leading zeros from values like "02".
       */
      const findItemFromCompleteValue = values.find(({ text }) => text.replace(/^0+/, '') === inputEl.value);
      if (findItemFromCompleteValue) {
        inputModeColumn.value = findItemFromCompleteValue.value;
        return;
      }
      /**
       * If we typed "56" to get minute 56, then typed "7",
       * we should select "07" as "567" is not a valid minute.
       */
      if (inputEl.value.length === 2) {
        const changedCharacter = inputEl.value.substring(inputEl.value.length - 1);
        inputEl.value = changedCharacter;
        this.selectSingleColumn();
      }
    };
    /**
     * Searches a list of column items for a particular
     * value. This is currently used for numeric values.
     * The zeroBehavior can be set to account for leading
     * or trailing zeros when looking at the item text.
     */
    this.searchColumn = (colEl, value, zeroBehavior = 'start') => {
      let item;
      const behavior = zeroBehavior === 'start' ? /^0+/ : /0$/;
      item = colEl.items.find(({ text }) => text.replace(behavior, '') === value);
      if (item) {
        colEl.value = item.value;
      }
    };
    this.selectMultiColumn = () => {
      const { inputEl, el } = this;
      if (!inputEl) {
        return;
      }
      const numericPickers = Array.from(el.querySelectorAll('ion-picker-column-internal')).filter(col => col.numericInput);
      const firstColumn = numericPickers[0];
      const lastColumn = numericPickers[1];
      let value = inputEl.value;
      switch (value.length) {
        case 1:
          this.searchColumn(firstColumn, value);
          break;
        case 2:
          /**
           * If the first character is `0` or `1` it is
           * possible that users are trying to type `09`
           * or `11` into the hour field, so we should look
           * at that first.
           */
          const firstCharacter = inputEl.value.substring(0, 1);
          value = (firstCharacter === '0' || firstCharacter === '1') ? inputEl.value : firstCharacter;
          this.searchColumn(firstColumn, value);
          /**
           * If only checked the first value,
           * we can check the second value
           * for a match in the minutes column
           */
          if (value.length === 1) {
            const minuteValue = inputEl.value.substring(inputEl.value.length - 1);
            this.searchColumn(lastColumn, minuteValue, 'end');
          }
          break;
        case 3:
          /**
           * If the first character is `0` or `1` it is
           * possible that users are trying to type `09`
           * or `11` into the hour field, so we should look
           * at that first.
           */
          const firstCharacterAgain = inputEl.value.substring(0, 1);
          value = (firstCharacterAgain === '0' || firstCharacterAgain === '1') ? inputEl.value.substring(0, 2) : firstCharacterAgain;
          this.searchColumn(firstColumn, value);
          /**
           * If only checked the first value,
           * we can check the second value
           * for a match in the minutes column
           */
          const minuteValue = (value.length === 1) ? inputEl.value.substring(1) : inputEl.value.substring(2);
          this.searchColumn(lastColumn, minuteValue, 'end');
          break;
        case 4:
          /**
           * If the first character is `0` or `1` it is
           * possible that users are trying to type `09`
           * or `11` into the hour field, so we should look
           * at that first.
           */
          const firstCharacterAgainAgain = inputEl.value.substring(0, 1);
          value = (firstCharacterAgainAgain === '0' || firstCharacterAgainAgain === '1') ? inputEl.value.substring(0, 2) : firstCharacterAgainAgain;
          this.searchColumn(firstColumn, value);
          /**
           * If only checked the first value,
           * we can check the second value
           * for a match in the minutes column
           */
          const minuteValueAgain = (value.length === 1) ? inputEl.value.substring(1, inputEl.value.length) : inputEl.value.substring(2, inputEl.value.length);
          this.searchColumn(lastColumn, minuteValueAgain, 'end');
          break;
        default:
          const startIndex = inputEl.value.length - 4;
          const newString = inputEl.value.substring(startIndex);
          inputEl.value = newString;
          this.selectMultiColumn();
          break;
      }
    };
    /**
     * Searches the value of the active column
     * to determine which value users are trying
     * to select
     */
    this.onInputChange = () => {
      const { useInputMode, inputEl, inputModeColumn } = this;
      if (!useInputMode || !inputEl) {
        return;
      }
      if (inputModeColumn) {
        this.selectSingleColumn();
      }
      else {
        this.selectMultiColumn();
      }
    };
    /**
     * Emit ionInputModeChange. Picker columns
     * listen for this event to determine whether
     * or not their column is "active" for text input.
     */
    this.emitInputModeChange = () => {
      const { useInputMode, inputModeColumn } = this;
      this.ionInputModeChange.emit({
        useInputMode,
        inputModeColumn
      });
    };
  }
  componentWillLoad() {
    (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.el).addEventListener('focusin', this.onFocusIn);
    (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.el).addEventListener('focusout', this.onFocusOut);
  }
  render() {
    return ((0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.H, { onPointerDown: (ev) => this.onPointerDown(ev), onClick: () => this.onClick() }, (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("input", { "aria-hidden": "true", tabindex: -1, inputmode: "numeric", type: "number", ref: el => this.inputEl = el, onInput: () => this.onInputChange(), onBlur: () => this.exitInputMode() }), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "picker-before" }), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "picker-after" }), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "picker-highlight", ref: el => this.highlightEl = el }), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null)));
  }
  get el() { return (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.i)(this); }
};
PickerInternal.style = {
  ios: pickerInternalIosCss,
  md: pickerInternalMdCss
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfZGlzdF9lc21faW9uLXBpY2tlci1pbnRlcm5hbF9lbnRyeV9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDNkc7QUFDakQ7O0FBRTVELG9DQUFvQyxvQkFBb0IsYUFBYSxrQkFBa0Isc0JBQXNCLG1CQUFtQixxQkFBcUIsdUJBQXVCLFdBQVcsYUFBYSxVQUFVLHlDQUF5QyxrQkFBa0IsV0FBVyxVQUFVLG9CQUFvQixxQkFBcUIsT0FBTyxNQUFNLFlBQVkseUJBQXlCLFdBQVcsWUFBWSxRQUFRLG9CQUFvQixPQUFPLFVBQVUsWUFBWSx5QkFBeUIsV0FBVyxZQUFZLFFBQVEsd0JBQXdCLGtCQUFrQixPQUFPLFFBQVEsUUFBUSxTQUFTLGlCQUFpQixrQkFBa0IsYUFBYSxnQkFBZ0Isa0JBQWtCLHdCQUF3QixZQUFZLG1DQUFtQywyQkFBMkIsV0FBVywrRkFBK0Ysd0JBQXdCLGtCQUFrQixtQkFBbUIsMEJBQTBCLHlCQUF5Qix3QkFBd0Isd0JBQXdCLFlBQVksa0JBQWtCLE1BQU0sT0FBTyxRQUFRLFNBQVMsV0FBVyxZQUFZLFNBQVMsVUFBVSxTQUFTLFVBQVUsbUJBQW1CLFVBQVUsZ0JBQWdCLHdCQUF3QixxQkFBcUIsMERBQTBELGlCQUFpQix5REFBeUQsZUFBZSxxQkFBcUIsd05BQXdOLHVMQUF1TCxvQkFBb0Isd05BQXdOLG9MQUFvTCx3QkFBd0IsOENBQThDOztBQUV6dkUsbUNBQW1DLG9CQUFvQixhQUFhLGtCQUFrQixzQkFBc0IsbUJBQW1CLHFCQUFxQix1QkFBdUIsV0FBVyxhQUFhLFVBQVUseUNBQXlDLGtCQUFrQixXQUFXLFVBQVUsb0JBQW9CLHFCQUFxQixPQUFPLE1BQU0sWUFBWSx5QkFBeUIsV0FBVyxZQUFZLFFBQVEsb0JBQW9CLE9BQU8sVUFBVSxZQUFZLHlCQUF5QixXQUFXLFlBQVksUUFBUSx3QkFBd0Isa0JBQWtCLE9BQU8sUUFBUSxRQUFRLFNBQVMsaUJBQWlCLGtCQUFrQixhQUFhLGdCQUFnQixrQkFBa0Isd0JBQXdCLFlBQVksbUNBQW1DLDJCQUEyQixXQUFXLCtGQUErRix3QkFBd0Isa0JBQWtCLG1CQUFtQiwwQkFBMEIseUJBQXlCLHdCQUF3Qix3QkFBd0IsWUFBWSxrQkFBa0IsTUFBTSxPQUFPLFFBQVEsU0FBUyxXQUFXLFlBQVksU0FBUyxVQUFVLFNBQVMsVUFBVSxtQkFBbUIsVUFBVSxnQkFBZ0Isd0JBQXdCLHFCQUFxQiwwREFBMEQsaUJBQWlCLHlEQUF5RCxlQUFlLHFCQUFxQixtT0FBbU8sb0xBQW9MLG9CQUFvQixtT0FBbU8saUxBQWlMOztBQUVsc0U7QUFDQTtBQUNBLElBQUkscURBQWdCO0FBQ3BCLDhCQUE4QixxREFBVztBQUN6QztBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0NBQW9DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlDQUF5QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFjO0FBQ2xCLElBQUksdURBQWM7QUFDbEI7QUFDQTtBQUNBLFlBQVkscURBQUMsQ0FBQyxpREFBSSxJQUFJLDhFQUE4RSxFQUFFLHFEQUFDLFlBQVksa0xBQWtMLEdBQUcscURBQUMsVUFBVSx3QkFBd0IsR0FBRyxxREFBQyxVQUFVLHVCQUF1QixHQUFHLHFEQUFDLFVBQVUsNkRBQTZELEdBQUcscURBQUM7QUFDL2I7QUFDQSxhQUFhLE9BQU8scURBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL2lvbi1waWNrZXItaW50ZXJuYWwuZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgZSBhcyBjcmVhdGVFdmVudCwgaCwgSCBhcyBIb3N0LCBpIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LTA2Y2QyN2IxLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0RWxlbWVudFJvb3QgfSBmcm9tICcuL2hlbHBlcnMtZWVkNzlhMmIuanMnO1xuXG5jb25zdCBwaWNrZXJJbnRlcm5hbElvc0NzcyA9IFwiOmhvc3R7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7cG9zaXRpb246cmVsYXRpdmU7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEwMCU7aGVpZ2h0OjIwMHB4O3otaW5kZXg6MH06aG9zdCAucGlja2VyLWJlZm9yZSw6aG9zdCAucGlja2VyLWFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCU7ei1pbmRleDoxO3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3QgLnBpY2tlci1iZWZvcmV7bGVmdDowO3RvcDowO2hlaWdodDo4M3B4fTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKXtsZWZ0OnVuc2V0O3JpZ2h0OnVuc2V0O3JpZ2h0OjB9Omhvc3QgLnBpY2tlci1hZnRlcntsZWZ0OjA7dG9wOjExNnB4O2hlaWdodDo4NHB4fTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKXtsZWZ0OnVuc2V0O3JpZ2h0OnVuc2V0O3JpZ2h0OjB9Omhvc3QgLnBpY2tlci1oaWdobGlnaHR7Ym9yZGVyLXJhZGl1czo4cHg7bGVmdDowO3JpZ2h0OjA7dG9wOjUwJTtib3R0b206MDttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6Y2FsYygxMDAlIC0gMTZweCk7aGVpZ2h0OjM0cHg7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt6LWluZGV4Oi0xfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3QgLnBpY2tlci1oaWdobGlnaHR7bWFyZ2luLWxlZnQ6dW5zZXQ7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OmF1dG87bWFyZ2luLWlubGluZS1zdGFydDphdXRvOy13ZWJraXQtbWFyZ2luLWVuZDphdXRvO21hcmdpbi1pbmxpbmUtZW5kOmF1dG99fTpob3N0IGlucHV0e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtyaWdodDowO2JvdHRvbTowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7bWFyZ2luOjA7cGFkZGluZzowO2JvcmRlcjowO291dGxpbmU6MDtjbGlwOnJlY3QoMCAwIDAgMCk7b3BhY2l0eTowO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTstbW96LWFwcGVhcmFuY2U6bm9uZX06aG9zdCA6OnNsb3R0ZWQoaW9uLXBpY2tlci1jb2x1bW4taW50ZXJuYWw6Zmlyc3Qtb2YtdHlwZSl7dGV4dC1hbGlnbjpzdGFydH06aG9zdCA6OnNsb3R0ZWQoaW9uLXBpY2tlci1jb2x1bW4taW50ZXJuYWw6bGFzdC1vZi10eXBlKXt0ZXh0LWFsaWduOmVuZH06aG9zdCAucGlja2VyLWJlZm9yZXtiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0IHRvcCwgbGVmdCBib3R0b20sIGNvbG9yLXN0b3AoMjAlLCB2YXIoLS1iYWNrZ3JvdW5kLCB2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvciwgI2ZmZikpKSwgdG8ocmdiYSh2YXIoLS1iYWNrZ3JvdW5kLXJnYiwgdmFyKC0taW9uLWJhY2tncm91bmQtY29sb3ItcmdiLCAyNTUsIDI1NSwgMjU1KSksIDAuOCkpKTtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20sIHZhcigtLWJhY2tncm91bmQsIHZhcigtLWlvbi1iYWNrZ3JvdW5kLWNvbG9yLCAjZmZmKSkgMjAlLCByZ2JhKHZhcigtLWJhY2tncm91bmQtcmdiLCB2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvci1yZ2IsIDI1NSwgMjU1LCAyNTUpKSwgMC44KSAxMDAlKX06aG9zdCAucGlja2VyLWFmdGVye2JhY2tncm91bmQ6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIGxlZnQgYm90dG9tLCBsZWZ0IHRvcCwgY29sb3Itc3RvcCgyMCUsIHZhcigtLWJhY2tncm91bmQsIHZhcigtLWlvbi1iYWNrZ3JvdW5kLWNvbG9yLCAjZmZmKSkpLCB0byhyZ2JhKHZhcigtLWJhY2tncm91bmQtcmdiLCB2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvci1yZ2IsIDI1NSwgMjU1LCAyNTUpKSwgMC44KSkpO2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIHRvcCwgdmFyKC0tYmFja2dyb3VuZCwgdmFyKC0taW9uLWJhY2tncm91bmQtY29sb3IsICNmZmYpKSAyMCUsIHJnYmEodmFyKC0tYmFja2dyb3VuZC1yZ2IsIHZhcigtLWlvbi1iYWNrZ3JvdW5kLWNvbG9yLXJnYiwgMjU1LCAyNTUsIDI1NSkpLCAwLjgpIDEwMCUpfTpob3N0IC5waWNrZXItaGlnaGxpZ2h0e2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLXN0ZXAtMTUwLCAjZWVlZWVmKX1cIjtcblxuY29uc3QgcGlja2VySW50ZXJuYWxNZENzcyA9IFwiOmhvc3R7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7cG9zaXRpb246cmVsYXRpdmU7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEwMCU7aGVpZ2h0OjIwMHB4O3otaW5kZXg6MH06aG9zdCAucGlja2VyLWJlZm9yZSw6aG9zdCAucGlja2VyLWFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCU7ei1pbmRleDoxO3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3QgLnBpY2tlci1iZWZvcmV7bGVmdDowO3RvcDowO2hlaWdodDo4M3B4fTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKXtsZWZ0OnVuc2V0O3JpZ2h0OnVuc2V0O3JpZ2h0OjB9Omhvc3QgLnBpY2tlci1hZnRlcntsZWZ0OjA7dG9wOjExNnB4O2hlaWdodDo4NHB4fTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKXtsZWZ0OnVuc2V0O3JpZ2h0OnVuc2V0O3JpZ2h0OjB9Omhvc3QgLnBpY2tlci1oaWdobGlnaHR7Ym9yZGVyLXJhZGl1czo4cHg7bGVmdDowO3JpZ2h0OjA7dG9wOjUwJTtib3R0b206MDttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6Y2FsYygxMDAlIC0gMTZweCk7aGVpZ2h0OjM0cHg7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt6LWluZGV4Oi0xfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3QgLnBpY2tlci1oaWdobGlnaHR7bWFyZ2luLWxlZnQ6dW5zZXQ7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OmF1dG87bWFyZ2luLWlubGluZS1zdGFydDphdXRvOy13ZWJraXQtbWFyZ2luLWVuZDphdXRvO21hcmdpbi1pbmxpbmUtZW5kOmF1dG99fTpob3N0IGlucHV0e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtyaWdodDowO2JvdHRvbTowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7bWFyZ2luOjA7cGFkZGluZzowO2JvcmRlcjowO291dGxpbmU6MDtjbGlwOnJlY3QoMCAwIDAgMCk7b3BhY2l0eTowO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTstbW96LWFwcGVhcmFuY2U6bm9uZX06aG9zdCA6OnNsb3R0ZWQoaW9uLXBpY2tlci1jb2x1bW4taW50ZXJuYWw6Zmlyc3Qtb2YtdHlwZSl7dGV4dC1hbGlnbjpzdGFydH06aG9zdCA6OnNsb3R0ZWQoaW9uLXBpY2tlci1jb2x1bW4taW50ZXJuYWw6bGFzdC1vZi10eXBlKXt0ZXh0LWFsaWduOmVuZH06aG9zdCAucGlja2VyLWJlZm9yZXtiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0IHRvcCwgbGVmdCBib3R0b20sIGNvbG9yLXN0b3AoMjAlLCB2YXIoLS1iYWNrZ3JvdW5kLCB2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvciwgI2ZmZikpKSwgY29sb3Itc3RvcCg5MCUsIHJnYmEodmFyKC0tYmFja2dyb3VuZC1yZ2IsIHZhcigtLWlvbi1iYWNrZ3JvdW5kLWNvbG9yLXJnYiwgMjU1LCAyNTUsIDI1NSkpLCAwKSkpO2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgdmFyKC0tYmFja2dyb3VuZCwgdmFyKC0taW9uLWJhY2tncm91bmQtY29sb3IsICNmZmYpKSAyMCUsIHJnYmEodmFyKC0tYmFja2dyb3VuZC1yZ2IsIHZhcigtLWlvbi1iYWNrZ3JvdW5kLWNvbG9yLXJnYiwgMjU1LCAyNTUsIDI1NSkpLCAwKSA5MCUpfTpob3N0IC5waWNrZXItYWZ0ZXJ7YmFja2dyb3VuZDotd2Via2l0LWdyYWRpZW50KGxpbmVhciwgbGVmdCBib3R0b20sIGxlZnQgdG9wLCBjb2xvci1zdG9wKDMwJSwgdmFyKC0tYmFja2dyb3VuZCwgdmFyKC0taW9uLWJhY2tncm91bmQtY29sb3IsICNmZmYpKSksIGNvbG9yLXN0b3AoOTAlLCByZ2JhKHZhcigtLWJhY2tncm91bmQtcmdiLCB2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvci1yZ2IsIDI1NSwgMjU1LCAyNTUpKSwgMCkpKTtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCh0byB0b3AsIHZhcigtLWJhY2tncm91bmQsIHZhcigtLWlvbi1iYWNrZ3JvdW5kLWNvbG9yLCAjZmZmKSkgMzAlLCByZ2JhKHZhcigtLWJhY2tncm91bmQtcmdiLCB2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvci1yZ2IsIDI1NSwgMjU1LCAyNTUpKSwgMCkgOTAlKX1cIjtcblxubGV0IFBpY2tlckludGVybmFsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmlvbklucHV0TW9kZUNoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiaW9uSW5wdXRNb2RlQ2hhbmdlXCIsIDcpO1xuICAgIHRoaXMudXNlSW5wdXRNb2RlID0gZmFsc2U7XG4gICAgdGhpcy5pc0luSGlnaGxpZ2h0Qm91bmRzID0gKGV2KSA9PiB7XG4gICAgICBjb25zdCB7IGhpZ2hsaWdodEVsIH0gPSB0aGlzO1xuICAgICAgaWYgKCFoaWdobGlnaHRFbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBiYm94ID0gaGlnaGxpZ2h0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIHRvIHNlZSBpZiB0aGUgdXNlciBjbGlja2VkXG4gICAgICAgKiBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIGhpZ2hsaWdodC5cbiAgICAgICAqL1xuICAgICAgY29uc3Qgb3V0c2lkZVggPSBldi5jbGllbnRYIDwgYmJveC5sZWZ0IHx8IGV2LmNsaWVudFggPiBiYm94LnJpZ2h0O1xuICAgICAgY29uc3Qgb3V0c2lkZVkgPSBldi5jbGllbnRZIDwgYmJveC50b3AgfHwgZXYuY2xpZW50WSA+IGJib3guYm90dG9tO1xuICAgICAgaWYgKG91dHNpZGVYIHx8IG91dHNpZGVZKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgd2UgYXJlIG5vIGxvbmdlciBmb2N1c2VkXG4gICAgICogb24gYSBwaWNrZXIgY29sdW1uLCB0aGVuIHdlIHNob3VsZFxuICAgICAqIGV4aXQgaW5wdXQgbW9kZS4gQW4gZXhjZXB0aW9uIGlzIG1hZGVcbiAgICAgKiBmb3IgdGhlIGlucHV0IGluIHRoZSBwaWNrZXIgc2luY2UgaGF2aW5nXG4gICAgICogdGhhdCBmb2N1c2VkIG1lYW5zIHdlIGFyZSBzdGlsbCBpbiBpbnB1dCBtb2RlLlxuICAgICAqL1xuICAgIHRoaXMub25Gb2N1c091dCA9IChldikgPT4ge1xuICAgICAgY29uc3QgeyByZWxhdGVkVGFyZ2V0IH0gPSBldjtcbiAgICAgIGlmICghcmVsYXRlZFRhcmdldCB8fFxuICAgICAgICByZWxhdGVkVGFyZ2V0LnRhZ05hbWUgIT09ICdJT04tUElDS0VSLUNPTFVNTi1JTlRFUk5BTCcgJiYgcmVsYXRlZFRhcmdldCAhPT0gdGhpcy5pbnB1dEVsKSB7XG4gICAgICAgIHRoaXMuZXhpdElucHV0TW9kZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiBwaWNrZXIgY29sdW1ucyByZWNlaXZlIGZvY3VzXG4gICAgICogdGhlIHBhcmVudCBwaWNrZXIgbmVlZHMgdG8gZGV0ZXJtaW5lXG4gICAgICogd2hldGhlciB0byBlbnRlci9leGl0IGlucHV0IG1vZGUuXG4gICAgICovXG4gICAgdGhpcy5vbkZvY3VzSW4gPSAoZXYpID0+IHtcbiAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBldjtcbiAgICAgIC8qKlxuICAgICAgICogRHVlIHRvIGJyb3dzZXIgZGlmZmVyZW5jZXMgaW4gaG93L3doZW4gZm9jdXNcbiAgICAgICAqIGlzIGRpc3BhdGNoZWQgb24gY2VydGFpbiBlbGVtZW50cywgd2UgbmVlZCB0b1xuICAgICAgICogbWFrZSBzdXJlIHRoYXQgdGhpcyBmdW5jdGlvbiBvbmx5IGV2ZXIgcnVucyB3aGVuXG4gICAgICAgKiBmb2N1c2luZyBhIHBpY2tlciBjb2x1bW4uXG4gICAgICAgKi9cbiAgICAgIGlmICh0YXJnZXQudGFnTmFtZSAhPT0gJ0lPTi1QSUNLRVItQ09MVU1OLUlOVEVSTkFMJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIElmIHdlIGhhdmUgYWN0aW9uT25DbGlja1xuICAgICAgICogdGhlbiB0aGlzIG1lYW5zIHRoZSB1c2VyIGZvY3VzZWRcbiAgICAgICAqIGEgcGlja2VyIGNvbHVtbiB2aWEgbW91c2Ugb3JcbiAgICAgICAqIHRvdWNoIChpLmUuIGEgUG9pbnRlckV2ZW50KS4gQXMgYSByZXN1bHQsXG4gICAgICAgKiB3ZSBzaG91bGQgbm90IGVudGVyL2V4aXQgaW5wdXQgbW9kZVxuICAgICAgICogdW50aWwgdGhlIGNsaWNrIGV2ZW50IGhhcyBmaXJlZCwgd2hpY2ggaGFwcGVuc1xuICAgICAgICogYWZ0ZXIgdGhlIGBmb2N1c2luYCBldmVudC5cbiAgICAgICAqXG4gICAgICAgKiBPdGhlcndpc2UsIHRoZSB1c2VyIGxpa2VseSBmb2N1c2VkXG4gICAgICAgKiB0aGUgY29sdW1uIHVzaW5nIHRoZWlyIGtleWJvYXJkIGFuZFxuICAgICAgICogd2Ugc2hvdWxkIGVudGVyL2V4aXQgaW5wdXQgbW9kZSBhdXRvbWF0aWNhbGx5LlxuICAgICAgICovXG4gICAgICBpZiAoIXRoaXMuYWN0aW9uT25DbGljaykge1xuICAgICAgICBjb25zdCBjb2x1bW5FbCA9IHRhcmdldDtcbiAgICAgICAgY29uc3QgYWxsb3dJbnB1dCA9IGNvbHVtbkVsLm51bWVyaWNJbnB1dDtcbiAgICAgICAgaWYgKGFsbG93SW5wdXQpIHtcbiAgICAgICAgICB0aGlzLmVudGVySW5wdXRNb2RlKGNvbHVtbkVsLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5leGl0SW5wdXRNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9uIGNsaWNrIHdlIG5lZWQgdG8gcnVuIGFuIGFjdGlvbk9uQ2xpY2tcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIHNldCBpbiBvblBvaW50ZXJEb3duXG4gICAgICogc28gdGhhdCB3ZSBlbnRlci9leGl0IGlucHV0IG1vZGUgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIHRoaXMub25DbGljayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgYWN0aW9uT25DbGljayB9ID0gdGhpcztcbiAgICAgIGlmIChhY3Rpb25PbkNsaWNrKSB7XG4gICAgICAgIGFjdGlvbk9uQ2xpY2soKTtcbiAgICAgICAgdGhpcy5hY3Rpb25PbkNsaWNrID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xpY2tpbmcgYSBjb2x1bW4gYWxzbyBmb2N1c2VzIHRoZSBjb2x1bW4gb25cbiAgICAgKiBjZXJ0YWluIGJyb3dzZXJzLCBzbyB3ZSB1c2Ugb25Qb2ludGVyRG93blxuICAgICAqIHRvIHRlbGwgdGhlIG9uRm9jdXNJbiBmdW5jdGlvbiB0aGF0IHVzZXJzXG4gICAgICogYXJlIHRyeWluZyB0byBjbGljayB0aGUgY29sdW1uIHJhdGhlciB0aGFuXG4gICAgICogZm9jdXMgdGhlIGNvbHVtbiB1c2luZyB0aGUga2V5Ym9hcmQuIFdoZW4gdGhlXG4gICAgICogdXNlciBjb21wbGV0ZXMgdGhlIGNsaWNrLCB0aGUgb25DbGljayBmdW5jdGlvblxuICAgICAqIHJ1bnMgYW5kIHJ1bnMgdGhlIGFjdGlvbk9uQ2xpY2sgY2FsbGJhY2suXG4gICAgICovXG4gICAgdGhpcy5vblBvaW50ZXJEb3duID0gKGV2KSA9PiB7XG4gICAgICBjb25zdCB7IHVzZUlucHV0TW9kZSwgaW5wdXRNb2RlQ29sdW1uLCBlbCB9ID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmlzSW5IaWdobGlnaHRCb3VuZHMoZXYpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSB3ZXJlIGFscmVhZHkgaW5cbiAgICAgICAgICogaW5wdXQgbW9kZSwgdGhlbiB3ZSBzaG91bGQgZGV0ZXJtaW5lXG4gICAgICAgICAqIGlmIHdlIHRhcHBlZCBhIHBhcnRpY3VsYXIgY29sdW1uIGFuZFxuICAgICAgICAgKiBzaG91bGQgc3dpdGNoIHRvIGlucHV0IG1vZGUgZm9yXG4gICAgICAgICAqIHRoYXQgc3BlY2lmaWMgY29sdW1uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHVzZUlucHV0TW9kZSkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIHdlIHRhcHBlZCBhIHBpY2tlciBjb2x1bW5cbiAgICAgICAgICAgKiB0aGVuIHdlIHNob3VsZCBlaXRoZXIgc3dpdGNoIHRvIGlucHV0XG4gICAgICAgICAgICogbW9kZSBmb3IgdGhhdCBjb2x1bW4gb3IgYWxsIGNvbHVtbnMuXG4gICAgICAgICAgICogT3RoZXJ3aXNlIHdlIHNob3VsZCBleGl0IGlucHV0IG1vZGVcbiAgICAgICAgICAgKiBzaW5jZSB3ZSBqdXN0IHRhcHBlZCB0aGUgaGlnaGxpZ2h0IGFuZFxuICAgICAgICAgICAqIG5vdCBhIGNvbHVtbi5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdJT04tUElDS0VSLUNPTFVNTi1JTlRFUk5BTCcpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdXNlciB0YXBzIDIgZGlmZmVyZW50IGNvbHVtbnNcbiAgICAgICAgICAgICAqIHRoZW4gd2Ugc2hvdWxkIGp1c3Qgc3dpdGNoIHRvIGlucHV0IG1vZGVcbiAgICAgICAgICAgICAqIGZvciB0aGUgbmV3IGNvbHVtbiByYXRoZXIgdGhhbiBzd2l0Y2hpbmcgdG9cbiAgICAgICAgICAgICAqIGlucHV0IG1vZGUgZm9yIGFsbCBjb2x1bW5zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaW5wdXRNb2RlQ29sdW1uICYmIGlucHV0TW9kZUNvbHVtbiA9PT0gZXYudGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHRoaXMuYWN0aW9uT25DbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVySW5wdXRNb2RlKCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hY3Rpb25PbkNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJJbnB1dE1vZGUoZXYudGFyZ2V0KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbk9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuZXhpdElucHV0TW9kZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSWYgd2Ugd2VyZSBub3QgYWxyZWFkeSBpblxuICAgICAgICAgICAqIGlucHV0IG1vZGUsIHRoZW4gd2Ugc2hvdWxkXG4gICAgICAgICAgICogZW50ZXIgaW5wdXQgbW9kZSBmb3IgYWxsIGNvbHVtbnMuXG4gICAgICAgICAgICovXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSWYgdGhlcmUgaXMgb25seSAxIG51bWVyaWMgaW5wdXQgY29sdW1uXG4gICAgICAgICAgICogdGhlbiB3ZSBzaG91bGQgc2tpcCBtdWx0aSBjb2x1bW4gaW5wdXQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgY29sdW1ucyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lvbi1waWNrZXItY29sdW1uLWludGVybmFsLnBpY2tlci1jb2x1bW4tbnVtZXJpYy1pbnB1dCcpO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbkVsID0gKGNvbHVtbnMubGVuZ3RoID09PSAxKSA/IGV2LnRhcmdldCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLmFjdGlvbk9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVudGVySW5wdXRNb2RlKGNvbHVtbkVsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aW9uT25DbGljayA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5leGl0SW5wdXRNb2RlKCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW50ZXJzIGlucHV0IG1vZGUgdG8gYWxsb3dcbiAgICAgKiBmb3IgdGV4dCBlbnRyeSBvZiBudW1lcmljIHZhbHVlcy5cbiAgICAgKiBJZiBvbiBtb2JpbGUsIHdlIGZvY3VzIGEgaGlkZGVuIGlucHV0XG4gICAgICogZmllbGQgc28gdGhhdCB0aGUgb24gc2NyZWVuIGtleWJvYXJkXG4gICAgICogaXMgYnJvdWdodCB1cC4gV2hlbiB0YWJiaW5nIHVzaW5nIGFcbiAgICAgKiBrZXlib2FyZCwgcGlja2VyIGNvbHVtbnMgcmVjZWl2ZSBhbiBvdXRsaW5lXG4gICAgICogdG8gaW5kaWNhdGUgdGhleSBhcmUgZm9jdXNlZC4gQXMgYSByZXN1bHQsXG4gICAgICogd2Ugc2hvdWxkIG5vdCBmb2N1cyB0aGUgaGlkZGVuIGlucHV0IGFzIGl0XG4gICAgICogd291bGQgY2F1c2UgdGhlIG91dGxpbmUgdG8gZ28gYXdheSwgcHJldmVudGluZ1xuICAgICAqIHVzZXJzIGZyb20gaGF2aW5nIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiB3aGljaFxuICAgICAqIGNvbHVtbiBpcyBmb2N1c2VkLlxuICAgICAqL1xuICAgIHRoaXMuZW50ZXJJbnB1dE1vZGUgPSAoY29sdW1uRWwsIGZvY3VzSW5wdXQgPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCB7IGlucHV0RWwsIGVsIH0gPSB0aGlzO1xuICAgICAgaWYgKCFpbnB1dEVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogT25seSBhY3RpdmUgaW5wdXQgbW9kZSBpZiB0aGVyZSBpcyBhdFxuICAgICAgICogbGVhc3Qgb25lIGNvbHVtbiB0aGF0IGFjY2VwdHMgbnVtZXJpYyBpbnB1dC5cbiAgICAgICAqL1xuICAgICAgY29uc3QgaGFzSW5wdXRDb2x1bW4gPSBlbC5xdWVyeVNlbGVjdG9yKCdpb24tcGlja2VyLWNvbHVtbi1pbnRlcm5hbC5waWNrZXItY29sdW1uLW51bWVyaWMtaW5wdXQnKTtcbiAgICAgIGlmICghaGFzSW5wdXRDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJZiBjb2x1bW5FbCBpcyB1bmRlZmluZWQgdGhlblxuICAgICAgICogaXQgaXMgYXNzdW1lZCB0aGF0IGFsbCBudW1lcmljIHBpY2tlcnNcbiAgICAgICAqIGFyZSBlbGlnaWJsZSBmb3IgdGV4dCBlbnRyeS5cbiAgICAgICAqIChpLmUuIGhvdXIgYW5kIG1pbnV0ZSBjb2x1bW5zKVxuICAgICAgICovXG4gICAgICB0aGlzLnVzZUlucHV0TW9kZSA9IHRydWU7XG4gICAgICB0aGlzLmlucHV0TW9kZUNvbHVtbiA9IGNvbHVtbkVsO1xuICAgICAgLyoqXG4gICAgICAgKiBVc2VycyB3aXRoIGEga2V5Ym9hcmQgYW5kIG1vdXNlIGNhblxuICAgICAgICogYWN0aXZhdGUgaW5wdXQgbW9kZSB3aGVyZSB0aGUgaW5wdXQgaXNcbiAgICAgICAqIGZvY3VzZWQgYXMgd2VsbCBhcyB3aGVuIGl0IGlzIG5vdCBmb2N1c2VkLFxuICAgICAgICogc28gd2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgY2xlYW4gdXAgYW55XG4gICAgICAgKiBvbGQgbGlzdGVuZXJzLlxuICAgICAgICovXG4gICAgICBpZiAoZm9jdXNJbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95S2V5cHJlc3NMaXN0ZW5lcikge1xuICAgICAgICAgIHRoaXMuZGVzdHJveUtleXByZXNzTGlzdGVuZXIoKTtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3lLZXlwcmVzc0xpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0RWwuZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMub25LZXlQcmVzcyk7XG4gICAgICAgIHRoaXMuZGVzdHJveUtleXByZXNzTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLm9uS2V5UHJlc3MpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0SW5wdXRNb2RlQ2hhbmdlKCk7XG4gICAgfTtcbiAgICB0aGlzLmV4aXRJbnB1dE1vZGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IGlucHV0RWwsIHVzZUlucHV0TW9kZSB9ID0gdGhpcztcbiAgICAgIGlmICghdXNlSW5wdXRNb2RlIHx8ICFpbnB1dEVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudXNlSW5wdXRNb2RlID0gZmFsc2U7XG4gICAgICB0aGlzLmlucHV0TW9kZUNvbHVtbiA9IHVuZGVmaW5lZDtcbiAgICAgIGlucHV0RWwuYmx1cigpO1xuICAgICAgaW5wdXRFbC52YWx1ZSA9ICcnO1xuICAgICAgaWYgKHRoaXMuZGVzdHJveUtleXByZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95S2V5cHJlc3NMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lLZXlwcmVzc0xpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0SW5wdXRNb2RlQ2hhbmdlKCk7XG4gICAgfTtcbiAgICB0aGlzLm9uS2V5UHJlc3MgPSAoZXYpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5wdXRFbCB9ID0gdGhpcztcbiAgICAgIGlmICghaW5wdXRFbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlSW50KGV2LmtleSwgMTApO1xuICAgICAgLyoqXG4gICAgICAgKiBPbmx5IG51bWJlcnMgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICAgICAqL1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgIGlucHV0RWwudmFsdWUgKz0gZXYua2V5O1xuICAgICAgICB0aGlzLm9uSW5wdXRDaGFuZ2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0U2luZ2xlQ29sdW1uID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyBpbnB1dEVsLCBpbnB1dE1vZGVDb2x1bW4sIHNpbmdsZUNvbHVtblNlYXJjaFRpbWVvdXQgfSA9IHRoaXM7XG4gICAgICBpZiAoIWlucHV0RWwgfHwgIWlucHV0TW9kZUNvbHVtbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZXMgPSBpbnB1dE1vZGVDb2x1bW4uaXRlbXM7XG4gICAgICAvKipcbiAgICAgICAqIElmIHVzZXJzIHBhdXNlIGZvciBhIGJpdCwgdGhlIHNlYXJjaFxuICAgICAgICogdmFsdWUgc2hvdWxkIGJlIHJlc2V0IHNpbWlsYXIgdG8gaG93IGFcbiAgICAgICAqIDxzZWxlY3Q+IGJlaGF2ZXMuIFNvIHR5cGluZyBcIjM0XCIsIHdhaXRpbmcsXG4gICAgICAgKiB0aGVuIHR5cGluZyBcIjVcIiBzaG91bGQgc2VsZWN0IFwiMDVcIi5cbiAgICAgICAqL1xuICAgICAgaWYgKHNpbmdsZUNvbHVtblNlYXJjaFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNpbmdsZUNvbHVtblNlYXJjaFRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgdGhpcy5zaW5nbGVDb2x1bW5TZWFyY2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlucHV0RWwudmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy5zaW5nbGVDb2x1bW5TZWFyY2hUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgfSwgMTAwMCk7XG4gICAgICAvKipcbiAgICAgICAqIEZvciB2YWx1ZXMgdGhhdCBhcmUgbG9uZ2VyIHRoYW4gMiBkaWdpdHMgbG9uZ1xuICAgICAgICogd2Ugc2hvdWxkIHNoaWZ0IHRoZSB2YWx1ZSBvdmVyIDEgY2hhcmFjdGVyXG4gICAgICAgKiB0byB0aGUgbGVmdC4gU28gdHlwaW5nIFwiNDU2XCIgd291bGQgcmVzdWx0IGluIFwiNTZcIi5cbiAgICAgICAqIFRPRE86IElmIHdlIHdhbnQgdG8gc3VwcG9ydCBtb3JlIHRoYW4ganVzdFxuICAgICAgICogdGltZSBlbnRyeSwgd2Ugc2hvdWxkIHVwZGF0ZSB0aGlzIHZhbHVlIHRvIGJlXG4gICAgICAgKiB0aGUgbWF4IGxlbmd0aCBvZiBhbGwgb2YgdGhlIHBpY2tlciBpdGVtcy5cbiAgICAgICAqL1xuICAgICAgaWYgKGlucHV0RWwudmFsdWUubGVuZ3RoID49IDMpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IGlucHV0RWwudmFsdWUubGVuZ3RoIC0gMjtcbiAgICAgICAgY29uc3QgbmV3U3RyaW5nID0gaW5wdXRFbC52YWx1ZS5zdWJzdHJpbmcoc3RhcnRJbmRleCk7XG4gICAgICAgIGlucHV0RWwudmFsdWUgPSBuZXdTdHJpbmc7XG4gICAgICAgIHRoaXMuc2VsZWN0U2luZ2xlQ29sdW1uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tpbmcgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBnZXRzIHByaW9yaXR5XG4gICAgICAgKiBmaXJzdC4gRm9yIGV4YW1wbGUsIGlmIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXRcbiAgICAgICAqIGlzIFwiMVwiIGFuZCB3ZSBlbnRlcmVkIFwiMlwiLCB0aGVuIHRoZSBjb21wbGV0ZSB2YWx1ZVxuICAgICAgICogaXMgXCIxMlwiIGFuZCB3ZSBzaG91bGQgc2VsZWN0IGhvdXIgMTIuXG4gICAgICAgKlxuICAgICAgICogUmVnZXggcmVtb3ZlcyBhbnkgbGVhZGluZyB6ZXJvcyBmcm9tIHZhbHVlcyBsaWtlIFwiMDJcIi5cbiAgICAgICAqL1xuICAgICAgY29uc3QgZmluZEl0ZW1Gcm9tQ29tcGxldGVWYWx1ZSA9IHZhbHVlcy5maW5kKCh7IHRleHQgfSkgPT4gdGV4dC5yZXBsYWNlKC9eMCsvLCAnJykgPT09IGlucHV0RWwudmFsdWUpO1xuICAgICAgaWYgKGZpbmRJdGVtRnJvbUNvbXBsZXRlVmFsdWUpIHtcbiAgICAgICAgaW5wdXRNb2RlQ29sdW1uLnZhbHVlID0gZmluZEl0ZW1Gcm9tQ29tcGxldGVWYWx1ZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJZiB3ZSB0eXBlZCBcIjU2XCIgdG8gZ2V0IG1pbnV0ZSA1NiwgdGhlbiB0eXBlZCBcIjdcIixcbiAgICAgICAqIHdlIHNob3VsZCBzZWxlY3QgXCIwN1wiIGFzIFwiNTY3XCIgaXMgbm90IGEgdmFsaWQgbWludXRlLlxuICAgICAgICovXG4gICAgICBpZiAoaW5wdXRFbC52YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZENoYXJhY3RlciA9IGlucHV0RWwudmFsdWUuc3Vic3RyaW5nKGlucHV0RWwudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlucHV0RWwudmFsdWUgPSBjaGFuZ2VkQ2hhcmFjdGVyO1xuICAgICAgICB0aGlzLnNlbGVjdFNpbmdsZUNvbHVtbigpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgYSBsaXN0IG9mIGNvbHVtbiBpdGVtcyBmb3IgYSBwYXJ0aWN1bGFyXG4gICAgICogdmFsdWUuIFRoaXMgaXMgY3VycmVudGx5IHVzZWQgZm9yIG51bWVyaWMgdmFsdWVzLlxuICAgICAqIFRoZSB6ZXJvQmVoYXZpb3IgY2FuIGJlIHNldCB0byBhY2NvdW50IGZvciBsZWFkaW5nXG4gICAgICogb3IgdHJhaWxpbmcgemVyb3Mgd2hlbiBsb29raW5nIGF0IHRoZSBpdGVtIHRleHQuXG4gICAgICovXG4gICAgdGhpcy5zZWFyY2hDb2x1bW4gPSAoY29sRWwsIHZhbHVlLCB6ZXJvQmVoYXZpb3IgPSAnc3RhcnQnKSA9PiB7XG4gICAgICBsZXQgaXRlbTtcbiAgICAgIGNvbnN0IGJlaGF2aW9yID0gemVyb0JlaGF2aW9yID09PSAnc3RhcnQnID8gL14wKy8gOiAvMCQvO1xuICAgICAgaXRlbSA9IGNvbEVsLml0ZW1zLmZpbmQoKHsgdGV4dCB9KSA9PiB0ZXh0LnJlcGxhY2UoYmVoYXZpb3IsICcnKSA9PT0gdmFsdWUpO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgY29sRWwudmFsdWUgPSBpdGVtLnZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zZWxlY3RNdWx0aUNvbHVtbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5wdXRFbCwgZWwgfSA9IHRoaXM7XG4gICAgICBpZiAoIWlucHV0RWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbnVtZXJpY1BpY2tlcnMgPSBBcnJheS5mcm9tKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lvbi1waWNrZXItY29sdW1uLWludGVybmFsJykpLmZpbHRlcihjb2wgPT4gY29sLm51bWVyaWNJbnB1dCk7XG4gICAgICBjb25zdCBmaXJzdENvbHVtbiA9IG51bWVyaWNQaWNrZXJzWzBdO1xuICAgICAgY29uc3QgbGFzdENvbHVtbiA9IG51bWVyaWNQaWNrZXJzWzFdO1xuICAgICAgbGV0IHZhbHVlID0gaW5wdXRFbC52YWx1ZTtcbiAgICAgIHN3aXRjaCAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aGlzLnNlYXJjaENvbHVtbihmaXJzdENvbHVtbiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBgMGAgb3IgYDFgIGl0IGlzXG4gICAgICAgICAgICogcG9zc2libGUgdGhhdCB1c2VycyBhcmUgdHJ5aW5nIHRvIHR5cGUgYDA5YFxuICAgICAgICAgICAqIG9yIGAxMWAgaW50byB0aGUgaG91ciBmaWVsZCwgc28gd2Ugc2hvdWxkIGxvb2tcbiAgICAgICAgICAgKiBhdCB0aGF0IGZpcnN0LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q2hhcmFjdGVyID0gaW5wdXRFbC52YWx1ZS5zdWJzdHJpbmcoMCwgMSk7XG4gICAgICAgICAgdmFsdWUgPSAoZmlyc3RDaGFyYWN0ZXIgPT09ICcwJyB8fCBmaXJzdENoYXJhY3RlciA9PT0gJzEnKSA/IGlucHV0RWwudmFsdWUgOiBmaXJzdENoYXJhY3RlcjtcbiAgICAgICAgICB0aGlzLnNlYXJjaENvbHVtbihmaXJzdENvbHVtbiwgdmFsdWUpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIG9ubHkgY2hlY2tlZCB0aGUgZmlyc3QgdmFsdWUsXG4gICAgICAgICAgICogd2UgY2FuIGNoZWNrIHRoZSBzZWNvbmQgdmFsdWVcbiAgICAgICAgICAgKiBmb3IgYSBtYXRjaCBpbiB0aGUgbWludXRlcyBjb2x1bW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBtaW51dGVWYWx1ZSA9IGlucHV0RWwudmFsdWUuc3Vic3RyaW5nKGlucHV0RWwudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaENvbHVtbihsYXN0Q29sdW1uLCBtaW51dGVWYWx1ZSwgJ2VuZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgYDBgIG9yIGAxYCBpdCBpc1xuICAgICAgICAgICAqIHBvc3NpYmxlIHRoYXQgdXNlcnMgYXJlIHRyeWluZyB0byB0eXBlIGAwOWBcbiAgICAgICAgICAgKiBvciBgMTFgIGludG8gdGhlIGhvdXIgZmllbGQsIHNvIHdlIHNob3VsZCBsb29rXG4gICAgICAgICAgICogYXQgdGhhdCBmaXJzdC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBmaXJzdENoYXJhY3RlckFnYWluID0gaW5wdXRFbC52YWx1ZS5zdWJzdHJpbmcoMCwgMSk7XG4gICAgICAgICAgdmFsdWUgPSAoZmlyc3RDaGFyYWN0ZXJBZ2FpbiA9PT0gJzAnIHx8IGZpcnN0Q2hhcmFjdGVyQWdhaW4gPT09ICcxJykgPyBpbnB1dEVsLnZhbHVlLnN1YnN0cmluZygwLCAyKSA6IGZpcnN0Q2hhcmFjdGVyQWdhaW47XG4gICAgICAgICAgdGhpcy5zZWFyY2hDb2x1bW4oZmlyc3RDb2x1bW4sIHZhbHVlKTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJZiBvbmx5IGNoZWNrZWQgdGhlIGZpcnN0IHZhbHVlLFxuICAgICAgICAgICAqIHdlIGNhbiBjaGVjayB0aGUgc2Vjb25kIHZhbHVlXG4gICAgICAgICAgICogZm9yIGEgbWF0Y2ggaW4gdGhlIG1pbnV0ZXMgY29sdW1uXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgbWludXRlVmFsdWUgPSAodmFsdWUubGVuZ3RoID09PSAxKSA/IGlucHV0RWwudmFsdWUuc3Vic3RyaW5nKDEpIDogaW5wdXRFbC52YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgdGhpcy5zZWFyY2hDb2x1bW4obGFzdENvbHVtbiwgbWludXRlVmFsdWUsICdlbmQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgYDBgIG9yIGAxYCBpdCBpc1xuICAgICAgICAgICAqIHBvc3NpYmxlIHRoYXQgdXNlcnMgYXJlIHRyeWluZyB0byB0eXBlIGAwOWBcbiAgICAgICAgICAgKiBvciBgMTFgIGludG8gdGhlIGhvdXIgZmllbGQsIHNvIHdlIHNob3VsZCBsb29rXG4gICAgICAgICAgICogYXQgdGhhdCBmaXJzdC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBmaXJzdENoYXJhY3RlckFnYWluQWdhaW4gPSBpbnB1dEVsLnZhbHVlLnN1YnN0cmluZygwLCAxKTtcbiAgICAgICAgICB2YWx1ZSA9IChmaXJzdENoYXJhY3RlckFnYWluQWdhaW4gPT09ICcwJyB8fCBmaXJzdENoYXJhY3RlckFnYWluQWdhaW4gPT09ICcxJykgPyBpbnB1dEVsLnZhbHVlLnN1YnN0cmluZygwLCAyKSA6IGZpcnN0Q2hhcmFjdGVyQWdhaW5BZ2FpbjtcbiAgICAgICAgICB0aGlzLnNlYXJjaENvbHVtbihmaXJzdENvbHVtbiwgdmFsdWUpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIG9ubHkgY2hlY2tlZCB0aGUgZmlyc3QgdmFsdWUsXG4gICAgICAgICAgICogd2UgY2FuIGNoZWNrIHRoZSBzZWNvbmQgdmFsdWVcbiAgICAgICAgICAgKiBmb3IgYSBtYXRjaCBpbiB0aGUgbWludXRlcyBjb2x1bW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBtaW51dGVWYWx1ZUFnYWluID0gKHZhbHVlLmxlbmd0aCA9PT0gMSkgPyBpbnB1dEVsLnZhbHVlLnN1YnN0cmluZygxLCBpbnB1dEVsLnZhbHVlLmxlbmd0aCkgOiBpbnB1dEVsLnZhbHVlLnN1YnN0cmluZygyLCBpbnB1dEVsLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgdGhpcy5zZWFyY2hDb2x1bW4obGFzdENvbHVtbiwgbWludXRlVmFsdWVBZ2FpbiwgJ2VuZCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBpbnB1dEVsLnZhbHVlLmxlbmd0aCAtIDQ7XG4gICAgICAgICAgY29uc3QgbmV3U3RyaW5nID0gaW5wdXRFbC52YWx1ZS5zdWJzdHJpbmcoc3RhcnRJbmRleCk7XG4gICAgICAgICAgaW5wdXRFbC52YWx1ZSA9IG5ld1N0cmluZztcbiAgICAgICAgICB0aGlzLnNlbGVjdE11bHRpQ29sdW1uKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBjb2x1bW5cbiAgICAgKiB0byBkZXRlcm1pbmUgd2hpY2ggdmFsdWUgdXNlcnMgYXJlIHRyeWluZ1xuICAgICAqIHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHRoaXMub25JbnB1dENoYW5nZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdXNlSW5wdXRNb2RlLCBpbnB1dEVsLCBpbnB1dE1vZGVDb2x1bW4gfSA9IHRoaXM7XG4gICAgICBpZiAoIXVzZUlucHV0TW9kZSB8fCAhaW5wdXRFbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXRNb2RlQ29sdW1uKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0U2luZ2xlQ29sdW1uKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3RNdWx0aUNvbHVtbigpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdCBpb25JbnB1dE1vZGVDaGFuZ2UuIFBpY2tlciBjb2x1bW5zXG4gICAgICogbGlzdGVuIGZvciB0aGlzIGV2ZW50IHRvIGRldGVybWluZSB3aGV0aGVyXG4gICAgICogb3Igbm90IHRoZWlyIGNvbHVtbiBpcyBcImFjdGl2ZVwiIGZvciB0ZXh0IGlucHV0LlxuICAgICAqL1xuICAgIHRoaXMuZW1pdElucHV0TW9kZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdXNlSW5wdXRNb2RlLCBpbnB1dE1vZGVDb2x1bW4gfSA9IHRoaXM7XG4gICAgICB0aGlzLmlvbklucHV0TW9kZUNoYW5nZS5lbWl0KHtcbiAgICAgICAgdXNlSW5wdXRNb2RlLFxuICAgICAgICBpbnB1dE1vZGVDb2x1bW5cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgZ2V0RWxlbWVudFJvb3QodGhpcy5lbCkuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMub25Gb2N1c0luKTtcbiAgICBnZXRFbGVtZW50Um9vdCh0aGlzLmVsKS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMub25Gb2N1c091dCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoaChIb3N0LCB7IG9uUG9pbnRlckRvd246IChldikgPT4gdGhpcy5vblBvaW50ZXJEb3duKGV2KSwgb25DbGljazogKCkgPT4gdGhpcy5vbkNsaWNrKCkgfSwgaChcImlucHV0XCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgdGFiaW5kZXg6IC0xLCBpbnB1dG1vZGU6IFwibnVtZXJpY1wiLCB0eXBlOiBcIm51bWJlclwiLCByZWY6IGVsID0+IHRoaXMuaW5wdXRFbCA9IGVsLCBvbklucHV0OiAoKSA9PiB0aGlzLm9uSW5wdXRDaGFuZ2UoKSwgb25CbHVyOiAoKSA9PiB0aGlzLmV4aXRJbnB1dE1vZGUoKSB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInBpY2tlci1iZWZvcmVcIiB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInBpY2tlci1hZnRlclwiIH0pLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwicGlja2VyLWhpZ2hsaWdodFwiLCByZWY6IGVsID0+IHRoaXMuaGlnaGxpZ2h0RWwgPSBlbCB9KSwgaChcInNsb3RcIiwgbnVsbCkpKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuUGlja2VySW50ZXJuYWwuc3R5bGUgPSB7XG4gIGlvczogcGlja2VySW50ZXJuYWxJb3NDc3MsXG4gIG1kOiBwaWNrZXJJbnRlcm5hbE1kQ3NzXG59O1xuXG5leHBvcnQgeyBQaWNrZXJJbnRlcm5hbCBhcyBpb25fcGlja2VyX2ludGVybmFsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=