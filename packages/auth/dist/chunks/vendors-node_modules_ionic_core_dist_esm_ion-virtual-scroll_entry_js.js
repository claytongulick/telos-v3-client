"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_ionic_core_dist_esm_ion-virtual-scroll_entry_js"],{

/***/ "../node_modules/@ionic/core/dist/esm/ion-virtual-scroll.entry.js":
/*!************************************************************************!*\
  !*** ../node_modules/@ionic/core/dist/esm/ion-virtual-scroll.entry.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_virtual_scroll": () => (/* binding */ VirtualScroll)
/* harmony export */ });
/* harmony import */ var _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-06cd27b1.js */ "../node_modules/@ionic/core/dist/esm/index-06cd27b1.js");
/* harmony import */ var _helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers-eed79a2b.js */ "../node_modules/@ionic/core/dist/esm/helpers-eed79a2b.js");
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */



const CELL_TYPE_ITEM = 'item';
const CELL_TYPE_HEADER = 'header';
const CELL_TYPE_FOOTER = 'footer';
const NODE_CHANGE_NONE = 0;
const NODE_CHANGE_POSITION = 1;
const NODE_CHANGE_CELL = 2;

const MIN_READS = 2;
const updateVDom = (dom, heightIndex, cells, range) => {
  // reset dom
  for (const node of dom) {
    node.change = NODE_CHANGE_NONE;
    node.d = true;
  }
  // try to match into exisiting dom
  const toMutate = [];
  const end = range.offset + range.length;
  for (let i = range.offset; i < end; i++) {
    const cell = cells[i];
    const node = dom.find(n => n.d && n.cell === cell);
    if (node) {
      const top = heightIndex[i];
      if (top !== node.top) {
        node.top = top;
        node.change = NODE_CHANGE_POSITION;
      }
      node.d = false;
    }
    else {
      toMutate.push(cell);
    }
  }
  // needs to append
  const pool = dom.filter(n => n.d);
  for (const cell of toMutate) {
    const node = pool.find(n => n.d && n.cell.type === cell.type);
    const index = cell.i;
    if (node) {
      node.d = false;
      node.change = NODE_CHANGE_CELL;
      node.cell = cell;
      node.top = heightIndex[index];
    }
    else {
      dom.push({
        d: false,
        cell,
        visible: true,
        change: NODE_CHANGE_CELL,
        top: heightIndex[index],
      });
    }
  }
  dom
    .filter(n => n.d && n.top !== -9999)
    .forEach(n => {
    n.change = NODE_CHANGE_POSITION;
    n.top = -9999;
  });
};
const doRender = (el, nodeRender, dom, updateCellHeight) => {
  const children = Array.from(el.children).filter(n => n.tagName !== 'TEMPLATE');
  const childrenNu = children.length;
  let child;
  for (let i = 0; i < dom.length; i++) {
    const node = dom[i];
    const cell = node.cell;
    // the cell change, the content must be updated
    if (node.change === NODE_CHANGE_CELL) {
      if (i < childrenNu) {
        child = children[i];
        nodeRender(child, cell, i);
      }
      else {
        const newChild = createNode(el, cell.type);
        child = nodeRender(newChild, cell, i) || newChild;
        child.classList.add('virtual-item');
        el.appendChild(child);
      }
      child['$ionCell'] = cell;
    }
    else {
      child = children[i];
    }
    // only update position when it changes
    if (node.change !== NODE_CHANGE_NONE) {
      child.style.transform = `translate3d(0,${node.top}px,0)`;
    }
    // update visibility
    const visible = cell.visible;
    if (node.visible !== visible) {
      if (visible) {
        child.classList.remove('virtual-loading');
      }
      else {
        child.classList.add('virtual-loading');
      }
      node.visible = visible;
    }
    // dynamic height
    if (cell.reads > 0) {
      updateCellHeight(cell, child);
      cell.reads--;
    }
  }
};
const createNode = (el, type) => {
  const template = getTemplate(el, type);
  if (template && el.ownerDocument) {
    return el.ownerDocument.importNode(template.content, true).children[0];
  }
  return null;
};
const getTemplate = (el, type) => {
  switch (type) {
    case CELL_TYPE_ITEM: return el.querySelector('template:not([name])');
    case CELL_TYPE_HEADER: return el.querySelector('template[name=header]');
    case CELL_TYPE_FOOTER: return el.querySelector('template[name=footer]');
  }
};
const getViewport = (scrollTop, vierportHeight, margin) => {
  return {
    top: Math.max(scrollTop - margin, 0),
    bottom: scrollTop + vierportHeight + margin
  };
};
const getRange = (heightIndex, viewport, buffer) => {
  const topPos = viewport.top;
  const bottomPos = viewport.bottom;
  // find top index
  let i = 0;
  for (; i < heightIndex.length; i++) {
    if (heightIndex[i] > topPos) {
      break;
    }
  }
  const offset = Math.max(i - buffer - 1, 0);
  // find bottom index
  for (; i < heightIndex.length; i++) {
    if (heightIndex[i] >= bottomPos) {
      break;
    }
  }
  const end = Math.min(i + buffer, heightIndex.length);
  const length = end - offset;
  return { offset, length };
};
const getShouldUpdate = (dirtyIndex, currentRange, range) => {
  const end = range.offset + range.length;
  return (dirtyIndex <= end ||
    currentRange.offset !== range.offset ||
    currentRange.length !== range.length);
};
const findCellIndex = (cells, index) => {
  const max = cells.length > 0 ? cells[cells.length - 1].index : 0;
  if (index === 0) {
    return 0;
  }
  else if (index === max + 1) {
    return cells.length;
  }
  else {
    return cells.findIndex(c => c.index === index);
  }
};
const inplaceUpdate = (dst, src, offset) => {
  if (offset === 0 && src.length >= dst.length) {
    return src;
  }
  for (let i = 0; i < src.length; i++) {
    dst[i + offset] = src[i];
  }
  return dst;
};
const calcCells = (items, itemHeight, headerHeight, footerHeight, headerFn, footerFn, approxHeaderHeight, approxFooterHeight, approxItemHeight, j, offset, len) => {
  const cells = [];
  const end = len + offset;
  for (let i = offset; i < end; i++) {
    const item = items[i];
    if (headerFn) {
      const value = headerFn(item, i, items);
      if (value != null) {
        cells.push({
          i: j++,
          type: CELL_TYPE_HEADER,
          value,
          index: i,
          height: headerHeight ? headerHeight(value, i) : approxHeaderHeight,
          reads: headerHeight ? 0 : MIN_READS,
          visible: !!headerHeight,
        });
      }
    }
    cells.push({
      i: j++,
      type: CELL_TYPE_ITEM,
      value: item,
      index: i,
      height: itemHeight ? itemHeight(item, i) : approxItemHeight,
      reads: itemHeight ? 0 : MIN_READS,
      visible: !!itemHeight,
    });
    if (footerFn) {
      const value = footerFn(item, i, items);
      if (value != null) {
        cells.push({
          i: j++,
          type: CELL_TYPE_FOOTER,
          value,
          index: i,
          height: footerHeight ? footerHeight(value, i) : approxFooterHeight,
          reads: footerHeight ? 0 : MIN_READS,
          visible: !!footerHeight,
        });
      }
    }
  }
  return cells;
};
const calcHeightIndex = (buf, cells, index) => {
  let acum = buf[index];
  for (let i = index; i < buf.length; i++) {
    buf[i] = acum;
    acum += cells[i].height;
  }
  return acum;
};
const resizeBuffer = (buf, len) => {
  if (!buf) {
    return new Uint32Array(len);
  }
  if (buf.length === len) {
    return buf;
  }
  else if (len > buf.length) {
    const newBuf = new Uint32Array(len);
    newBuf.set(buf);
    return newBuf;
  }
  else {
    return buf.subarray(0, len);
  }
};
const positionForIndex = (index, cells, heightIndex) => {
  const cell = cells.find(c => c.type === CELL_TYPE_ITEM && c.index === index);
  if (cell) {
    return heightIndex[cell.i];
  }
  return -1;
};

const virtualScrollCss = "ion-virtual-scroll{display:block;position:relative;width:100%;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-virtual-scroll>.virtual-loading{opacity:0}ion-virtual-scroll>.virtual-item{position:absolute !important;top:0 !important;right:0 !important;left:0 !important;-webkit-transition-duration:0ms;transition-duration:0ms;will-change:transform}";

let VirtualScroll = class {
  constructor(hostRef) {
    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.range = { offset: 0, length: 0 };
    this.viewportHeight = 0;
    this.cells = [];
    this.virtualDom = [];
    this.isEnabled = false;
    this.viewportOffset = 0;
    this.currentScrollTop = 0;
    this.indexDirty = 0;
    this.lastItemLen = 0;
    this.totalHeight = 0;
    /**
     * It is important to provide this
     * if virtual item height will be significantly larger than the default
     * The approximate height of each virtual item template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This height value can only use `px` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions before the item has been rendered.
     */
    this.approxItemHeight = 45;
    /**
     * The approximate height of each header template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This height value can only use `px` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions before the item has been rendered.
     */
    this.approxHeaderHeight = 30;
    /**
     * The approximate width of each footer template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This height value can only use `px` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions before the item has been rendered.
     */
    this.approxFooterHeight = 30;
    this.onScroll = () => {
      this.updateVirtualScroll();
    };
  }
  itemsChanged() {
    this.calcCells();
    this.updateVirtualScroll();
  }
  componentWillLoad() {
    console.warn(`[Deprecation Warning]: ion-virtual-scroll has been deprecated and will be removed in Ionic Framework v7.0. See https://ionicframework.com/docs/angular/virtual-scroll for migration steps.`);
  }
  async connectedCallback() {
    const contentEl = this.el.closest('ion-content');
    if (!contentEl) {
      console.error('<ion-virtual-scroll> must be used inside an <ion-content>');
      return;
    }
    this.scrollEl = await contentEl.getScrollElement();
    this.contentEl = contentEl;
    this.calcCells();
    this.updateState();
  }
  componentDidUpdate() {
    this.updateState();
  }
  disconnectedCallback() {
    this.scrollEl = undefined;
  }
  onResize() {
    this.calcCells();
    this.updateVirtualScroll();
  }
  /**
   * Returns the position of the virtual item at the given index.
   */
  positionForItem(index) {
    return Promise.resolve(positionForIndex(index, this.cells, this.getHeightIndex()));
  }
  /**
   * This method marks a subset of items as dirty, so they can be re-rendered. Items should be marked as
   * dirty any time the content or their style changes.
   *
   * The subset of items to be updated can are specifing by an offset and a length.
   */
  async checkRange(offset, len = -1) {
    // TODO: kind of hacky how we do in-place updated of the cells
    // array. this part needs a complete refactor
    if (!this.items) {
      return;
    }
    const length = (len === -1)
      ? this.items.length - offset
      : len;
    const cellIndex = findCellIndex(this.cells, offset);
    const cells = calcCells(this.items, this.itemHeight, this.headerHeight, this.footerHeight, this.headerFn, this.footerFn, this.approxHeaderHeight, this.approxFooterHeight, this.approxItemHeight, cellIndex, offset, length);
    this.cells = inplaceUpdate(this.cells, cells, cellIndex);
    this.lastItemLen = this.items.length;
    this.indexDirty = Math.max(offset - 1, 0);
    this.scheduleUpdate();
  }
  /**
   * This method marks the tail the items array as dirty, so they can be re-rendered.
   *
   * It's equivalent to calling:
   *
   * ```js
   * virtualScroll.checkRange(lastItemLen);
   * ```
   */
  async checkEnd() {
    if (this.items) {
      this.checkRange(this.lastItemLen);
    }
  }
  updateVirtualScroll() {
    // do nothing if virtual-scroll is disabled
    if (!this.isEnabled || !this.scrollEl) {
      return;
    }
    // unschedule future updates
    if (this.timerUpdate) {
      clearTimeout(this.timerUpdate);
      this.timerUpdate = undefined;
    }
    // schedule DOM operations into the stencil queue
    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.readVS.bind(this));
    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.c)(this.writeVS.bind(this));
  }
  readVS() {
    const { contentEl, scrollEl, el } = this;
    let topOffset = 0;
    let node = el;
    while (node && node !== contentEl) {
      topOffset += node.offsetTop;
      node = node.offsetParent;
    }
    this.viewportOffset = topOffset;
    if (scrollEl) {
      this.viewportHeight = scrollEl.offsetHeight;
      this.currentScrollTop = scrollEl.scrollTop;
    }
  }
  writeVS() {
    const dirtyIndex = this.indexDirty;
    // get visible viewport
    const scrollTop = this.currentScrollTop - this.viewportOffset;
    const viewport = getViewport(scrollTop, this.viewportHeight, 100);
    // compute lazily the height index
    const heightIndex = this.getHeightIndex();
    // get array bounds of visible cells base in the viewport
    const range = getRange(heightIndex, viewport, 2);
    // fast path, do nothing
    const shouldUpdate = getShouldUpdate(dirtyIndex, this.range, range);
    if (!shouldUpdate) {
      return;
    }
    this.range = range;
    // in place mutation of the virtual DOM
    updateVDom(this.virtualDom, heightIndex, this.cells, range);
    // Write DOM
    // Different code paths taken depending of the render API used
    if (this.nodeRender) {
      doRender(this.el, this.nodeRender, this.virtualDom, this.updateCellHeight.bind(this));
    }
    else if (this.domRender) {
      this.domRender(this.virtualDom);
    }
    else if (this.renderItem) {
      (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.j)(this);
    }
  }
  updateCellHeight(cell, node) {
    const update = () => {
      if (node['$ionCell'] === cell) {
        const style = window.getComputedStyle(node);
        const height = node.offsetHeight + parseFloat(style.getPropertyValue('margin-bottom'));
        this.setCellHeight(cell, height);
      }
    };
    if (node) {
      (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_1__.c)(node, update);
    }
    else {
      update();
    }
  }
  setCellHeight(cell, height) {
    const index = cell.i;
    // the cell might changed since the height update was scheduled
    if (cell !== this.cells[index]) {
      return;
    }
    if (cell.height !== height || cell.visible !== true) {
      cell.visible = true;
      cell.height = height;
      this.indexDirty = Math.min(this.indexDirty, index);
      this.scheduleUpdate();
    }
  }
  scheduleUpdate() {
    clearTimeout(this.timerUpdate);
    this.timerUpdate = setTimeout(() => this.updateVirtualScroll(), 100);
  }
  updateState() {
    const shouldEnable = !!(this.scrollEl &&
      this.cells);
    if (shouldEnable !== this.isEnabled) {
      this.enableScrollEvents(shouldEnable);
      if (shouldEnable) {
        this.updateVirtualScroll();
      }
    }
  }
  calcCells() {
    if (!this.items) {
      return;
    }
    this.lastItemLen = this.items.length;
    this.cells = calcCells(this.items, this.itemHeight, this.headerHeight, this.footerHeight, this.headerFn, this.footerFn, this.approxHeaderHeight, this.approxFooterHeight, this.approxItemHeight, 0, 0, this.lastItemLen);
    this.indexDirty = 0;
  }
  getHeightIndex() {
    if (this.indexDirty !== Infinity) {
      this.calcHeightIndex(this.indexDirty);
    }
    return this.heightIndex;
  }
  calcHeightIndex(index = 0) {
    // TODO: optimize, we don't need to calculate all the cells
    this.heightIndex = resizeBuffer(this.heightIndex, this.cells.length);
    this.totalHeight = calcHeightIndex(this.heightIndex, this.cells, index);
    this.indexDirty = Infinity;
  }
  enableScrollEvents(shouldListen) {
    if (this.rmEvent) {
      this.rmEvent();
      this.rmEvent = undefined;
    }
    const scrollEl = this.scrollEl;
    if (scrollEl) {
      this.isEnabled = shouldListen;
      scrollEl.addEventListener('scroll', this.onScroll);
      this.rmEvent = () => {
        scrollEl.removeEventListener('scroll', this.onScroll);
      };
    }
  }
  renderVirtualNode(node) {
    const { type, value, index } = node.cell;
    switch (type) {
      case CELL_TYPE_ITEM: return this.renderItem(value, index);
      case CELL_TYPE_HEADER: return this.renderHeader(value, index);
      case CELL_TYPE_FOOTER: return this.renderFooter(value, index);
    }
  }
  render() {
    return ((0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.H, { style: {
        height: `${this.totalHeight}px`
      } }, this.renderItem && ((0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)(VirtualProxy, { dom: this.virtualDom }, this.virtualDom.map(node => this.renderVirtualNode(node))))));
  }
  get el() { return (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.i)(this); }
  static get watchers() { return {
    "itemHeight": ["itemsChanged"],
    "headerHeight": ["itemsChanged"],
    "footerHeight": ["itemsChanged"],
    "items": ["itemsChanged"]
  }; }
};
const VirtualProxy = ({ dom }, children, utils) => {
  return utils.map(children, (child, i) => {
    const node = dom[i];
    const vattrs = child.vattrs || {};
    let classes = vattrs.class || '';
    classes += 'virtual-item ';
    if (!node.visible) {
      classes += 'virtual-loading';
    }
    return Object.assign(Object.assign({}, child), { vattrs: Object.assign(Object.assign({}, vattrs), { class: classes, style: Object.assign(Object.assign({}, vattrs.style), { transform: `translate3d(0,${node.top}px,0)` }) }) });
  });
};
VirtualScroll.style = virtualScrollCss;




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfZGlzdF9lc21faW9uLXZpcnR1YWwtc2Nyb2xsX2VudHJ5X2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUM0STtBQUM5RTs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxjQUFjLGtCQUFrQixXQUFXLGVBQWUseUJBQXlCLHNCQUFzQixxQkFBcUIsaUJBQWlCLG9DQUFvQyxVQUFVLGlDQUFpQyw2QkFBNkIsaUJBQWlCLG1CQUFtQixrQkFBa0IsZ0NBQWdDLHdCQUF3QixzQkFBc0I7O0FBRTVhO0FBQ0E7QUFDQSxJQUFJLHFEQUFnQjtBQUNwQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBUTtBQUNaLElBQUkscURBQVM7QUFDYjtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scURBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQWdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFDLENBQUMsaURBQUksSUFBSTtBQUN0QixtQkFBbUIsaUJBQWlCO0FBQ3BDLFNBQVMsc0JBQXNCLHFEQUFDLGlCQUFpQixzQkFBc0I7QUFDdkU7QUFDQSxhQUFhLE9BQU8scURBQVU7QUFDOUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWSxzQ0FBc0MsYUFBYSxxREFBcUQsbUJBQW1CLDRCQUE0QixTQUFTLFFBQVEsR0FBRyxHQUFHO0FBQ25PLEdBQUc7QUFDSDtBQUNBOztBQUUrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20vaW9uLXZpcnR1YWwtc2Nyb2xsLmVudHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGYgYXMgcmVhZFRhc2ssIGMgYXMgd3JpdGVUYXNrLCBqIGFzIGZvcmNlVXBkYXRlLCBoLCBIIGFzIEhvc3QsIGkgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtMDZjZDI3YjEuanMnO1xuaW1wb3J0IHsgYyBhcyBjb21wb25lbnRPblJlYWR5IH0gZnJvbSAnLi9oZWxwZXJzLWVlZDc5YTJiLmpzJztcblxuY29uc3QgQ0VMTF9UWVBFX0lURU0gPSAnaXRlbSc7XG5jb25zdCBDRUxMX1RZUEVfSEVBREVSID0gJ2hlYWRlcic7XG5jb25zdCBDRUxMX1RZUEVfRk9PVEVSID0gJ2Zvb3Rlcic7XG5jb25zdCBOT0RFX0NIQU5HRV9OT05FID0gMDtcbmNvbnN0IE5PREVfQ0hBTkdFX1BPU0lUSU9OID0gMTtcbmNvbnN0IE5PREVfQ0hBTkdFX0NFTEwgPSAyO1xuXG5jb25zdCBNSU5fUkVBRFMgPSAyO1xuY29uc3QgdXBkYXRlVkRvbSA9IChkb20sIGhlaWdodEluZGV4LCBjZWxscywgcmFuZ2UpID0+IHtcbiAgLy8gcmVzZXQgZG9tXG4gIGZvciAoY29uc3Qgbm9kZSBvZiBkb20pIHtcbiAgICBub2RlLmNoYW5nZSA9IE5PREVfQ0hBTkdFX05PTkU7XG4gICAgbm9kZS5kID0gdHJ1ZTtcbiAgfVxuICAvLyB0cnkgdG8gbWF0Y2ggaW50byBleGlzaXRpbmcgZG9tXG4gIGNvbnN0IHRvTXV0YXRlID0gW107XG4gIGNvbnN0IGVuZCA9IHJhbmdlLm9mZnNldCArIHJhbmdlLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IHJhbmdlLm9mZnNldDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY29uc3QgY2VsbCA9IGNlbGxzW2ldO1xuICAgIGNvbnN0IG5vZGUgPSBkb20uZmluZChuID0+IG4uZCAmJiBuLmNlbGwgPT09IGNlbGwpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBjb25zdCB0b3AgPSBoZWlnaHRJbmRleFtpXTtcbiAgICAgIGlmICh0b3AgIT09IG5vZGUudG9wKSB7XG4gICAgICAgIG5vZGUudG9wID0gdG9wO1xuICAgICAgICBub2RlLmNoYW5nZSA9IE5PREVfQ0hBTkdFX1BPU0lUSU9OO1xuICAgICAgfVxuICAgICAgbm9kZS5kID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdG9NdXRhdGUucHVzaChjZWxsKTtcbiAgICB9XG4gIH1cbiAgLy8gbmVlZHMgdG8gYXBwZW5kXG4gIGNvbnN0IHBvb2wgPSBkb20uZmlsdGVyKG4gPT4gbi5kKTtcbiAgZm9yIChjb25zdCBjZWxsIG9mIHRvTXV0YXRlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBvb2wuZmluZChuID0+IG4uZCAmJiBuLmNlbGwudHlwZSA9PT0gY2VsbC50eXBlKTtcbiAgICBjb25zdCBpbmRleCA9IGNlbGwuaTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5kID0gZmFsc2U7XG4gICAgICBub2RlLmNoYW5nZSA9IE5PREVfQ0hBTkdFX0NFTEw7XG4gICAgICBub2RlLmNlbGwgPSBjZWxsO1xuICAgICAgbm9kZS50b3AgPSBoZWlnaHRJbmRleFtpbmRleF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZG9tLnB1c2goe1xuICAgICAgICBkOiBmYWxzZSxcbiAgICAgICAgY2VsbCxcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgY2hhbmdlOiBOT0RFX0NIQU5HRV9DRUxMLFxuICAgICAgICB0b3A6IGhlaWdodEluZGV4W2luZGV4XSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkb21cbiAgICAuZmlsdGVyKG4gPT4gbi5kICYmIG4udG9wICE9PSAtOTk5OSlcbiAgICAuZm9yRWFjaChuID0+IHtcbiAgICBuLmNoYW5nZSA9IE5PREVfQ0hBTkdFX1BPU0lUSU9OO1xuICAgIG4udG9wID0gLTk5OTk7XG4gIH0pO1xufTtcbmNvbnN0IGRvUmVuZGVyID0gKGVsLCBub2RlUmVuZGVyLCBkb20sIHVwZGF0ZUNlbGxIZWlnaHQpID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKS5maWx0ZXIobiA9PiBuLnRhZ05hbWUgIT09ICdURU1QTEFURScpO1xuICBjb25zdCBjaGlsZHJlbk51ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICBsZXQgY2hpbGQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvbVtpXTtcbiAgICBjb25zdCBjZWxsID0gbm9kZS5jZWxsO1xuICAgIC8vIHRoZSBjZWxsIGNoYW5nZSwgdGhlIGNvbnRlbnQgbXVzdCBiZSB1cGRhdGVkXG4gICAgaWYgKG5vZGUuY2hhbmdlID09PSBOT0RFX0NIQU5HRV9DRUxMKSB7XG4gICAgICBpZiAoaSA8IGNoaWxkcmVuTnUpIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgbm9kZVJlbmRlcihjaGlsZCwgY2VsbCwgaSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBjcmVhdGVOb2RlKGVsLCBjZWxsLnR5cGUpO1xuICAgICAgICBjaGlsZCA9IG5vZGVSZW5kZXIobmV3Q2hpbGQsIGNlbGwsIGkpIHx8IG5ld0NoaWxkO1xuICAgICAgICBjaGlsZC5jbGFzc0xpc3QuYWRkKCd2aXJ0dWFsLWl0ZW0nKTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGRbJyRpb25DZWxsJ10gPSBjZWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgfVxuICAgIC8vIG9ubHkgdXBkYXRlIHBvc2l0aW9uIHdoZW4gaXQgY2hhbmdlc1xuICAgIGlmIChub2RlLmNoYW5nZSAhPT0gTk9ERV9DSEFOR0VfTk9ORSkge1xuICAgICAgY2hpbGQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsJHtub2RlLnRvcH1weCwwKWA7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB2aXNpYmlsaXR5XG4gICAgY29uc3QgdmlzaWJsZSA9IGNlbGwudmlzaWJsZTtcbiAgICBpZiAobm9kZS52aXNpYmxlICE9PSB2aXNpYmxlKSB7XG4gICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICBjaGlsZC5jbGFzc0xpc3QucmVtb3ZlKCd2aXJ0dWFsLWxvYWRpbmcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjaGlsZC5jbGFzc0xpc3QuYWRkKCd2aXJ0dWFsLWxvYWRpbmcnKTtcbiAgICAgIH1cbiAgICAgIG5vZGUudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICAgIC8vIGR5bmFtaWMgaGVpZ2h0XG4gICAgaWYgKGNlbGwucmVhZHMgPiAwKSB7XG4gICAgICB1cGRhdGVDZWxsSGVpZ2h0KGNlbGwsIGNoaWxkKTtcbiAgICAgIGNlbGwucmVhZHMtLTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBjcmVhdGVOb2RlID0gKGVsLCB0eXBlKSA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlID0gZ2V0VGVtcGxhdGUoZWwsIHR5cGUpO1xuICBpZiAodGVtcGxhdGUgJiYgZWwub3duZXJEb2N1bWVudCkge1xuICAgIHJldHVybiBlbC5vd25lckRvY3VtZW50LmltcG9ydE5vZGUodGVtcGxhdGUuY29udGVudCwgdHJ1ZSkuY2hpbGRyZW5bMF07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZ2V0VGVtcGxhdGUgPSAoZWwsIHR5cGUpID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBDRUxMX1RZUEVfSVRFTTogcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlOm5vdChbbmFtZV0pJyk7XG4gICAgY2FzZSBDRUxMX1RZUEVfSEVBREVSOiByZXR1cm4gZWwucXVlcnlTZWxlY3RvcigndGVtcGxhdGVbbmFtZT1oZWFkZXJdJyk7XG4gICAgY2FzZSBDRUxMX1RZUEVfRk9PVEVSOiByZXR1cm4gZWwucXVlcnlTZWxlY3RvcigndGVtcGxhdGVbbmFtZT1mb290ZXJdJyk7XG4gIH1cbn07XG5jb25zdCBnZXRWaWV3cG9ydCA9IChzY3JvbGxUb3AsIHZpZXJwb3J0SGVpZ2h0LCBtYXJnaW4pID0+IHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IE1hdGgubWF4KHNjcm9sbFRvcCAtIG1hcmdpbiwgMCksXG4gICAgYm90dG9tOiBzY3JvbGxUb3AgKyB2aWVycG9ydEhlaWdodCArIG1hcmdpblxuICB9O1xufTtcbmNvbnN0IGdldFJhbmdlID0gKGhlaWdodEluZGV4LCB2aWV3cG9ydCwgYnVmZmVyKSA9PiB7XG4gIGNvbnN0IHRvcFBvcyA9IHZpZXdwb3J0LnRvcDtcbiAgY29uc3QgYm90dG9tUG9zID0gdmlld3BvcnQuYm90dG9tO1xuICAvLyBmaW5kIHRvcCBpbmRleFxuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgaGVpZ2h0SW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGVpZ2h0SW5kZXhbaV0gPiB0b3BQb3MpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBvZmZzZXQgPSBNYXRoLm1heChpIC0gYnVmZmVyIC0gMSwgMCk7XG4gIC8vIGZpbmQgYm90dG9tIGluZGV4XG4gIGZvciAoOyBpIDwgaGVpZ2h0SW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGVpZ2h0SW5kZXhbaV0gPj0gYm90dG9tUG9zKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgZW5kID0gTWF0aC5taW4oaSArIGJ1ZmZlciwgaGVpZ2h0SW5kZXgubGVuZ3RoKTtcbiAgY29uc3QgbGVuZ3RoID0gZW5kIC0gb2Zmc2V0O1xuICByZXR1cm4geyBvZmZzZXQsIGxlbmd0aCB9O1xufTtcbmNvbnN0IGdldFNob3VsZFVwZGF0ZSA9IChkaXJ0eUluZGV4LCBjdXJyZW50UmFuZ2UsIHJhbmdlKSA9PiB7XG4gIGNvbnN0IGVuZCA9IHJhbmdlLm9mZnNldCArIHJhbmdlLmxlbmd0aDtcbiAgcmV0dXJuIChkaXJ0eUluZGV4IDw9IGVuZCB8fFxuICAgIGN1cnJlbnRSYW5nZS5vZmZzZXQgIT09IHJhbmdlLm9mZnNldCB8fFxuICAgIGN1cnJlbnRSYW5nZS5sZW5ndGggIT09IHJhbmdlLmxlbmd0aCk7XG59O1xuY29uc3QgZmluZENlbGxJbmRleCA9IChjZWxscywgaW5kZXgpID0+IHtcbiAgY29uc3QgbWF4ID0gY2VsbHMubGVuZ3RoID4gMCA/IGNlbGxzW2NlbGxzLmxlbmd0aCAtIDFdLmluZGV4IDogMDtcbiAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSBpZiAoaW5kZXggPT09IG1heCArIDEpIHtcbiAgICByZXR1cm4gY2VsbHMubGVuZ3RoO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBjZWxscy5maW5kSW5kZXgoYyA9PiBjLmluZGV4ID09PSBpbmRleCk7XG4gIH1cbn07XG5jb25zdCBpbnBsYWNlVXBkYXRlID0gKGRzdCwgc3JjLCBvZmZzZXQpID0+IHtcbiAgaWYgKG9mZnNldCA9PT0gMCAmJiBzcmMubGVuZ3RoID49IGRzdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICB9XG4gIHJldHVybiBkc3Q7XG59O1xuY29uc3QgY2FsY0NlbGxzID0gKGl0ZW1zLCBpdGVtSGVpZ2h0LCBoZWFkZXJIZWlnaHQsIGZvb3RlckhlaWdodCwgaGVhZGVyRm4sIGZvb3RlckZuLCBhcHByb3hIZWFkZXJIZWlnaHQsIGFwcHJveEZvb3RlckhlaWdodCwgYXBwcm94SXRlbUhlaWdodCwgaiwgb2Zmc2V0LCBsZW4pID0+IHtcbiAgY29uc3QgY2VsbHMgPSBbXTtcbiAgY29uc3QgZW5kID0gbGVuICsgb2Zmc2V0O1xuICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgaWYgKGhlYWRlckZuKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlckZuKGl0ZW0sIGksIGl0ZW1zKTtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNlbGxzLnB1c2goe1xuICAgICAgICAgIGk6IGorKyxcbiAgICAgICAgICB0eXBlOiBDRUxMX1RZUEVfSEVBREVSLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGhlaWdodDogaGVhZGVySGVpZ2h0ID8gaGVhZGVySGVpZ2h0KHZhbHVlLCBpKSA6IGFwcHJveEhlYWRlckhlaWdodCxcbiAgICAgICAgICByZWFkczogaGVhZGVySGVpZ2h0ID8gMCA6IE1JTl9SRUFEUyxcbiAgICAgICAgICB2aXNpYmxlOiAhIWhlYWRlckhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNlbGxzLnB1c2goe1xuICAgICAgaTogaisrLFxuICAgICAgdHlwZTogQ0VMTF9UWVBFX0lURU0sXG4gICAgICB2YWx1ZTogaXRlbSxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgaGVpZ2h0OiBpdGVtSGVpZ2h0ID8gaXRlbUhlaWdodChpdGVtLCBpKSA6IGFwcHJveEl0ZW1IZWlnaHQsXG4gICAgICByZWFkczogaXRlbUhlaWdodCA/IDAgOiBNSU5fUkVBRFMsXG4gICAgICB2aXNpYmxlOiAhIWl0ZW1IZWlnaHQsXG4gICAgfSk7XG4gICAgaWYgKGZvb3RlckZuKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGZvb3RlckZuKGl0ZW0sIGksIGl0ZW1zKTtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNlbGxzLnB1c2goe1xuICAgICAgICAgIGk6IGorKyxcbiAgICAgICAgICB0eXBlOiBDRUxMX1RZUEVfRk9PVEVSLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGhlaWdodDogZm9vdGVySGVpZ2h0ID8gZm9vdGVySGVpZ2h0KHZhbHVlLCBpKSA6IGFwcHJveEZvb3RlckhlaWdodCxcbiAgICAgICAgICByZWFkczogZm9vdGVySGVpZ2h0ID8gMCA6IE1JTl9SRUFEUyxcbiAgICAgICAgICB2aXNpYmxlOiAhIWZvb3RlckhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjZWxscztcbn07XG5jb25zdCBjYWxjSGVpZ2h0SW5kZXggPSAoYnVmLCBjZWxscywgaW5kZXgpID0+IHtcbiAgbGV0IGFjdW0gPSBidWZbaW5kZXhdO1xuICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICBidWZbaV0gPSBhY3VtO1xuICAgIGFjdW0gKz0gY2VsbHNbaV0uaGVpZ2h0O1xuICB9XG4gIHJldHVybiBhY3VtO1xufTtcbmNvbnN0IHJlc2l6ZUJ1ZmZlciA9IChidWYsIGxlbikgPT4ge1xuICBpZiAoIWJ1Zikge1xuICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgfVxuICBpZiAoYnVmLmxlbmd0aCA9PT0gbGVuKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICBlbHNlIGlmIChsZW4gPiBidWYubGVuZ3RoKSB7XG4gICAgY29uc3QgbmV3QnVmID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gICAgbmV3QnVmLnNldChidWYpO1xuICAgIHJldHVybiBuZXdCdWY7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBsZW4pO1xuICB9XG59O1xuY29uc3QgcG9zaXRpb25Gb3JJbmRleCA9IChpbmRleCwgY2VsbHMsIGhlaWdodEluZGV4KSA9PiB7XG4gIGNvbnN0IGNlbGwgPSBjZWxscy5maW5kKGMgPT4gYy50eXBlID09PSBDRUxMX1RZUEVfSVRFTSAmJiBjLmluZGV4ID09PSBpbmRleCk7XG4gIGlmIChjZWxsKSB7XG4gICAgcmV0dXJuIGhlaWdodEluZGV4W2NlbGwuaV07XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuY29uc3QgdmlydHVhbFNjcm9sbENzcyA9IFwiaW9uLXZpcnR1YWwtc2Nyb2xse2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtjb250YWluOnN0cmljdDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9aW9uLXZpcnR1YWwtc2Nyb2xsPi52aXJ0dWFsLWxvYWRpbmd7b3BhY2l0eTowfWlvbi12aXJ0dWFsLXNjcm9sbD4udmlydHVhbC1pdGVte3Bvc2l0aW9uOmFic29sdXRlICFpbXBvcnRhbnQ7dG9wOjAgIWltcG9ydGFudDtyaWdodDowICFpbXBvcnRhbnQ7bGVmdDowICFpbXBvcnRhbnQ7LXdlYmtpdC10cmFuc2l0aW9uLWR1cmF0aW9uOjBtczt0cmFuc2l0aW9uLWR1cmF0aW9uOjBtczt3aWxsLWNoYW5nZTp0cmFuc2Zvcm19XCI7XG5cbmxldCBWaXJ0dWFsU2Nyb2xsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLnJhbmdlID0geyBvZmZzZXQ6IDAsIGxlbmd0aDogMCB9O1xuICAgIHRoaXMudmlld3BvcnRIZWlnaHQgPSAwO1xuICAgIHRoaXMuY2VsbHMgPSBbXTtcbiAgICB0aGlzLnZpcnR1YWxEb20gPSBbXTtcbiAgICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMudmlld3BvcnRPZmZzZXQgPSAwO1xuICAgIHRoaXMuY3VycmVudFNjcm9sbFRvcCA9IDA7XG4gICAgdGhpcy5pbmRleERpcnR5ID0gMDtcbiAgICB0aGlzLmxhc3RJdGVtTGVuID0gMDtcbiAgICB0aGlzLnRvdGFsSGVpZ2h0ID0gMDtcbiAgICAvKipcbiAgICAgKiBJdCBpcyBpbXBvcnRhbnQgdG8gcHJvdmlkZSB0aGlzXG4gICAgICogaWYgdmlydHVhbCBpdGVtIGhlaWdodCB3aWxsIGJlIHNpZ25pZmljYW50bHkgbGFyZ2VyIHRoYW4gdGhlIGRlZmF1bHRcbiAgICAgKiBUaGUgYXBwcm94aW1hdGUgaGVpZ2h0IG9mIGVhY2ggdmlydHVhbCBpdGVtIHRlbXBsYXRlJ3MgY2VsbC5cbiAgICAgKiBUaGlzIGRpbWVuc2lvbiBpcyB1c2VkIHRvIGhlbHAgZGV0ZXJtaW5lIGhvdyBtYW55IGNlbGxzIHNob3VsZFxuICAgICAqIGJlIGNyZWF0ZWQgd2hlbiBpbml0aWFsaXplZCwgYW5kIHRvIGhlbHAgY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2ZcbiAgICAgKiB0aGUgc2Nyb2xsYWJsZSBhcmVhLiBUaGlzIGhlaWdodCB2YWx1ZSBjYW4gb25seSB1c2UgYHB4YCB1bml0cy5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIGFjdHVhbCByZW5kZXJlZCBzaXplIG9mIGVhY2ggY2VsbCBjb21lcyBmcm9tIHRoZVxuICAgICAqIGFwcCdzIENTUywgd2hlcmVhcyB0aGlzIGFwcHJveGltYXRpb24gaXMgdXNlZCB0byBoZWxwIGNhbGN1bGF0ZVxuICAgICAqIGluaXRpYWwgZGltZW5zaW9ucyBiZWZvcmUgdGhlIGl0ZW0gaGFzIGJlZW4gcmVuZGVyZWQuXG4gICAgICovXG4gICAgdGhpcy5hcHByb3hJdGVtSGVpZ2h0ID0gNDU7XG4gICAgLyoqXG4gICAgICogVGhlIGFwcHJveGltYXRlIGhlaWdodCBvZiBlYWNoIGhlYWRlciB0ZW1wbGF0ZSdzIGNlbGwuXG4gICAgICogVGhpcyBkaW1lbnNpb24gaXMgdXNlZCB0byBoZWxwIGRldGVybWluZSBob3cgbWFueSBjZWxscyBzaG91bGRcbiAgICAgKiBiZSBjcmVhdGVkIHdoZW4gaW5pdGlhbGl6ZWQsIGFuZCB0byBoZWxwIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mXG4gICAgICogdGhlIHNjcm9sbGFibGUgYXJlYS4gVGhpcyBoZWlnaHQgdmFsdWUgY2FuIG9ubHkgdXNlIGBweGAgdW5pdHMuXG4gICAgICogTm90ZSB0aGF0IHRoZSBhY3R1YWwgcmVuZGVyZWQgc2l6ZSBvZiBlYWNoIGNlbGwgY29tZXMgZnJvbSB0aGVcbiAgICAgKiBhcHAncyBDU1MsIHdoZXJlYXMgdGhpcyBhcHByb3hpbWF0aW9uIGlzIHVzZWQgdG8gaGVscCBjYWxjdWxhdGVcbiAgICAgKiBpbml0aWFsIGRpbWVuc2lvbnMgYmVmb3JlIHRoZSBpdGVtIGhhcyBiZWVuIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHRoaXMuYXBwcm94SGVhZGVySGVpZ2h0ID0gMzA7XG4gICAgLyoqXG4gICAgICogVGhlIGFwcHJveGltYXRlIHdpZHRoIG9mIGVhY2ggZm9vdGVyIHRlbXBsYXRlJ3MgY2VsbC5cbiAgICAgKiBUaGlzIGRpbWVuc2lvbiBpcyB1c2VkIHRvIGhlbHAgZGV0ZXJtaW5lIGhvdyBtYW55IGNlbGxzIHNob3VsZFxuICAgICAqIGJlIGNyZWF0ZWQgd2hlbiBpbml0aWFsaXplZCwgYW5kIHRvIGhlbHAgY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2ZcbiAgICAgKiB0aGUgc2Nyb2xsYWJsZSBhcmVhLiBUaGlzIGhlaWdodCB2YWx1ZSBjYW4gb25seSB1c2UgYHB4YCB1bml0cy5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIGFjdHVhbCByZW5kZXJlZCBzaXplIG9mIGVhY2ggY2VsbCBjb21lcyBmcm9tIHRoZVxuICAgICAqIGFwcCdzIENTUywgd2hlcmVhcyB0aGlzIGFwcHJveGltYXRpb24gaXMgdXNlZCB0byBoZWxwIGNhbGN1bGF0ZVxuICAgICAqIGluaXRpYWwgZGltZW5zaW9ucyBiZWZvcmUgdGhlIGl0ZW0gaGFzIGJlZW4gcmVuZGVyZWQuXG4gICAgICovXG4gICAgdGhpcy5hcHByb3hGb290ZXJIZWlnaHQgPSAzMDtcbiAgICB0aGlzLm9uU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVWaXJ0dWFsU2Nyb2xsKCk7XG4gICAgfTtcbiAgfVxuICBpdGVtc0NoYW5nZWQoKSB7XG4gICAgdGhpcy5jYWxjQ2VsbHMoKTtcbiAgICB0aGlzLnVwZGF0ZVZpcnR1YWxTY3JvbGwoKTtcbiAgfVxuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBjb25zb2xlLndhcm4oYFtEZXByZWNhdGlvbiBXYXJuaW5nXTogaW9uLXZpcnR1YWwtc2Nyb2xsIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBJb25pYyBGcmFtZXdvcmsgdjcuMC4gU2VlIGh0dHBzOi8vaW9uaWNmcmFtZXdvcmsuY29tL2RvY3MvYW5ndWxhci92aXJ0dWFsLXNjcm9sbCBmb3IgbWlncmF0aW9uIHN0ZXBzLmApO1xuICB9XG4gIGFzeW5jIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IGNvbnRlbnRFbCA9IHRoaXMuZWwuY2xvc2VzdCgnaW9uLWNvbnRlbnQnKTtcbiAgICBpZiAoIWNvbnRlbnRFbCkge1xuICAgICAgY29uc29sZS5lcnJvcignPGlvbi12aXJ0dWFsLXNjcm9sbD4gbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8aW9uLWNvbnRlbnQ+Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2Nyb2xsRWwgPSBhd2FpdCBjb250ZW50RWwuZ2V0U2Nyb2xsRWxlbWVudCgpO1xuICAgIHRoaXMuY29udGVudEVsID0gY29udGVudEVsO1xuICAgIHRoaXMuY2FsY0NlbGxzKCk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5zY3JvbGxFbCA9IHVuZGVmaW5lZDtcbiAgfVxuICBvblJlc2l6ZSgpIHtcbiAgICB0aGlzLmNhbGNDZWxscygpO1xuICAgIHRoaXMudXBkYXRlVmlydHVhbFNjcm9sbCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgdmlydHVhbCBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICovXG4gIHBvc2l0aW9uRm9ySXRlbShpbmRleCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocG9zaXRpb25Gb3JJbmRleChpbmRleCwgdGhpcy5jZWxscywgdGhpcy5nZXRIZWlnaHRJbmRleCgpKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIG1hcmtzIGEgc3Vic2V0IG9mIGl0ZW1zIGFzIGRpcnR5LCBzbyB0aGV5IGNhbiBiZSByZS1yZW5kZXJlZC4gSXRlbXMgc2hvdWxkIGJlIG1hcmtlZCBhc1xuICAgKiBkaXJ0eSBhbnkgdGltZSB0aGUgY29udGVudCBvciB0aGVpciBzdHlsZSBjaGFuZ2VzLlxuICAgKlxuICAgKiBUaGUgc3Vic2V0IG9mIGl0ZW1zIHRvIGJlIHVwZGF0ZWQgY2FuIGFyZSBzcGVjaWZpbmcgYnkgYW4gb2Zmc2V0IGFuZCBhIGxlbmd0aC5cbiAgICovXG4gIGFzeW5jIGNoZWNrUmFuZ2Uob2Zmc2V0LCBsZW4gPSAtMSkge1xuICAgIC8vIFRPRE86IGtpbmQgb2YgaGFja3kgaG93IHdlIGRvIGluLXBsYWNlIHVwZGF0ZWQgb2YgdGhlIGNlbGxzXG4gICAgLy8gYXJyYXkuIHRoaXMgcGFydCBuZWVkcyBhIGNvbXBsZXRlIHJlZmFjdG9yXG4gICAgaWYgKCF0aGlzLml0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IChsZW4gPT09IC0xKVxuICAgICAgPyB0aGlzLml0ZW1zLmxlbmd0aCAtIG9mZnNldFxuICAgICAgOiBsZW47XG4gICAgY29uc3QgY2VsbEluZGV4ID0gZmluZENlbGxJbmRleCh0aGlzLmNlbGxzLCBvZmZzZXQpO1xuICAgIGNvbnN0IGNlbGxzID0gY2FsY0NlbGxzKHRoaXMuaXRlbXMsIHRoaXMuaXRlbUhlaWdodCwgdGhpcy5oZWFkZXJIZWlnaHQsIHRoaXMuZm9vdGVySGVpZ2h0LCB0aGlzLmhlYWRlckZuLCB0aGlzLmZvb3RlckZuLCB0aGlzLmFwcHJveEhlYWRlckhlaWdodCwgdGhpcy5hcHByb3hGb290ZXJIZWlnaHQsIHRoaXMuYXBwcm94SXRlbUhlaWdodCwgY2VsbEluZGV4LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgdGhpcy5jZWxscyA9IGlucGxhY2VVcGRhdGUodGhpcy5jZWxscywgY2VsbHMsIGNlbGxJbmRleCk7XG4gICAgdGhpcy5sYXN0SXRlbUxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIHRoaXMuaW5kZXhEaXJ0eSA9IE1hdGgubWF4KG9mZnNldCAtIDEsIDApO1xuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgbWFya3MgdGhlIHRhaWwgdGhlIGl0ZW1zIGFycmF5IGFzIGRpcnR5LCBzbyB0aGV5IGNhbiBiZSByZS1yZW5kZXJlZC5cbiAgICpcbiAgICogSXQncyBlcXVpdmFsZW50IHRvIGNhbGxpbmc6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZpcnR1YWxTY3JvbGwuY2hlY2tSYW5nZShsYXN0SXRlbUxlbik7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgY2hlY2tFbmQoKSB7XG4gICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgIHRoaXMuY2hlY2tSYW5nZSh0aGlzLmxhc3RJdGVtTGVuKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVmlydHVhbFNjcm9sbCgpIHtcbiAgICAvLyBkbyBub3RoaW5nIGlmIHZpcnR1YWwtc2Nyb2xsIGlzIGRpc2FibGVkXG4gICAgaWYgKCF0aGlzLmlzRW5hYmxlZCB8fCAhdGhpcy5zY3JvbGxFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB1bnNjaGVkdWxlIGZ1dHVyZSB1cGRhdGVzXG4gICAgaWYgKHRoaXMudGltZXJVcGRhdGUpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyVXBkYXRlKTtcbiAgICAgIHRoaXMudGltZXJVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIHNjaGVkdWxlIERPTSBvcGVyYXRpb25zIGludG8gdGhlIHN0ZW5jaWwgcXVldWVcbiAgICByZWFkVGFzayh0aGlzLnJlYWRWUy5iaW5kKHRoaXMpKTtcbiAgICB3cml0ZVRhc2sodGhpcy53cml0ZVZTLmJpbmQodGhpcykpO1xuICB9XG4gIHJlYWRWUygpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCwgc2Nyb2xsRWwsIGVsIH0gPSB0aGlzO1xuICAgIGxldCB0b3BPZmZzZXQgPSAwO1xuICAgIGxldCBub2RlID0gZWw7XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gY29udGVudEVsKSB7XG4gICAgICB0b3BPZmZzZXQgKz0gbm9kZS5vZmZzZXRUb3A7XG4gICAgICBub2RlID0gbm9kZS5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICAgIHRoaXMudmlld3BvcnRPZmZzZXQgPSB0b3BPZmZzZXQ7XG4gICAgaWYgKHNjcm9sbEVsKSB7XG4gICAgICB0aGlzLnZpZXdwb3J0SGVpZ2h0ID0gc2Nyb2xsRWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5jdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsRWwuc2Nyb2xsVG9wO1xuICAgIH1cbiAgfVxuICB3cml0ZVZTKCkge1xuICAgIGNvbnN0IGRpcnR5SW5kZXggPSB0aGlzLmluZGV4RGlydHk7XG4gICAgLy8gZ2V0IHZpc2libGUgdmlld3BvcnRcbiAgICBjb25zdCBzY3JvbGxUb3AgPSB0aGlzLmN1cnJlbnRTY3JvbGxUb3AgLSB0aGlzLnZpZXdwb3J0T2Zmc2V0O1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnQoc2Nyb2xsVG9wLCB0aGlzLnZpZXdwb3J0SGVpZ2h0LCAxMDApO1xuICAgIC8vIGNvbXB1dGUgbGF6aWx5IHRoZSBoZWlnaHQgaW5kZXhcbiAgICBjb25zdCBoZWlnaHRJbmRleCA9IHRoaXMuZ2V0SGVpZ2h0SW5kZXgoKTtcbiAgICAvLyBnZXQgYXJyYXkgYm91bmRzIG9mIHZpc2libGUgY2VsbHMgYmFzZSBpbiB0aGUgdmlld3BvcnRcbiAgICBjb25zdCByYW5nZSA9IGdldFJhbmdlKGhlaWdodEluZGV4LCB2aWV3cG9ydCwgMik7XG4gICAgLy8gZmFzdCBwYXRoLCBkbyBub3RoaW5nXG4gICAgY29uc3Qgc2hvdWxkVXBkYXRlID0gZ2V0U2hvdWxkVXBkYXRlKGRpcnR5SW5kZXgsIHRoaXMucmFuZ2UsIHJhbmdlKTtcbiAgICBpZiAoIXNob3VsZFVwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgLy8gaW4gcGxhY2UgbXV0YXRpb24gb2YgdGhlIHZpcnR1YWwgRE9NXG4gICAgdXBkYXRlVkRvbSh0aGlzLnZpcnR1YWxEb20sIGhlaWdodEluZGV4LCB0aGlzLmNlbGxzLCByYW5nZSk7XG4gICAgLy8gV3JpdGUgRE9NXG4gICAgLy8gRGlmZmVyZW50IGNvZGUgcGF0aHMgdGFrZW4gZGVwZW5kaW5nIG9mIHRoZSByZW5kZXIgQVBJIHVzZWRcbiAgICBpZiAodGhpcy5ub2RlUmVuZGVyKSB7XG4gICAgICBkb1JlbmRlcih0aGlzLmVsLCB0aGlzLm5vZGVSZW5kZXIsIHRoaXMudmlydHVhbERvbSwgdGhpcy51cGRhdGVDZWxsSGVpZ2h0LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmRvbVJlbmRlcikge1xuICAgICAgdGhpcy5kb21SZW5kZXIodGhpcy52aXJ0dWFsRG9tKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5yZW5kZXJJdGVtKSB7XG4gICAgICBmb3JjZVVwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlQ2VsbEhlaWdodChjZWxsLCBub2RlKSB7XG4gICAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgICAgaWYgKG5vZGVbJyRpb25DZWxsJ10gPT09IGNlbGwpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbm9kZS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1ib3R0b20nKSk7XG4gICAgICAgIHRoaXMuc2V0Q2VsbEhlaWdodChjZWxsLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIGNvbXBvbmVudE9uUmVhZHkobm9kZSwgdXBkYXRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgc2V0Q2VsbEhlaWdodChjZWxsLCBoZWlnaHQpIHtcbiAgICBjb25zdCBpbmRleCA9IGNlbGwuaTtcbiAgICAvLyB0aGUgY2VsbCBtaWdodCBjaGFuZ2VkIHNpbmNlIHRoZSBoZWlnaHQgdXBkYXRlIHdhcyBzY2hlZHVsZWRcbiAgICBpZiAoY2VsbCAhPT0gdGhpcy5jZWxsc1tpbmRleF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNlbGwuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgY2VsbC52aXNpYmxlICE9PSB0cnVlKSB7XG4gICAgICBjZWxsLnZpc2libGUgPSB0cnVlO1xuICAgICAgY2VsbC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLmluZGV4RGlydHkgPSBNYXRoLm1pbih0aGlzLmluZGV4RGlydHksIGluZGV4KTtcbiAgICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgc2NoZWR1bGVVcGRhdGUoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJVcGRhdGUpO1xuICAgIHRoaXMudGltZXJVcGRhdGUgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlVmlydHVhbFNjcm9sbCgpLCAxMDApO1xuICB9XG4gIHVwZGF0ZVN0YXRlKCkge1xuICAgIGNvbnN0IHNob3VsZEVuYWJsZSA9ICEhKHRoaXMuc2Nyb2xsRWwgJiZcbiAgICAgIHRoaXMuY2VsbHMpO1xuICAgIGlmIChzaG91bGRFbmFibGUgIT09IHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLmVuYWJsZVNjcm9sbEV2ZW50cyhzaG91bGRFbmFibGUpO1xuICAgICAgaWYgKHNob3VsZEVuYWJsZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpcnR1YWxTY3JvbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsY0NlbGxzKCkge1xuICAgIGlmICghdGhpcy5pdGVtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RJdGVtTGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgdGhpcy5jZWxscyA9IGNhbGNDZWxscyh0aGlzLml0ZW1zLCB0aGlzLml0ZW1IZWlnaHQsIHRoaXMuaGVhZGVySGVpZ2h0LCB0aGlzLmZvb3RlckhlaWdodCwgdGhpcy5oZWFkZXJGbiwgdGhpcy5mb290ZXJGbiwgdGhpcy5hcHByb3hIZWFkZXJIZWlnaHQsIHRoaXMuYXBwcm94Rm9vdGVySGVpZ2h0LCB0aGlzLmFwcHJveEl0ZW1IZWlnaHQsIDAsIDAsIHRoaXMubGFzdEl0ZW1MZW4pO1xuICAgIHRoaXMuaW5kZXhEaXJ0eSA9IDA7XG4gIH1cbiAgZ2V0SGVpZ2h0SW5kZXgoKSB7XG4gICAgaWYgKHRoaXMuaW5kZXhEaXJ0eSAhPT0gSW5maW5pdHkpIHtcbiAgICAgIHRoaXMuY2FsY0hlaWdodEluZGV4KHRoaXMuaW5kZXhEaXJ0eSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhlaWdodEluZGV4O1xuICB9XG4gIGNhbGNIZWlnaHRJbmRleChpbmRleCA9IDApIHtcbiAgICAvLyBUT0RPOiBvcHRpbWl6ZSwgd2UgZG9uJ3QgbmVlZCB0byBjYWxjdWxhdGUgYWxsIHRoZSBjZWxsc1xuICAgIHRoaXMuaGVpZ2h0SW5kZXggPSByZXNpemVCdWZmZXIodGhpcy5oZWlnaHRJbmRleCwgdGhpcy5jZWxscy5sZW5ndGgpO1xuICAgIHRoaXMudG90YWxIZWlnaHQgPSBjYWxjSGVpZ2h0SW5kZXgodGhpcy5oZWlnaHRJbmRleCwgdGhpcy5jZWxscywgaW5kZXgpO1xuICAgIHRoaXMuaW5kZXhEaXJ0eSA9IEluZmluaXR5O1xuICB9XG4gIGVuYWJsZVNjcm9sbEV2ZW50cyhzaG91bGRMaXN0ZW4pIHtcbiAgICBpZiAodGhpcy5ybUV2ZW50KSB7XG4gICAgICB0aGlzLnJtRXZlbnQoKTtcbiAgICAgIHRoaXMucm1FdmVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsRWwgPSB0aGlzLnNjcm9sbEVsO1xuICAgIGlmIChzY3JvbGxFbCkge1xuICAgICAgdGhpcy5pc0VuYWJsZWQgPSBzaG91bGRMaXN0ZW47XG4gICAgICBzY3JvbGxFbC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgIHRoaXMucm1FdmVudCA9ICgpID0+IHtcbiAgICAgICAgc2Nyb2xsRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5vblNjcm9sbCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZW5kZXJWaXJ0dWFsTm9kZShub2RlKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSwgaW5kZXggfSA9IG5vZGUuY2VsbDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQ0VMTF9UWVBFX0lURU06IHJldHVybiB0aGlzLnJlbmRlckl0ZW0odmFsdWUsIGluZGV4KTtcbiAgICAgIGNhc2UgQ0VMTF9UWVBFX0hFQURFUjogcmV0dXJuIHRoaXMucmVuZGVySGVhZGVyKHZhbHVlLCBpbmRleCk7XG4gICAgICBjYXNlIENFTExfVFlQRV9GT09URVI6IHJldHVybiB0aGlzLnJlbmRlckZvb3Rlcih2YWx1ZSwgaW5kZXgpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgc3R5bGU6IHtcbiAgICAgICAgaGVpZ2h0OiBgJHt0aGlzLnRvdGFsSGVpZ2h0fXB4YFxuICAgICAgfSB9LCB0aGlzLnJlbmRlckl0ZW0gJiYgKGgoVmlydHVhbFByb3h5LCB7IGRvbTogdGhpcy52aXJ0dWFsRG9tIH0sIHRoaXMudmlydHVhbERvbS5tYXAobm9kZSA9PiB0aGlzLnJlbmRlclZpcnR1YWxOb2RlKG5vZGUpKSkpKSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwiaXRlbUhlaWdodFwiOiBbXCJpdGVtc0NoYW5nZWRcIl0sXG4gICAgXCJoZWFkZXJIZWlnaHRcIjogW1wiaXRlbXNDaGFuZ2VkXCJdLFxuICAgIFwiZm9vdGVySGVpZ2h0XCI6IFtcIml0ZW1zQ2hhbmdlZFwiXSxcbiAgICBcIml0ZW1zXCI6IFtcIml0ZW1zQ2hhbmdlZFwiXVxuICB9OyB9XG59O1xuY29uc3QgVmlydHVhbFByb3h5ID0gKHsgZG9tIH0sIGNoaWxkcmVuLCB1dGlscykgPT4ge1xuICByZXR1cm4gdXRpbHMubWFwKGNoaWxkcmVuLCAoY2hpbGQsIGkpID0+IHtcbiAgICBjb25zdCBub2RlID0gZG9tW2ldO1xuICAgIGNvbnN0IHZhdHRycyA9IGNoaWxkLnZhdHRycyB8fCB7fTtcbiAgICBsZXQgY2xhc3NlcyA9IHZhdHRycy5jbGFzcyB8fCAnJztcbiAgICBjbGFzc2VzICs9ICd2aXJ0dWFsLWl0ZW0gJztcbiAgICBpZiAoIW5vZGUudmlzaWJsZSkge1xuICAgICAgY2xhc3NlcyArPSAndmlydHVhbC1sb2FkaW5nJztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hpbGQpLCB7IHZhdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YXR0cnMpLCB7IGNsYXNzOiBjbGFzc2VzLCBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YXR0cnMuc3R5bGUpLCB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsJHtub2RlLnRvcH1weCwwKWAgfSkgfSkgfSk7XG4gIH0pO1xufTtcblZpcnR1YWxTY3JvbGwuc3R5bGUgPSB2aXJ0dWFsU2Nyb2xsQ3NzO1xuXG5leHBvcnQgeyBWaXJ0dWFsU2Nyb2xsIGFzIGlvbl92aXJ0dWFsX3Njcm9sbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9