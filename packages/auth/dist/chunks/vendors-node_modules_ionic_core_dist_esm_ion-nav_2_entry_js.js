"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_ionic_core_dist_esm_ion-nav_2_entry_js"],{

/***/ "../node_modules/@ionic/core/dist/esm/ion-nav_2.entry.js":
/*!***************************************************************!*\
  !*** ../node_modules/@ionic/core/dist/esm/ion-nav_2.entry.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_nav": () => (/* binding */ Nav),
/* harmony export */   "ion_nav_link": () => (/* binding */ NavLink)
/* harmony export */ });
/* harmony import */ var _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-06cd27b1.js */ "../node_modules/@ionic/core/dist/esm/index-06cd27b1.js");
/* harmony import */ var _ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ionic-global-a049bcbf.js */ "../node_modules/@ionic/core/dist/esm/ionic-global-a049bcbf.js");
/* harmony import */ var _cubic_bezier_154a53a5_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubic-bezier-154a53a5.js */ "../node_modules/@ionic/core/dist/esm/cubic-bezier-154a53a5.js");
/* harmony import */ var _helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers-eed79a2b.js */ "../node_modules/@ionic/core/dist/esm/helpers-eed79a2b.js");
/* harmony import */ var _index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-c8ef55b5.js */ "../node_modules/@ionic/core/dist/esm/index-c8ef55b5.js");
/* harmony import */ var _framework_delegate_a922018c_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./framework-delegate-a922018c.js */ "../node_modules/@ionic/core/dist/esm/framework-delegate-a922018c.js");
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */







const VIEW_STATE_NEW = 1;
const VIEW_STATE_ATTACHED = 2;
const VIEW_STATE_DESTROYED = 3;
class ViewController {
  constructor(component, params) {
    this.component = component;
    this.params = params;
    this.state = VIEW_STATE_NEW;
  }
  async init(container) {
    this.state = VIEW_STATE_ATTACHED;
    if (!this.element) {
      const component = this.component;
      this.element = await (0,_framework_delegate_a922018c_js__WEBPACK_IMPORTED_MODULE_5__.a)(this.delegate, container, component, ['ion-page', 'ion-page-invisible'], this.params);
    }
  }
  /**
   * DOM WRITE
   */
  _destroy() {
    (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(this.state !== VIEW_STATE_DESTROYED, 'view state must be ATTACHED');
    const element = this.element;
    if (element) {
      if (this.delegate) {
        this.delegate.removeViewFromDom(element.parentElement, element);
      }
      else {
        element.remove();
      }
    }
    this.nav = undefined;
    this.state = VIEW_STATE_DESTROYED;
  }
}
const matches = (view, id, params) => {
  if (!view) {
    return false;
  }
  if (view.component !== id) {
    return false;
  }
  const currentParams = view.params;
  if (currentParams === params) {
    return true;
  }
  if (!currentParams && !params) {
    return true;
  }
  if (!currentParams || !params) {
    return false;
  }
  const keysA = Object.keys(currentParams);
  const keysB = Object.keys(params);
  if (keysA.length !== keysB.length) {
    return false;
  }
  // Test for A's keys different from B.
  for (const key of keysA) {
    if (currentParams[key] !== params[key]) {
      return false;
    }
  }
  return true;
};
const convertToView = (page, params) => {
  if (!page) {
    return null;
  }
  if (page instanceof ViewController) {
    return page;
  }
  return new ViewController(page, params);
};
const convertToViews = (pages) => {
  return pages.map(page => {
    if (page instanceof ViewController) {
      return page;
    }
    if ('component' in page) {
      /**
       * TODO Ionic 6:
       * Consider switching to just using `undefined` here
       * as well as on the public interfaces and on
       * `NavComponentWithProps`. Previously `pages` was
       * of type `any[]` so TypeScript did not catch this.
       */
      return convertToView(page.component, (page.componentProps === null) ? undefined : page.componentProps);
    }
    return convertToView(page, undefined);
  }).filter(v => v !== null);
};

const navCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}";

let Nav = class {
  constructor(hostRef) {
    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.ionNavWillLoad = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionNavWillLoad", 7);
    this.ionNavWillChange = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionNavWillChange", 3);
    this.ionNavDidChange = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionNavDidChange", 3);
    this.transInstr = [];
    this.animationEnabled = true;
    this.useRouter = false;
    this.isTransitioning = false;
    this.destroyed = false;
    this.views = [];
    /**
     * If `true`, the nav should animate the transition of components.
     */
    this.animated = true;
  }
  swipeGestureChanged() {
    if (this.gesture) {
      this.gesture.enable(this.swipeGesture === true);
    }
  }
  rootChanged() {
    if (this.root !== undefined) {
      if (!this.useRouter) {
        this.setRoot(this.root, this.rootParams);
      }
    }
  }
  componentWillLoad() {
    this.useRouter =
      !!document.querySelector('ion-router') &&
        !this.el.closest('[no-router]');
    if (this.swipeGesture === undefined) {
      const mode = (0,_ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_1__.b)(this);
      this.swipeGesture = _ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_1__.c.getBoolean('swipeBackEnabled', mode === 'ios');
    }
    this.ionNavWillLoad.emit();
  }
  async componentDidLoad() {
    this.rootChanged();
    this.gesture = (await __webpack_require__.e(/*! import() */ "node_modules_ionic_core_dist_esm_swipe-back-edc455e2_js").then(__webpack_require__.bind(__webpack_require__, /*! ./swipe-back-edc455e2.js */ "../node_modules/@ionic/core/dist/esm/swipe-back-edc455e2.js"))).createSwipeBackGesture(this.el, this.canStart.bind(this), this.onStart.bind(this), this.onMove.bind(this), this.onEnd.bind(this));
    this.swipeGestureChanged();
  }
  disconnectedCallback() {
    for (const view of this.views) {
      (0,_index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.l)(view.element, _index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.d);
      view._destroy();
    }
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = undefined;
    }
    // release swipe back gesture and transition
    this.transInstr.length = this.views.length = 0;
    this.destroyed = true;
  }
  /**
   * Push a new component onto the current navigation stack. Pass any additional
   * information along as an object. This additional information is accessible
   * through NavParams.
   *
   * @param component The component to push onto the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  push(component, componentProps, opts, done) {
    return this.queueTrns({
      insertStart: -1,
      insertViews: [{ component, componentProps }],
      opts
    }, done);
  }
  /**
   * Inserts a component into the navigation stack at the specified index.
   * This is useful to add a component at any point in the navigation stack.
   *
   * @param insertIndex The index to insert the component at in the stack.
   * @param component The component to insert into the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  insert(insertIndex, component, componentProps, opts, done) {
    return this.queueTrns({
      insertStart: insertIndex,
      insertViews: [{ component, componentProps }],
      opts
    }, done);
  }
  /**
   * Inserts an array of components into the navigation stack at the specified index.
   * The last component in the array will become instantiated as a view, and animate
   * in to become the active view.
   *
   * @param insertIndex The index to insert the components at in the stack.
   * @param insertComponents The components to insert into the navigation stack.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  insertPages(insertIndex, insertComponents, opts, done) {
    return this.queueTrns({
      insertStart: insertIndex,
      insertViews: insertComponents,
      opts
    }, done);
  }
  /**
   * Pop a component off of the navigation stack. Navigates back from the current
   * component.
   *
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  pop(opts, done) {
    return this.queueTrns({
      removeStart: -1,
      removeCount: 1,
      opts
    }, done);
  }
  /**
   * Pop to a specific index in the navigation stack.
   *
   * @param indexOrViewCtrl The index or view controller to pop to.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  popTo(indexOrViewCtrl, opts, done) {
    const tiConfig = {
      removeStart: -1,
      removeCount: -1,
      opts
    };
    if (typeof indexOrViewCtrl === 'object' && indexOrViewCtrl.component) {
      tiConfig.removeView = indexOrViewCtrl;
      tiConfig.removeStart = 1;
    }
    else if (typeof indexOrViewCtrl === 'number') {
      tiConfig.removeStart = indexOrViewCtrl + 1;
    }
    return this.queueTrns(tiConfig, done);
  }
  /**
   * Navigate back to the root of the stack, no matter how far back that is.
   *
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  popToRoot(opts, done) {
    return this.queueTrns({
      removeStart: 1,
      removeCount: -1,
      opts
    }, done);
  }
  /**
   * Removes a component from the navigation stack at the specified index.
   *
   * @param startIndex The number to begin removal at.
   * @param removeCount The number of components to remove.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  removeIndex(startIndex, removeCount = 1, opts, done) {
    return this.queueTrns({
      removeStart: startIndex,
      removeCount,
      opts
    }, done);
  }
  /**
   * Set the root for the current navigation stack to a component.
   *
   * @param component The component to set as the root of the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  setRoot(component, componentProps, opts, done) {
    return this.setPages([{ component, componentProps }], opts, done);
  }
  /**
   * Set the views of the current navigation stack and navigate to the last view.
   * By default animations are disabled, but they can be enabled by passing options
   * to the navigation controller. Navigation parameters can also be passed to the
   * individual pages in the array.
   *
   * @param views The list of views to set as the navigation stack.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  setPages(views, opts, done) {
    if (opts == null) {
      opts = {};
    }
    // if animation wasn't set to true then default it to NOT animate
    if (opts.animated !== true) {
      opts.animated = false;
    }
    return this.queueTrns({
      insertStart: 0,
      insertViews: views,
      removeStart: 0,
      removeCount: -1,
      opts
    }, done);
  }
  /** @internal */
  setRouteId(id, params, direction, animation) {
    const active = this.getActiveSync();
    if (matches(active, id, params)) {
      return Promise.resolve({
        changed: false,
        element: active.element
      });
    }
    let resolve;
    const promise = new Promise(r => (resolve = r));
    let finish;
    const commonOpts = {
      updateURL: false,
      viewIsReady: enteringEl => {
        let mark;
        const p = new Promise(r => (mark = r));
        resolve({
          changed: true,
          element: enteringEl,
          markVisible: async () => {
            mark();
            await finish;
          }
        });
        return p;
      }
    };
    if (direction === 'root') {
      finish = this.setRoot(id, params, commonOpts);
    }
    else {
      const viewController = this.views.find(v => matches(v, id, params));
      if (viewController) {
        finish = this.popTo(viewController, Object.assign(Object.assign({}, commonOpts), { direction: 'back', animationBuilder: animation }));
      }
      else if (direction === 'forward') {
        finish = this.push(id, params, Object.assign(Object.assign({}, commonOpts), { animationBuilder: animation }));
      }
      else if (direction === 'back') {
        finish = this.setRoot(id, params, Object.assign(Object.assign({}, commonOpts), { direction: 'back', animated: true, animationBuilder: animation }));
      }
    }
    return promise;
  }
  /** @internal */
  async getRouteId() {
    const active = this.getActiveSync();
    return active
      ? {
        id: active.element.tagName,
        params: active.params,
        element: active.element
      }
      : undefined;
  }
  /**
   * Get the active view.
   */
  getActive() {
    return Promise.resolve(this.getActiveSync());
  }
  /**
   * Get the view at the specified index.
   *
   * @param index The index of the view.
   */
  getByIndex(index) {
    return Promise.resolve(this.views[index]);
  }
  /**
   * Returns `true` if the current view can go back.
   *
   * @param view The view to check.
   */
  canGoBack(view) {
    return Promise.resolve(this.canGoBackSync(view));
  }
  /**
   * Get the previous view.
   *
   * @param view The view to get.
   */
  getPrevious(view) {
    return Promise.resolve(this.getPreviousSync(view));
  }
  getLength() {
    return this.views.length;
  }
  getActiveSync() {
    return this.views[this.views.length - 1];
  }
  canGoBackSync(view = this.getActiveSync()) {
    return !!(view && this.getPreviousSync(view));
  }
  getPreviousSync(view = this.getActiveSync()) {
    if (!view) {
      return undefined;
    }
    const views = this.views;
    const index = views.indexOf(view);
    return index > 0 ? views[index - 1] : undefined;
  }
  // _queueTrns() adds a navigation stack change to the queue and schedules it to run:
  // 1. _nextTrns(): consumes the next transition in the queue
  // 2. _viewInit(): initializes enteringView if required
  // 3. _viewTest(): ensures canLeave/canEnter Returns `true`, so the operation can continue
  // 4. _postViewInit(): add/remove the views from the navigation stack
  // 5. _transitionInit(): initializes the visual transition if required and schedules it to run
  // 6. _viewAttachToDOM(): attaches the enteringView to the DOM
  // 7. _transitionStart(): called once the transition actually starts, it initializes the Animation underneath.
  // 8. _transitionFinish(): called once the transition finishes
  // 9. _cleanup(): syncs the navigation internal state with the DOM. For example it removes the pages from the DOM or hides/show them.
  async queueTrns(ti, done) {
    if (this.isTransitioning && ti.opts != null && ti.opts.skipIfBusy) {
      return Promise.resolve(false);
    }
    const promise = new Promise((resolve, reject) => {
      ti.resolve = resolve;
      ti.reject = reject;
    });
    ti.done = done;
    /**
     * If using router, check to see if navigation hooks
     * will allow us to perform this transition. This
     * is required in order for hooks to work with
     * the ion-back-button or swipe to go back.
     */
    if (ti.opts && ti.opts.updateURL !== false && this.useRouter) {
      const router = document.querySelector('ion-router');
      if (router) {
        const canTransition = await router.canTransition();
        if (canTransition === false) {
          return Promise.resolve(false);
        }
        else if (typeof canTransition === 'string') {
          router.push(canTransition, ti.opts.direction || 'back');
          return Promise.resolve(false);
        }
      }
    }
    // Normalize empty
    if (ti.insertViews && ti.insertViews.length === 0) {
      ti.insertViews = undefined;
    }
    // Enqueue transition instruction
    this.transInstr.push(ti);
    // if there isn't a transition already happening
    // then this will kick off this transition
    this.nextTrns();
    return promise;
  }
  success(result, ti) {
    if (this.destroyed) {
      this.fireError('nav controller was destroyed', ti);
      return;
    }
    if (ti.done) {
      ti.done(result.hasCompleted, result.requiresTransition, result.enteringView, result.leavingView, result.direction);
    }
    ti.resolve(result.hasCompleted);
    if (ti.opts.updateURL !== false && this.useRouter) {
      const router = document.querySelector('ion-router');
      if (router) {
        const direction = result.direction === 'back' ? 'back' : 'forward';
        router.navChanged(direction);
      }
    }
  }
  failed(rejectReason, ti) {
    if (this.destroyed) {
      this.fireError('nav controller was destroyed', ti);
      return;
    }
    this.transInstr.length = 0;
    this.fireError(rejectReason, ti);
  }
  fireError(rejectReason, ti) {
    if (ti.done) {
      ti.done(false, false, rejectReason);
    }
    if (ti.reject && !this.destroyed) {
      ti.reject(rejectReason);
    }
    else {
      ti.resolve(false);
    }
  }
  nextTrns() {
    // this is the framework's bread 'n butta function
    // only one transition is allowed at any given time
    if (this.isTransitioning) {
      return false;
    }
    // there is no transition happening right now
    // get the next instruction
    const ti = this.transInstr.shift();
    if (!ti) {
      return false;
    }
    this.runTransition(ti);
    return true;
  }
  async runTransition(ti) {
    try {
      // set that this nav is actively transitioning
      this.ionNavWillChange.emit();
      this.isTransitioning = true;
      this.prepareTI(ti);
      const leavingView = this.getActiveSync();
      const enteringView = this.getEnteringView(ti, leavingView);
      if (!leavingView && !enteringView) {
        throw new Error('no views in the stack to be removed');
      }
      if (enteringView && enteringView.state === VIEW_STATE_NEW) {
        await enteringView.init(this.el);
      }
      this.postViewInit(enteringView, leavingView, ti);
      // Needs transition?
      const requiresTransition = (ti.enteringRequiresTransition || ti.leavingRequiresTransition) &&
        enteringView !== leavingView;
      if (requiresTransition && ti.opts && leavingView) {
        const isBackDirection = ti.opts.direction === 'back';
        /**
         * If heading back, use the entering page's animation
         * unless otherwise specified by the developer.
         */
        if (isBackDirection) {
          ti.opts.animationBuilder = ti.opts.animationBuilder || (enteringView && enteringView.animationBuilder);
        }
        leavingView.animationBuilder = ti.opts.animationBuilder;
      }
      const result = requiresTransition
        ? await this.transition(enteringView, leavingView, ti)
        : {
          // transition is not required, so we are already done!
          // they're inserting/removing the views somewhere in the middle or
          // beginning, so visually nothing needs to animate/transition
          // resolve immediately because there's no animation that's happening
          hasCompleted: true,
          requiresTransition: false
        };
      this.success(result, ti);
      this.ionNavDidChange.emit();
    }
    catch (rejectReason) {
      this.failed(rejectReason, ti);
    }
    this.isTransitioning = false;
    this.nextTrns();
  }
  prepareTI(ti) {
    const viewsLength = this.views.length;
    ti.opts = ti.opts || {};
    if (ti.opts.delegate === undefined) {
      ti.opts.delegate = this.delegate;
    }
    if (ti.removeView !== undefined) {
      (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(ti.removeStart !== undefined, 'removeView needs removeStart');
      (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(ti.removeCount !== undefined, 'removeView needs removeCount');
      const index = this.views.indexOf(ti.removeView);
      if (index < 0) {
        throw new Error('removeView was not found');
      }
      ti.removeStart += index;
    }
    if (ti.removeStart !== undefined) {
      if (ti.removeStart < 0) {
        ti.removeStart = viewsLength - 1;
      }
      if (ti.removeCount < 0) {
        ti.removeCount = viewsLength - ti.removeStart;
      }
      ti.leavingRequiresTransition =
        ti.removeCount > 0 && ti.removeStart + ti.removeCount === viewsLength;
    }
    if (ti.insertViews) {
      // allow -1 to be passed in to auto push it on the end
      // and clean up the index if it's larger then the size of the stack
      if (ti.insertStart < 0 || ti.insertStart > viewsLength) {
        ti.insertStart = viewsLength;
      }
      ti.enteringRequiresTransition = ti.insertStart === viewsLength;
    }
    const insertViews = ti.insertViews;
    if (!insertViews) {
      return;
    }
    (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(insertViews.length > 0, 'length can not be zero');
    const viewControllers = convertToViews(insertViews);
    if (viewControllers.length === 0) {
      throw new Error('invalid views to insert');
    }
    // Check all the inserted view are correct
    for (const view of viewControllers) {
      view.delegate = ti.opts.delegate;
      const nav = view.nav;
      if (nav && nav !== this) {
        throw new Error('inserted view was already inserted');
      }
      if (view.state === VIEW_STATE_DESTROYED) {
        throw new Error('inserted view was already destroyed');
      }
    }
    ti.insertViews = viewControllers;
  }
  getEnteringView(ti, leavingView) {
    const insertViews = ti.insertViews;
    if (insertViews !== undefined) {
      // grab the very last view of the views to be inserted
      // and initialize it as the new entering view
      return insertViews[insertViews.length - 1];
    }
    const removeStart = ti.removeStart;
    if (removeStart !== undefined) {
      const views = this.views;
      const removeEnd = removeStart + ti.removeCount;
      for (let i = views.length - 1; i >= 0; i--) {
        const view = views[i];
        if ((i < removeStart || i >= removeEnd) && view !== leavingView) {
          return view;
        }
      }
    }
    return undefined;
  }
  postViewInit(enteringView, leavingView, ti) {
    (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(leavingView || enteringView, 'Both leavingView and enteringView are null');
    (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(ti.resolve, 'resolve must be valid');
    (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(ti.reject, 'reject must be valid');
    const opts = ti.opts;
    const insertViews = ti.insertViews;
    const removeStart = ti.removeStart;
    const removeCount = ti.removeCount;
    let destroyQueue;
    // there are views to remove
    if (removeStart !== undefined && removeCount !== undefined) {
      (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(removeStart >= 0, 'removeStart can not be negative');
      (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(removeCount >= 0, 'removeCount can not be negative');
      destroyQueue = [];
      for (let i = 0; i < removeCount; i++) {
        const view = this.views[i + removeStart];
        if (view && view !== enteringView && view !== leavingView) {
          destroyQueue.push(view);
        }
      }
      // default the direction to "back"
      opts.direction = opts.direction || 'back';
    }
    const finalBalance = this.views.length +
      (insertViews !== undefined ? insertViews.length : 0) -
      (removeCount !== undefined ? removeCount : 0);
    (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(finalBalance >= 0, 'final balance can not be negative');
    if (finalBalance === 0) {
      console.warn(`You can't remove all the pages in the navigation stack. nav.pop() is probably called too many times.`, this, this.el);
      throw new Error('navigation stack needs at least one root page');
    }
    // At this point the transition can not be rejected, any throw should be an error
    // there are views to insert
    if (insertViews) {
      // add the views to the
      let insertIndex = ti.insertStart;
      for (const view of insertViews) {
        this.insertViewAt(view, insertIndex);
        insertIndex++;
      }
      if (ti.enteringRequiresTransition) {
        // default to forward if not already set
        opts.direction = opts.direction || 'forward';
      }
    }
    // if the views to be removed are in the beginning or middle
    // and there is not a view that needs to visually transition out
    // then just destroy them and don't transition anything
    // batch all of lifecycles together
    // let's make sure, callbacks are zoned
    if (destroyQueue && destroyQueue.length > 0) {
      for (const view of destroyQueue) {
        (0,_index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.l)(view.element, _index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.b);
        (0,_index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.l)(view.element, _index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.c);
        (0,_index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.l)(view.element, _index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.d);
      }
      // once all lifecycle events has been delivered, we can safely detroy the views
      for (const view of destroyQueue) {
        this.destroyView(view);
      }
    }
  }
  async transition(enteringView, leavingView, ti) {
    // we should animate (duration > 0) if the pushed page is not the first one (startup)
    // or if it is a portal (modal, actionsheet, etc.)
    const opts = ti.opts;
    const progressCallback = opts.progressAnimation
      ? (ani) => this.sbAni = ani
      : undefined;
    const mode = (0,_ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_1__.b)(this);
    const enteringEl = enteringView.element;
    const leavingEl = leavingView && leavingView.element;
    const animationOpts = Object.assign(Object.assign({ mode, showGoBack: this.canGoBackSync(enteringView), baseEl: this.el, progressCallback, animated: this.animated && _ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_1__.c.getBoolean('animated', true), enteringEl,
      leavingEl }, opts), { animationBuilder: opts.animationBuilder || this.animation || _ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_1__.c.get('navAnimation') });
    const { hasCompleted } = await (0,_index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.t)(animationOpts);
    return this.transitionFinish(hasCompleted, enteringView, leavingView, opts);
  }
  transitionFinish(hasCompleted, enteringView, leavingView, opts) {
    const cleanupView = hasCompleted ? enteringView : leavingView;
    if (cleanupView) {
      this.cleanup(cleanupView);
    }
    return {
      hasCompleted,
      requiresTransition: true,
      enteringView,
      leavingView,
      direction: opts.direction
    };
  }
  insertViewAt(view, index) {
    const views = this.views;
    const existingIndex = views.indexOf(view);
    if (existingIndex > -1) {
      // this view is already in the stack!!
      // move it to its new location
      (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(view.nav === this, 'view is not part of the nav');
      views.splice(index, 0, views.splice(existingIndex, 1)[0]);
    }
    else {
      (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(!view.nav, 'nav is used');
      // this is a new view to add to the stack
      // create the new entering view
      view.nav = this;
      // insert the entering view into the correct index in the stack
      views.splice(index, 0, view);
    }
  }
  removeView(view) {
    (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(view.state === VIEW_STATE_ATTACHED || view.state === VIEW_STATE_DESTROYED, 'view state should be loaded or destroyed');
    const views = this.views;
    const index = views.indexOf(view);
    (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_3__.m)(index > -1, 'view must be part of the stack');
    if (index >= 0) {
      views.splice(index, 1);
    }
  }
  destroyView(view) {
    view._destroy();
    this.removeView(view);
  }
  /**
   * DOM WRITE
   */
  cleanup(activeView) {
    // ok, cleanup time!! Destroy all of the views that are
    // INACTIVE and come after the active view
    // only do this if the views exist, though
    if (this.destroyed) {
      return;
    }
    const views = this.views;
    const activeViewIndex = views.indexOf(activeView);
    for (let i = views.length - 1; i >= 0; i--) {
      const view = views[i];
      /**
       * When inserting multiple views via insertPages
       * the last page will be transitioned to, but the
       * others will not be. As a result, a DOM element
       * will only be created for the last page inserted.
       * As a result, it is possible to have views in the
       * stack that do not have `view.element` yet.
       */
      const element = view.element;
      if (element) {
        if (i > activeViewIndex) {
          // this view comes after the active view
          // let's unload it
          (0,_index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.l)(element, _index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.d);
          this.destroyView(view);
        }
        else if (i < activeViewIndex) {
          // this view comes before the active view
          // and it is not a portal then ensure it is hidden
          (0,_index_c8ef55b5_js__WEBPACK_IMPORTED_MODULE_4__.s)(element, true);
        }
      }
    }
  }
  canStart() {
    return (!!this.swipeGesture &&
      !this.isTransitioning &&
      this.transInstr.length === 0 &&
      this.animationEnabled &&
      this.canGoBackSync());
  }
  onStart() {
    this.queueTrns({
      removeStart: -1,
      removeCount: 1,
      opts: {
        direction: 'back',
        progressAnimation: true
      }
    }, undefined);
  }
  onMove(stepValue) {
    if (this.sbAni) {
      this.sbAni.progressStep(stepValue);
    }
  }
  onEnd(shouldComplete, stepValue, dur) {
    if (this.sbAni) {
      this.animationEnabled = false;
      this.sbAni.onFinish(() => {
        this.animationEnabled = true;
      }, { oneTimeCallback: true });
      // Account for rounding errors in JS
      let newStepValue = (shouldComplete) ? -0.001 : 0.001;
      /**
       * Animation will be reversed here, so need to
       * reverse the easing curve as well
       *
       * Additionally, we need to account for the time relative
       * to the new easing curve, as `stepValue` is going to be given
       * in terms of a linear curve.
       */
      if (!shouldComplete) {
        this.sbAni.easing('cubic-bezier(1, 0, 0.68, 0.28)');
        newStepValue += (0,_cubic_bezier_154a53a5_js__WEBPACK_IMPORTED_MODULE_2__.g)([0, 0], [1, 0], [0.68, 0.28], [1, 1], stepValue)[0];
      }
      else {
        newStepValue += (0,_cubic_bezier_154a53a5_js__WEBPACK_IMPORTED_MODULE_2__.g)([0, 0], [0.32, 0.72], [0, 1], [1, 1], stepValue)[0];
      }
      this.sbAni.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);
    }
  }
  render() {
    return ((0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null));
  }
  get el() { return (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.i)(this); }
  static get watchers() { return {
    "swipeGesture": ["swipeGestureChanged"],
    "root": ["rootChanged"]
  }; }
};
Nav.style = navCss;

const navLink = (el, routerDirection, component, componentProps, routerAnimation) => {
  const nav = el.closest('ion-nav');
  if (nav) {
    if (routerDirection === 'forward') {
      if (component !== undefined) {
        return nav.push(component, componentProps, { skipIfBusy: true, animationBuilder: routerAnimation });
      }
    }
    else if (routerDirection === 'root') {
      if (component !== undefined) {
        return nav.setRoot(component, componentProps, { skipIfBusy: true, animationBuilder: routerAnimation });
      }
    }
    else if (routerDirection === 'back') {
      return nav.pop({ skipIfBusy: true, animationBuilder: routerAnimation });
    }
  }
  return Promise.resolve(false);
};

let NavLink = class {
  constructor(hostRef) {
    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    /**
     * The transition direction when navigating to another page.
     */
    this.routerDirection = 'forward';
    this.onClick = () => {
      return navLink(this.el, this.routerDirection, this.component, this.componentProps, this.routerAnimation);
    };
  }
  render() {
    return ((0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.H, { onClick: this.onClick }));
  }
  get el() { return (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.i)(this); }
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfZGlzdF9lc21faW9uLW5hdl8yX2VudHJ5X2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQzZHO0FBQ25DO0FBQ0E7QUFDdEI7QUFDdUg7QUFDbkc7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtFQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHNCQUFzQixPQUFPLFFBQVEsTUFBTSxTQUFTLGtCQUFrQiwwQkFBMEIsZ0JBQWdCLFVBQVU7O0FBRTFIO0FBQ0E7QUFDQSxJQUFJLHFEQUFnQjtBQUNwQiwwQkFBMEIscURBQVc7QUFDckMsNEJBQTRCLHFEQUFXO0FBQ3ZDLDJCQUEyQixxREFBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0REFBVTtBQUM3QiwwQkFBMEIsbUVBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbVBBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBUyxlQUFlLGlEQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxpQkFBaUIsZ0RBQWdEO0FBQzNJO0FBQ0E7QUFDQSxxRUFBcUUsaUJBQWlCLDZCQUE2QjtBQUNuSDtBQUNBO0FBQ0Esd0VBQXdFLGlCQUFpQixnRUFBZ0U7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQU07QUFDWixNQUFNLHVEQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFNO0FBQ1YsSUFBSSx1REFBTTtBQUNWLElBQUksdURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQU07QUFDWixNQUFNLHVEQUFNO0FBQ1o7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFTLGVBQWUsaURBQW9CO0FBQ3BELFFBQVEscURBQVMsZUFBZSxpREFBbUI7QUFDbkQsUUFBUSxxREFBUyxlQUFlLGlEQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDREQUFVO0FBQzNCO0FBQ0E7QUFDQSx3REFBd0Qsa0hBQWtILG1FQUFpQjtBQUMzTCxpQkFBaUIsV0FBVyw2REFBNkQsNERBQVUsa0JBQWtCO0FBQ3JILFlBQVksZUFBZSxRQUFRLHFEQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdURBQU07QUFDVjtBQUNBO0FBQ0EsSUFBSSx1REFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxREFBUyxVQUFVLGlEQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxREFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNERBQXVCO0FBQy9DO0FBQ0E7QUFDQSx3QkFBd0IsNERBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFDO0FBQ2I7QUFDQSxhQUFhLE9BQU8scURBQVU7QUFDOUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxREFBcUQ7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscURBQXFEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBcUQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUkscURBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQUMsQ0FBQyxpREFBSSxJQUFJLHVCQUF1QjtBQUM3QztBQUNBLGFBQWEsT0FBTyxxREFBVTtBQUM5Qjs7QUFFbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL2lvbi1uYXZfMi5lbnRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBlIGFzIGNyZWF0ZUV2ZW50LCBoLCBpIGFzIGdldEVsZW1lbnQsIEggYXMgSG9zdCB9IGZyb20gJy4vaW5kZXgtMDZjZDI3YjEuanMnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlLCBjIGFzIGNvbmZpZyB9IGZyb20gJy4vaW9uaWMtZ2xvYmFsLWEwNDliY2JmLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0VGltZUdpdmVuUHJvZ3Jlc3Npb24gfSBmcm9tICcuL2N1YmljLWJlemllci0xNTRhNTNhNS5qcyc7XG5pbXBvcnQgeyBtIGFzIGFzc2VydCB9IGZyb20gJy4vaGVscGVycy1lZWQ3OWEyYi5qcyc7XG5pbXBvcnQgeyBsIGFzIGxpZmVjeWNsZSwgdCBhcyB0cmFuc2l0aW9uLCBzIGFzIHNldFBhZ2VIaWRkZW4sIGQgYXMgTElGRUNZQ0xFX1dJTExfVU5MT0FELCBiIGFzIExJRkVDWUNMRV9XSUxMX0xFQVZFLCBjIGFzIExJRkVDWUNMRV9ESURfTEVBVkUgfSBmcm9tICcuL2luZGV4LWM4ZWY1NWI1LmpzJztcbmltcG9ydCB7IGEgYXMgYXR0YWNoQ29tcG9uZW50IH0gZnJvbSAnLi9mcmFtZXdvcmstZGVsZWdhdGUtYTkyMjAxOGMuanMnO1xuXG5jb25zdCBWSUVXX1NUQVRFX05FVyA9IDE7XG5jb25zdCBWSUVXX1NUQVRFX0FUVEFDSEVEID0gMjtcbmNvbnN0IFZJRVdfU1RBVEVfREVTVFJPWUVEID0gMztcbmNsYXNzIFZpZXdDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY29tcG9uZW50LCBwYXJhbXMpIHtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLnN0YXRlID0gVklFV19TVEFURV9ORVc7XG4gIH1cbiAgYXN5bmMgaW5pdChjb250YWluZXIpIHtcbiAgICB0aGlzLnN0YXRlID0gVklFV19TVEFURV9BVFRBQ0hFRDtcbiAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBhd2FpdCBhdHRhY2hDb21wb25lbnQodGhpcy5kZWxlZ2F0ZSwgY29udGFpbmVyLCBjb21wb25lbnQsIFsnaW9uLXBhZ2UnLCAnaW9uLXBhZ2UtaW52aXNpYmxlJ10sIHRoaXMucGFyYW1zKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERPTSBXUklURVxuICAgKi9cbiAgX2Rlc3Ryb3koKSB7XG4gICAgYXNzZXJ0KHRoaXMuc3RhdGUgIT09IFZJRVdfU1RBVEVfREVTVFJPWUVELCAndmlldyBzdGF0ZSBtdXN0IGJlIEFUVEFDSEVEJyk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMuZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5yZW1vdmVWaWV3RnJvbURvbShlbGVtZW50LnBhcmVudEVsZW1lbnQsIGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubmF2ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RhdGUgPSBWSUVXX1NUQVRFX0RFU1RST1lFRDtcbiAgfVxufVxuY29uc3QgbWF0Y2hlcyA9ICh2aWV3LCBpZCwgcGFyYW1zKSA9PiB7XG4gIGlmICghdmlldykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmlldy5jb21wb25lbnQgIT09IGlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRQYXJhbXMgPSB2aWV3LnBhcmFtcztcbiAgaWYgKGN1cnJlbnRQYXJhbXMgPT09IHBhcmFtcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghY3VycmVudFBhcmFtcyAmJiAhcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFjdXJyZW50UGFyYW1zIHx8ICFwYXJhbXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhjdXJyZW50UGFyYW1zKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhwYXJhbXMpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5c0EpIHtcbiAgICBpZiAoY3VycmVudFBhcmFtc1trZXldICE9PSBwYXJhbXNba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBjb252ZXJ0VG9WaWV3ID0gKHBhZ2UsIHBhcmFtcykgPT4ge1xuICBpZiAoIXBhZ2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocGFnZSBpbnN0YW5jZW9mIFZpZXdDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIHBhZ2U7XG4gIH1cbiAgcmV0dXJuIG5ldyBWaWV3Q29udHJvbGxlcihwYWdlLCBwYXJhbXMpO1xufTtcbmNvbnN0IGNvbnZlcnRUb1ZpZXdzID0gKHBhZ2VzKSA9PiB7XG4gIHJldHVybiBwYWdlcy5tYXAocGFnZSA9PiB7XG4gICAgaWYgKHBhZ2UgaW5zdGFuY2VvZiBWaWV3Q29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfVxuICAgIGlmICgnY29tcG9uZW50JyBpbiBwYWdlKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRPRE8gSW9uaWMgNjpcbiAgICAgICAqIENvbnNpZGVyIHN3aXRjaGluZyB0byBqdXN0IHVzaW5nIGB1bmRlZmluZWRgIGhlcmVcbiAgICAgICAqIGFzIHdlbGwgYXMgb24gdGhlIHB1YmxpYyBpbnRlcmZhY2VzIGFuZCBvblxuICAgICAgICogYE5hdkNvbXBvbmVudFdpdGhQcm9wc2AuIFByZXZpb3VzbHkgYHBhZ2VzYCB3YXNcbiAgICAgICAqIG9mIHR5cGUgYGFueVtdYCBzbyBUeXBlU2NyaXB0IGRpZCBub3QgY2F0Y2ggdGhpcy5cbiAgICAgICAqL1xuICAgICAgcmV0dXJuIGNvbnZlcnRUb1ZpZXcocGFnZS5jb21wb25lbnQsIChwYWdlLmNvbXBvbmVudFByb3BzID09PSBudWxsKSA/IHVuZGVmaW5lZCA6IHBhZ2UuY29tcG9uZW50UHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvVmlldyhwYWdlLCB1bmRlZmluZWQpO1xuICB9KS5maWx0ZXIodiA9PiB2ICE9PSBudWxsKTtcbn07XG5cbmNvbnN0IG5hdkNzcyA9IFwiOmhvc3R7bGVmdDowO3JpZ2h0OjA7dG9wOjA7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7Y29udGFpbjpsYXlvdXQgc2l6ZSBzdHlsZTtvdmVyZmxvdzpoaWRkZW47ei1pbmRleDowfVwiO1xuXG5sZXQgTmF2ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmlvbk5hdldpbGxMb2FkID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25OYXZXaWxsTG9hZFwiLCA3KTtcbiAgICB0aGlzLmlvbk5hdldpbGxDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvbk5hdldpbGxDaGFuZ2VcIiwgMyk7XG4gICAgdGhpcy5pb25OYXZEaWRDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvbk5hdkRpZENoYW5nZVwiLCAzKTtcbiAgICB0aGlzLnRyYW5zSW5zdHIgPSBbXTtcbiAgICB0aGlzLmFuaW1hdGlvbkVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMudXNlUm91dGVyID0gZmFsc2U7XG4gICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBuYXYgc2hvdWxkIGFuaW1hdGUgdGhlIHRyYW5zaXRpb24gb2YgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgfVxuICBzd2lwZUdlc3R1cmVDaGFuZ2VkKCkge1xuICAgIGlmICh0aGlzLmdlc3R1cmUpIHtcbiAgICAgIHRoaXMuZ2VzdHVyZS5lbmFibGUodGhpcy5zd2lwZUdlc3R1cmUgPT09IHRydWUpO1xuICAgIH1cbiAgfVxuICByb290Q2hhbmdlZCgpIHtcbiAgICBpZiAodGhpcy5yb290ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghdGhpcy51c2VSb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5zZXRSb290KHRoaXMucm9vdCwgdGhpcy5yb290UGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgdGhpcy51c2VSb3V0ZXIgPVxuICAgICAgISFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpb24tcm91dGVyJykgJiZcbiAgICAgICAgIXRoaXMuZWwuY2xvc2VzdCgnW25vLXJvdXRlcl0nKTtcbiAgICBpZiAodGhpcy5zd2lwZUdlc3R1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgICB0aGlzLnN3aXBlR2VzdHVyZSA9IGNvbmZpZy5nZXRCb29sZWFuKCdzd2lwZUJhY2tFbmFibGVkJywgbW9kZSA9PT0gJ2lvcycpO1xuICAgIH1cbiAgICB0aGlzLmlvbk5hdldpbGxMb2FkLmVtaXQoKTtcbiAgfVxuICBhc3luYyBjb21wb25lbnREaWRMb2FkKCkge1xuICAgIHRoaXMucm9vdENoYW5nZWQoKTtcbiAgICB0aGlzLmdlc3R1cmUgPSAoYXdhaXQgaW1wb3J0KCcuL3N3aXBlLWJhY2stZWRjNDU1ZTIuanMnKSkuY3JlYXRlU3dpcGVCYWNrR2VzdHVyZSh0aGlzLmVsLCB0aGlzLmNhblN0YXJ0LmJpbmQodGhpcyksIHRoaXMub25TdGFydC5iaW5kKHRoaXMpLCB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpLCB0aGlzLm9uRW5kLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc3dpcGVHZXN0dXJlQ2hhbmdlZCgpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGZvciAoY29uc3QgdmlldyBvZiB0aGlzLnZpZXdzKSB7XG4gICAgICBsaWZlY3ljbGUodmlldy5lbGVtZW50LCBMSUZFQ1lDTEVfV0lMTF9VTkxPQUQpO1xuICAgICAgdmlldy5fZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXN0dXJlKSB7XG4gICAgICB0aGlzLmdlc3R1cmUuZGVzdHJveSgpO1xuICAgICAgdGhpcy5nZXN0dXJlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIHN3aXBlIGJhY2sgZ2VzdHVyZSBhbmQgdHJhbnNpdGlvblxuICAgIHRoaXMudHJhbnNJbnN0ci5sZW5ndGggPSB0aGlzLnZpZXdzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBQdXNoIGEgbmV3IGNvbXBvbmVudCBvbnRvIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gc3RhY2suIFBhc3MgYW55IGFkZGl0aW9uYWxcbiAgICogaW5mb3JtYXRpb24gYWxvbmcgYXMgYW4gb2JqZWN0LiBUaGlzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaXMgYWNjZXNzaWJsZVxuICAgKiB0aHJvdWdoIE5hdlBhcmFtcy5cbiAgICpcbiAgICogQHBhcmFtIGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIHB1c2ggb250byB0aGUgbmF2aWdhdGlvbiBzdGFjay5cbiAgICogQHBhcmFtIGNvbXBvbmVudFByb3BzIEFueSBwcm9wZXJ0aWVzIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBvcHRzIFRoZSBuYXZpZ2F0aW9uIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBkb25lIFRoZSB0cmFuc2l0aW9uIGNvbXBsZXRlIGZ1bmN0aW9uLlxuICAgKi9cbiAgcHVzaChjb21wb25lbnQsIGNvbXBvbmVudFByb3BzLCBvcHRzLCBkb25lKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVUcm5zKHtcbiAgICAgIGluc2VydFN0YXJ0OiAtMSxcbiAgICAgIGluc2VydFZpZXdzOiBbeyBjb21wb25lbnQsIGNvbXBvbmVudFByb3BzIH1dLFxuICAgICAgb3B0c1xuICAgIH0sIGRvbmUpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgY29tcG9uZW50IGludG8gdGhlIG5hdmlnYXRpb24gc3RhY2sgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogVGhpcyBpcyB1c2VmdWwgdG8gYWRkIGEgY29tcG9uZW50IGF0IGFueSBwb2ludCBpbiB0aGUgbmF2aWdhdGlvbiBzdGFjay5cbiAgICpcbiAgICogQHBhcmFtIGluc2VydEluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgdGhlIGNvbXBvbmVudCBhdCBpbiB0aGUgc3RhY2suXG4gICAqIEBwYXJhbSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBpbnNlcnQgaW50byB0aGUgbmF2aWdhdGlvbiBzdGFjay5cbiAgICogQHBhcmFtIGNvbXBvbmVudFByb3BzIEFueSBwcm9wZXJ0aWVzIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBvcHRzIFRoZSBuYXZpZ2F0aW9uIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBkb25lIFRoZSB0cmFuc2l0aW9uIGNvbXBsZXRlIGZ1bmN0aW9uLlxuICAgKi9cbiAgaW5zZXJ0KGluc2VydEluZGV4LCBjb21wb25lbnQsIGNvbXBvbmVudFByb3BzLCBvcHRzLCBkb25lKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVUcm5zKHtcbiAgICAgIGluc2VydFN0YXJ0OiBpbnNlcnRJbmRleCxcbiAgICAgIGluc2VydFZpZXdzOiBbeyBjb21wb25lbnQsIGNvbXBvbmVudFByb3BzIH1dLFxuICAgICAgb3B0c1xuICAgIH0sIGRvbmUpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuIGFycmF5IG9mIGNvbXBvbmVudHMgaW50byB0aGUgbmF2aWdhdGlvbiBzdGFjayBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBUaGUgbGFzdCBjb21wb25lbnQgaW4gdGhlIGFycmF5IHdpbGwgYmVjb21lIGluc3RhbnRpYXRlZCBhcyBhIHZpZXcsIGFuZCBhbmltYXRlXG4gICAqIGluIHRvIGJlY29tZSB0aGUgYWN0aXZlIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSBpbnNlcnRJbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IHRoZSBjb21wb25lbnRzIGF0IGluIHRoZSBzdGFjay5cbiAgICogQHBhcmFtIGluc2VydENvbXBvbmVudHMgVGhlIGNvbXBvbmVudHMgdG8gaW5zZXJ0IGludG8gdGhlIG5hdmlnYXRpb24gc3RhY2suXG4gICAqIEBwYXJhbSBvcHRzIFRoZSBuYXZpZ2F0aW9uIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBkb25lIFRoZSB0cmFuc2l0aW9uIGNvbXBsZXRlIGZ1bmN0aW9uLlxuICAgKi9cbiAgaW5zZXJ0UGFnZXMoaW5zZXJ0SW5kZXgsIGluc2VydENvbXBvbmVudHMsIG9wdHMsIGRvbmUpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZVRybnMoe1xuICAgICAgaW5zZXJ0U3RhcnQ6IGluc2VydEluZGV4LFxuICAgICAgaW5zZXJ0Vmlld3M6IGluc2VydENvbXBvbmVudHMsXG4gICAgICBvcHRzXG4gICAgfSwgZG9uZSk7XG4gIH1cbiAgLyoqXG4gICAqIFBvcCBhIGNvbXBvbmVudCBvZmYgb2YgdGhlIG5hdmlnYXRpb24gc3RhY2suIE5hdmlnYXRlcyBiYWNrIGZyb20gdGhlIGN1cnJlbnRcbiAgICogY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyBUaGUgbmF2aWdhdGlvbiBvcHRpb25zLlxuICAgKiBAcGFyYW0gZG9uZSBUaGUgdHJhbnNpdGlvbiBjb21wbGV0ZSBmdW5jdGlvbi5cbiAgICovXG4gIHBvcChvcHRzLCBkb25lKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVUcm5zKHtcbiAgICAgIHJlbW92ZVN0YXJ0OiAtMSxcbiAgICAgIHJlbW92ZUNvdW50OiAxLFxuICAgICAgb3B0c1xuICAgIH0sIGRvbmUpO1xuICB9XG4gIC8qKlxuICAgKiBQb3AgdG8gYSBzcGVjaWZpYyBpbmRleCBpbiB0aGUgbmF2aWdhdGlvbiBzdGFjay5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4T3JWaWV3Q3RybCBUaGUgaW5kZXggb3IgdmlldyBjb250cm9sbGVyIHRvIHBvcCB0by5cbiAgICogQHBhcmFtIG9wdHMgVGhlIG5hdmlnYXRpb24gb3B0aW9ucy5cbiAgICogQHBhcmFtIGRvbmUgVGhlIHRyYW5zaXRpb24gY29tcGxldGUgZnVuY3Rpb24uXG4gICAqL1xuICBwb3BUbyhpbmRleE9yVmlld0N0cmwsIG9wdHMsIGRvbmUpIHtcbiAgICBjb25zdCB0aUNvbmZpZyA9IHtcbiAgICAgIHJlbW92ZVN0YXJ0OiAtMSxcbiAgICAgIHJlbW92ZUNvdW50OiAtMSxcbiAgICAgIG9wdHNcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgaW5kZXhPclZpZXdDdHJsID09PSAnb2JqZWN0JyAmJiBpbmRleE9yVmlld0N0cmwuY29tcG9uZW50KSB7XG4gICAgICB0aUNvbmZpZy5yZW1vdmVWaWV3ID0gaW5kZXhPclZpZXdDdHJsO1xuICAgICAgdGlDb25maWcucmVtb3ZlU3RhcnQgPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5kZXhPclZpZXdDdHJsID09PSAnbnVtYmVyJykge1xuICAgICAgdGlDb25maWcucmVtb3ZlU3RhcnQgPSBpbmRleE9yVmlld0N0cmwgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5xdWV1ZVRybnModGlDb25maWcsIGRvbmUpO1xuICB9XG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSBiYWNrIHRvIHRoZSByb290IG9mIHRoZSBzdGFjaywgbm8gbWF0dGVyIGhvdyBmYXIgYmFjayB0aGF0IGlzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyBUaGUgbmF2aWdhdGlvbiBvcHRpb25zLlxuICAgKiBAcGFyYW0gZG9uZSBUaGUgdHJhbnNpdGlvbiBjb21wbGV0ZSBmdW5jdGlvbi5cbiAgICovXG4gIHBvcFRvUm9vdChvcHRzLCBkb25lKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVUcm5zKHtcbiAgICAgIHJlbW92ZVN0YXJ0OiAxLFxuICAgICAgcmVtb3ZlQ291bnQ6IC0xLFxuICAgICAgb3B0c1xuICAgIH0sIGRvbmUpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IGZyb20gdGhlIG5hdmlnYXRpb24gc3RhY2sgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIG51bWJlciB0byBiZWdpbiByZW1vdmFsIGF0LlxuICAgKiBAcGFyYW0gcmVtb3ZlQ291bnQgVGhlIG51bWJlciBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIG9wdHMgVGhlIG5hdmlnYXRpb24gb3B0aW9ucy5cbiAgICogQHBhcmFtIGRvbmUgVGhlIHRyYW5zaXRpb24gY29tcGxldGUgZnVuY3Rpb24uXG4gICAqL1xuICByZW1vdmVJbmRleChzdGFydEluZGV4LCByZW1vdmVDb3VudCA9IDEsIG9wdHMsIGRvbmUpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZVRybnMoe1xuICAgICAgcmVtb3ZlU3RhcnQ6IHN0YXJ0SW5kZXgsXG4gICAgICByZW1vdmVDb3VudCxcbiAgICAgIG9wdHNcbiAgICB9LCBkb25lKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSByb290IGZvciB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIHN0YWNrIHRvIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gc2V0IGFzIHRoZSByb290IG9mIHRoZSBuYXZpZ2F0aW9uIHN0YWNrLlxuICAgKiBAcGFyYW0gY29tcG9uZW50UHJvcHMgQW55IHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIG9wdHMgVGhlIG5hdmlnYXRpb24gb3B0aW9ucy5cbiAgICogQHBhcmFtIGRvbmUgVGhlIHRyYW5zaXRpb24gY29tcGxldGUgZnVuY3Rpb24uXG4gICAqL1xuICBzZXRSb290KGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMsIG9wdHMsIGRvbmUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRQYWdlcyhbeyBjb21wb25lbnQsIGNvbXBvbmVudFByb3BzIH1dLCBvcHRzLCBkb25lKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB2aWV3cyBvZiB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIHN0YWNrIGFuZCBuYXZpZ2F0ZSB0byB0aGUgbGFzdCB2aWV3LlxuICAgKiBCeSBkZWZhdWx0IGFuaW1hdGlvbnMgYXJlIGRpc2FibGVkLCBidXQgdGhleSBjYW4gYmUgZW5hYmxlZCBieSBwYXNzaW5nIG9wdGlvbnNcbiAgICogdG8gdGhlIG5hdmlnYXRpb24gY29udHJvbGxlci4gTmF2aWdhdGlvbiBwYXJhbWV0ZXJzIGNhbiBhbHNvIGJlIHBhc3NlZCB0byB0aGVcbiAgICogaW5kaXZpZHVhbCBwYWdlcyBpbiB0aGUgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB2aWV3cyBUaGUgbGlzdCBvZiB2aWV3cyB0byBzZXQgYXMgdGhlIG5hdmlnYXRpb24gc3RhY2suXG4gICAqIEBwYXJhbSBvcHRzIFRoZSBuYXZpZ2F0aW9uIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBkb25lIFRoZSB0cmFuc2l0aW9uIGNvbXBsZXRlIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2V0UGFnZXModmlld3MsIG9wdHMsIGRvbmUpIHtcbiAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIC8vIGlmIGFuaW1hdGlvbiB3YXNuJ3Qgc2V0IHRvIHRydWUgdGhlbiBkZWZhdWx0IGl0IHRvIE5PVCBhbmltYXRlXG4gICAgaWYgKG9wdHMuYW5pbWF0ZWQgIT09IHRydWUpIHtcbiAgICAgIG9wdHMuYW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucXVldWVUcm5zKHtcbiAgICAgIGluc2VydFN0YXJ0OiAwLFxuICAgICAgaW5zZXJ0Vmlld3M6IHZpZXdzLFxuICAgICAgcmVtb3ZlU3RhcnQ6IDAsXG4gICAgICByZW1vdmVDb3VudDogLTEsXG4gICAgICBvcHRzXG4gICAgfSwgZG9uZSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRSb3V0ZUlkKGlkLCBwYXJhbXMsIGRpcmVjdGlvbiwgYW5pbWF0aW9uKSB7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmVTeW5jKCk7XG4gICAgaWYgKG1hdGNoZXMoYWN0aXZlLCBpZCwgcGFyYW1zKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGNoYW5nZWQ6IGZhbHNlLFxuICAgICAgICBlbGVtZW50OiBhY3RpdmUuZWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCByZXNvbHZlO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyID0+IChyZXNvbHZlID0gcikpO1xuICAgIGxldCBmaW5pc2g7XG4gICAgY29uc3QgY29tbW9uT3B0cyA9IHtcbiAgICAgIHVwZGF0ZVVSTDogZmFsc2UsXG4gICAgICB2aWV3SXNSZWFkeTogZW50ZXJpbmdFbCA9PiB7XG4gICAgICAgIGxldCBtYXJrO1xuICAgICAgICBjb25zdCBwID0gbmV3IFByb21pc2UociA9PiAobWFyayA9IHIpKTtcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgY2hhbmdlZDogdHJ1ZSxcbiAgICAgICAgICBlbGVtZW50OiBlbnRlcmluZ0VsLFxuICAgICAgICAgIG1hcmtWaXNpYmxlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBtYXJrKCk7XG4gICAgICAgICAgICBhd2FpdCBmaW5pc2g7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAncm9vdCcpIHtcbiAgICAgIGZpbmlzaCA9IHRoaXMuc2V0Um9vdChpZCwgcGFyYW1zLCBjb21tb25PcHRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB2aWV3Q29udHJvbGxlciA9IHRoaXMudmlld3MuZmluZCh2ID0+IG1hdGNoZXModiwgaWQsIHBhcmFtcykpO1xuICAgICAgaWYgKHZpZXdDb250cm9sbGVyKSB7XG4gICAgICAgIGZpbmlzaCA9IHRoaXMucG9wVG8odmlld0NvbnRyb2xsZXIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uT3B0cyksIHsgZGlyZWN0aW9uOiAnYmFjaycsIGFuaW1hdGlvbkJ1aWxkZXI6IGFuaW1hdGlvbiB9KSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgICBmaW5pc2ggPSB0aGlzLnB1c2goaWQsIHBhcmFtcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb21tb25PcHRzKSwgeyBhbmltYXRpb25CdWlsZGVyOiBhbmltYXRpb24gfSkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYmFjaycpIHtcbiAgICAgICAgZmluaXNoID0gdGhpcy5zZXRSb290KGlkLCBwYXJhbXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uT3B0cyksIHsgZGlyZWN0aW9uOiAnYmFjaycsIGFuaW1hdGVkOiB0cnVlLCBhbmltYXRpb25CdWlsZGVyOiBhbmltYXRpb24gfSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIGdldFJvdXRlSWQoKSB7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmVTeW5jKCk7XG4gICAgcmV0dXJuIGFjdGl2ZVxuICAgICAgPyB7XG4gICAgICAgIGlkOiBhY3RpdmUuZWxlbWVudC50YWdOYW1lLFxuICAgICAgICBwYXJhbXM6IGFjdGl2ZS5wYXJhbXMsXG4gICAgICAgIGVsZW1lbnQ6IGFjdGl2ZS5lbGVtZW50XG4gICAgICB9XG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhY3RpdmUgdmlldy5cbiAgICovXG4gIGdldEFjdGl2ZSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZ2V0QWN0aXZlU3luYygpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHZpZXcuXG4gICAqL1xuICBnZXRCeUluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnZpZXdzW2luZGV4XSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBjdXJyZW50IHZpZXcgY2FuIGdvIGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB2aWV3IFRoZSB2aWV3IHRvIGNoZWNrLlxuICAgKi9cbiAgY2FuR29CYWNrKHZpZXcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY2FuR29CYWNrU3luYyh2aWV3KSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJldmlvdXMgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHZpZXcgVGhlIHZpZXcgdG8gZ2V0LlxuICAgKi9cbiAgZ2V0UHJldmlvdXModmlldykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5nZXRQcmV2aW91c1N5bmModmlldykpO1xuICB9XG4gIGdldExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3cy5sZW5ndGg7XG4gIH1cbiAgZ2V0QWN0aXZlU3luYygpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3c1t0aGlzLnZpZXdzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGNhbkdvQmFja1N5bmModmlldyA9IHRoaXMuZ2V0QWN0aXZlU3luYygpKSB7XG4gICAgcmV0dXJuICEhKHZpZXcgJiYgdGhpcy5nZXRQcmV2aW91c1N5bmModmlldykpO1xuICB9XG4gIGdldFByZXZpb3VzU3luYyh2aWV3ID0gdGhpcy5nZXRBY3RpdmVTeW5jKCkpIHtcbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHZpZXdzID0gdGhpcy52aWV3cztcbiAgICBjb25zdCBpbmRleCA9IHZpZXdzLmluZGV4T2Yodmlldyk7XG4gICAgcmV0dXJuIGluZGV4ID4gMCA/IHZpZXdzW2luZGV4IC0gMV0gOiB1bmRlZmluZWQ7XG4gIH1cbiAgLy8gX3F1ZXVlVHJucygpIGFkZHMgYSBuYXZpZ2F0aW9uIHN0YWNrIGNoYW5nZSB0byB0aGUgcXVldWUgYW5kIHNjaGVkdWxlcyBpdCB0byBydW46XG4gIC8vIDEuIF9uZXh0VHJucygpOiBjb25zdW1lcyB0aGUgbmV4dCB0cmFuc2l0aW9uIGluIHRoZSBxdWV1ZVxuICAvLyAyLiBfdmlld0luaXQoKTogaW5pdGlhbGl6ZXMgZW50ZXJpbmdWaWV3IGlmIHJlcXVpcmVkXG4gIC8vIDMuIF92aWV3VGVzdCgpOiBlbnN1cmVzIGNhbkxlYXZlL2NhbkVudGVyIFJldHVybnMgYHRydWVgLCBzbyB0aGUgb3BlcmF0aW9uIGNhbiBjb250aW51ZVxuICAvLyA0LiBfcG9zdFZpZXdJbml0KCk6IGFkZC9yZW1vdmUgdGhlIHZpZXdzIGZyb20gdGhlIG5hdmlnYXRpb24gc3RhY2tcbiAgLy8gNS4gX3RyYW5zaXRpb25Jbml0KCk6IGluaXRpYWxpemVzIHRoZSB2aXN1YWwgdHJhbnNpdGlvbiBpZiByZXF1aXJlZCBhbmQgc2NoZWR1bGVzIGl0IHRvIHJ1blxuICAvLyA2LiBfdmlld0F0dGFjaFRvRE9NKCk6IGF0dGFjaGVzIHRoZSBlbnRlcmluZ1ZpZXcgdG8gdGhlIERPTVxuICAvLyA3LiBfdHJhbnNpdGlvblN0YXJ0KCk6IGNhbGxlZCBvbmNlIHRoZSB0cmFuc2l0aW9uIGFjdHVhbGx5IHN0YXJ0cywgaXQgaW5pdGlhbGl6ZXMgdGhlIEFuaW1hdGlvbiB1bmRlcm5lYXRoLlxuICAvLyA4LiBfdHJhbnNpdGlvbkZpbmlzaCgpOiBjYWxsZWQgb25jZSB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlc1xuICAvLyA5LiBfY2xlYW51cCgpOiBzeW5jcyB0aGUgbmF2aWdhdGlvbiBpbnRlcm5hbCBzdGF0ZSB3aXRoIHRoZSBET00uIEZvciBleGFtcGxlIGl0IHJlbW92ZXMgdGhlIHBhZ2VzIGZyb20gdGhlIERPTSBvciBoaWRlcy9zaG93IHRoZW0uXG4gIGFzeW5jIHF1ZXVlVHJucyh0aSwgZG9uZSkge1xuICAgIGlmICh0aGlzLmlzVHJhbnNpdGlvbmluZyAmJiB0aS5vcHRzICE9IG51bGwgJiYgdGkub3B0cy5za2lwSWZCdXN5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRpLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGkucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHRpLmRvbmUgPSBkb25lO1xuICAgIC8qKlxuICAgICAqIElmIHVzaW5nIHJvdXRlciwgY2hlY2sgdG8gc2VlIGlmIG5hdmlnYXRpb24gaG9va3NcbiAgICAgKiB3aWxsIGFsbG93IHVzIHRvIHBlcmZvcm0gdGhpcyB0cmFuc2l0aW9uLiBUaGlzXG4gICAgICogaXMgcmVxdWlyZWQgaW4gb3JkZXIgZm9yIGhvb2tzIHRvIHdvcmsgd2l0aFxuICAgICAqIHRoZSBpb24tYmFjay1idXR0b24gb3Igc3dpcGUgdG8gZ28gYmFjay5cbiAgICAgKi9cbiAgICBpZiAodGkub3B0cyAmJiB0aS5vcHRzLnVwZGF0ZVVSTCAhPT0gZmFsc2UgJiYgdGhpcy51c2VSb3V0ZXIpIHtcbiAgICAgIGNvbnN0IHJvdXRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lvbi1yb3V0ZXInKTtcbiAgICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgICAgY29uc3QgY2FuVHJhbnNpdGlvbiA9IGF3YWl0IHJvdXRlci5jYW5UcmFuc2l0aW9uKCk7XG4gICAgICAgIGlmIChjYW5UcmFuc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjYW5UcmFuc2l0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJvdXRlci5wdXNoKGNhblRyYW5zaXRpb24sIHRpLm9wdHMuZGlyZWN0aW9uIHx8ICdiYWNrJyk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIGVtcHR5XG4gICAgaWYgKHRpLmluc2VydFZpZXdzICYmIHRpLmluc2VydFZpZXdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGkuaW5zZXJ0Vmlld3MgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEVucXVldWUgdHJhbnNpdGlvbiBpbnN0cnVjdGlvblxuICAgIHRoaXMudHJhbnNJbnN0ci5wdXNoKHRpKTtcbiAgICAvLyBpZiB0aGVyZSBpc24ndCBhIHRyYW5zaXRpb24gYWxyZWFkeSBoYXBwZW5pbmdcbiAgICAvLyB0aGVuIHRoaXMgd2lsbCBraWNrIG9mZiB0aGlzIHRyYW5zaXRpb25cbiAgICB0aGlzLm5leHRUcm5zKCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgc3VjY2VzcyhyZXN1bHQsIHRpKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICB0aGlzLmZpcmVFcnJvcignbmF2IGNvbnRyb2xsZXIgd2FzIGRlc3Ryb3llZCcsIHRpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRpLmRvbmUpIHtcbiAgICAgIHRpLmRvbmUocmVzdWx0Lmhhc0NvbXBsZXRlZCwgcmVzdWx0LnJlcXVpcmVzVHJhbnNpdGlvbiwgcmVzdWx0LmVudGVyaW5nVmlldywgcmVzdWx0LmxlYXZpbmdWaWV3LCByZXN1bHQuZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgdGkucmVzb2x2ZShyZXN1bHQuaGFzQ29tcGxldGVkKTtcbiAgICBpZiAodGkub3B0cy51cGRhdGVVUkwgIT09IGZhbHNlICYmIHRoaXMudXNlUm91dGVyKSB7XG4gICAgICBjb25zdCByb3V0ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpb24tcm91dGVyJyk7XG4gICAgICBpZiAocm91dGVyKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHJlc3VsdC5kaXJlY3Rpb24gPT09ICdiYWNrJyA/ICdiYWNrJyA6ICdmb3J3YXJkJztcbiAgICAgICAgcm91dGVyLm5hdkNoYW5nZWQoZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmFpbGVkKHJlamVjdFJlYXNvbiwgdGkpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuZmlyZUVycm9yKCduYXYgY29udHJvbGxlciB3YXMgZGVzdHJveWVkJywgdGkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zSW5zdHIubGVuZ3RoID0gMDtcbiAgICB0aGlzLmZpcmVFcnJvcihyZWplY3RSZWFzb24sIHRpKTtcbiAgfVxuICBmaXJlRXJyb3IocmVqZWN0UmVhc29uLCB0aSkge1xuICAgIGlmICh0aS5kb25lKSB7XG4gICAgICB0aS5kb25lKGZhbHNlLCBmYWxzZSwgcmVqZWN0UmVhc29uKTtcbiAgICB9XG4gICAgaWYgKHRpLnJlamVjdCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHRpLnJlamVjdChyZWplY3RSZWFzb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRpLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgfVxuICBuZXh0VHJucygpIHtcbiAgICAvLyB0aGlzIGlzIHRoZSBmcmFtZXdvcmsncyBicmVhZCAnbiBidXR0YSBmdW5jdGlvblxuICAgIC8vIG9ubHkgb25lIHRyYW5zaXRpb24gaXMgYWxsb3dlZCBhdCBhbnkgZ2l2ZW4gdGltZVxuICAgIGlmICh0aGlzLmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyB0aGVyZSBpcyBubyB0cmFuc2l0aW9uIGhhcHBlbmluZyByaWdodCBub3dcbiAgICAvLyBnZXQgdGhlIG5leHQgaW5zdHJ1Y3Rpb25cbiAgICBjb25zdCB0aSA9IHRoaXMudHJhbnNJbnN0ci5zaGlmdCgpO1xuICAgIGlmICghdGkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5ydW5UcmFuc2l0aW9uKHRpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhc3luYyBydW5UcmFuc2l0aW9uKHRpKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIHNldCB0aGF0IHRoaXMgbmF2IGlzIGFjdGl2ZWx5IHRyYW5zaXRpb25pbmdcbiAgICAgIHRoaXMuaW9uTmF2V2lsbENoYW5nZS5lbWl0KCk7XG4gICAgICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICB0aGlzLnByZXBhcmVUSSh0aSk7XG4gICAgICBjb25zdCBsZWF2aW5nVmlldyA9IHRoaXMuZ2V0QWN0aXZlU3luYygpO1xuICAgICAgY29uc3QgZW50ZXJpbmdWaWV3ID0gdGhpcy5nZXRFbnRlcmluZ1ZpZXcodGksIGxlYXZpbmdWaWV3KTtcbiAgICAgIGlmICghbGVhdmluZ1ZpZXcgJiYgIWVudGVyaW5nVmlldykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHZpZXdzIGluIHRoZSBzdGFjayB0byBiZSByZW1vdmVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoZW50ZXJpbmdWaWV3ICYmIGVudGVyaW5nVmlldy5zdGF0ZSA9PT0gVklFV19TVEFURV9ORVcpIHtcbiAgICAgICAgYXdhaXQgZW50ZXJpbmdWaWV3LmluaXQodGhpcy5lbCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvc3RWaWV3SW5pdChlbnRlcmluZ1ZpZXcsIGxlYXZpbmdWaWV3LCB0aSk7XG4gICAgICAvLyBOZWVkcyB0cmFuc2l0aW9uP1xuICAgICAgY29uc3QgcmVxdWlyZXNUcmFuc2l0aW9uID0gKHRpLmVudGVyaW5nUmVxdWlyZXNUcmFuc2l0aW9uIHx8IHRpLmxlYXZpbmdSZXF1aXJlc1RyYW5zaXRpb24pICYmXG4gICAgICAgIGVudGVyaW5nVmlldyAhPT0gbGVhdmluZ1ZpZXc7XG4gICAgICBpZiAocmVxdWlyZXNUcmFuc2l0aW9uICYmIHRpLm9wdHMgJiYgbGVhdmluZ1ZpZXcpIHtcbiAgICAgICAgY29uc3QgaXNCYWNrRGlyZWN0aW9uID0gdGkub3B0cy5kaXJlY3Rpb24gPT09ICdiYWNrJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGhlYWRpbmcgYmFjaywgdXNlIHRoZSBlbnRlcmluZyBwYWdlJ3MgYW5pbWF0aW9uXG4gICAgICAgICAqIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkIGJ5IHRoZSBkZXZlbG9wZXIuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNCYWNrRGlyZWN0aW9uKSB7XG4gICAgICAgICAgdGkub3B0cy5hbmltYXRpb25CdWlsZGVyID0gdGkub3B0cy5hbmltYXRpb25CdWlsZGVyIHx8IChlbnRlcmluZ1ZpZXcgJiYgZW50ZXJpbmdWaWV3LmFuaW1hdGlvbkJ1aWxkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxlYXZpbmdWaWV3LmFuaW1hdGlvbkJ1aWxkZXIgPSB0aS5vcHRzLmFuaW1hdGlvbkJ1aWxkZXI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSByZXF1aXJlc1RyYW5zaXRpb25cbiAgICAgICAgPyBhd2FpdCB0aGlzLnRyYW5zaXRpb24oZW50ZXJpbmdWaWV3LCBsZWF2aW5nVmlldywgdGkpXG4gICAgICAgIDoge1xuICAgICAgICAgIC8vIHRyYW5zaXRpb24gaXMgbm90IHJlcXVpcmVkLCBzbyB3ZSBhcmUgYWxyZWFkeSBkb25lIVxuICAgICAgICAgIC8vIHRoZXkncmUgaW5zZXJ0aW5nL3JlbW92aW5nIHRoZSB2aWV3cyBzb21ld2hlcmUgaW4gdGhlIG1pZGRsZSBvclxuICAgICAgICAgIC8vIGJlZ2lubmluZywgc28gdmlzdWFsbHkgbm90aGluZyBuZWVkcyB0byBhbmltYXRlL3RyYW5zaXRpb25cbiAgICAgICAgICAvLyByZXNvbHZlIGltbWVkaWF0ZWx5IGJlY2F1c2UgdGhlcmUncyBubyBhbmltYXRpb24gdGhhdCdzIGhhcHBlbmluZ1xuICAgICAgICAgIGhhc0NvbXBsZXRlZDogdHJ1ZSxcbiAgICAgICAgICByZXF1aXJlc1RyYW5zaXRpb246IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB0aGlzLnN1Y2Nlc3MocmVzdWx0LCB0aSk7XG4gICAgICB0aGlzLmlvbk5hdkRpZENoYW5nZS5lbWl0KCk7XG4gICAgfVxuICAgIGNhdGNoIChyZWplY3RSZWFzb24pIHtcbiAgICAgIHRoaXMuZmFpbGVkKHJlamVjdFJlYXNvbiwgdGkpO1xuICAgIH1cbiAgICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIHRoaXMubmV4dFRybnMoKTtcbiAgfVxuICBwcmVwYXJlVEkodGkpIHtcbiAgICBjb25zdCB2aWV3c0xlbmd0aCA9IHRoaXMudmlld3MubGVuZ3RoO1xuICAgIHRpLm9wdHMgPSB0aS5vcHRzIHx8IHt9O1xuICAgIGlmICh0aS5vcHRzLmRlbGVnYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpLm9wdHMuZGVsZWdhdGUgPSB0aGlzLmRlbGVnYXRlO1xuICAgIH1cbiAgICBpZiAodGkucmVtb3ZlVmlldyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhc3NlcnQodGkucmVtb3ZlU3RhcnQgIT09IHVuZGVmaW5lZCwgJ3JlbW92ZVZpZXcgbmVlZHMgcmVtb3ZlU3RhcnQnKTtcbiAgICAgIGFzc2VydCh0aS5yZW1vdmVDb3VudCAhPT0gdW5kZWZpbmVkLCAncmVtb3ZlVmlldyBuZWVkcyByZW1vdmVDb3VudCcpO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnZpZXdzLmluZGV4T2YodGkucmVtb3ZlVmlldyk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlVmlldyB3YXMgbm90IGZvdW5kJyk7XG4gICAgICB9XG4gICAgICB0aS5yZW1vdmVTdGFydCArPSBpbmRleDtcbiAgICB9XG4gICAgaWYgKHRpLnJlbW92ZVN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aS5yZW1vdmVTdGFydCA8IDApIHtcbiAgICAgICAgdGkucmVtb3ZlU3RhcnQgPSB2aWV3c0xlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBpZiAodGkucmVtb3ZlQ291bnQgPCAwKSB7XG4gICAgICAgIHRpLnJlbW92ZUNvdW50ID0gdmlld3NMZW5ndGggLSB0aS5yZW1vdmVTdGFydDtcbiAgICAgIH1cbiAgICAgIHRpLmxlYXZpbmdSZXF1aXJlc1RyYW5zaXRpb24gPVxuICAgICAgICB0aS5yZW1vdmVDb3VudCA+IDAgJiYgdGkucmVtb3ZlU3RhcnQgKyB0aS5yZW1vdmVDb3VudCA9PT0gdmlld3NMZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aS5pbnNlcnRWaWV3cykge1xuICAgICAgLy8gYWxsb3cgLTEgdG8gYmUgcGFzc2VkIGluIHRvIGF1dG8gcHVzaCBpdCBvbiB0aGUgZW5kXG4gICAgICAvLyBhbmQgY2xlYW4gdXAgdGhlIGluZGV4IGlmIGl0J3MgbGFyZ2VyIHRoZW4gdGhlIHNpemUgb2YgdGhlIHN0YWNrXG4gICAgICBpZiAodGkuaW5zZXJ0U3RhcnQgPCAwIHx8IHRpLmluc2VydFN0YXJ0ID4gdmlld3NMZW5ndGgpIHtcbiAgICAgICAgdGkuaW5zZXJ0U3RhcnQgPSB2aWV3c0xlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRpLmVudGVyaW5nUmVxdWlyZXNUcmFuc2l0aW9uID0gdGkuaW5zZXJ0U3RhcnQgPT09IHZpZXdzTGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBpbnNlcnRWaWV3cyA9IHRpLmluc2VydFZpZXdzO1xuICAgIGlmICghaW5zZXJ0Vmlld3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXNzZXJ0KGluc2VydFZpZXdzLmxlbmd0aCA+IDAsICdsZW5ndGggY2FuIG5vdCBiZSB6ZXJvJyk7XG4gICAgY29uc3Qgdmlld0NvbnRyb2xsZXJzID0gY29udmVydFRvVmlld3MoaW5zZXJ0Vmlld3MpO1xuICAgIGlmICh2aWV3Q29udHJvbGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmlld3MgdG8gaW5zZXJ0Jyk7XG4gICAgfVxuICAgIC8vIENoZWNrIGFsbCB0aGUgaW5zZXJ0ZWQgdmlldyBhcmUgY29ycmVjdFxuICAgIGZvciAoY29uc3QgdmlldyBvZiB2aWV3Q29udHJvbGxlcnMpIHtcbiAgICAgIHZpZXcuZGVsZWdhdGUgPSB0aS5vcHRzLmRlbGVnYXRlO1xuICAgICAgY29uc3QgbmF2ID0gdmlldy5uYXY7XG4gICAgICBpZiAobmF2ICYmIG5hdiAhPT0gdGhpcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc2VydGVkIHZpZXcgd2FzIGFscmVhZHkgaW5zZXJ0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2aWV3LnN0YXRlID09PSBWSUVXX1NUQVRFX0RFU1RST1lFRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc2VydGVkIHZpZXcgd2FzIGFscmVhZHkgZGVzdHJveWVkJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRpLmluc2VydFZpZXdzID0gdmlld0NvbnRyb2xsZXJzO1xuICB9XG4gIGdldEVudGVyaW5nVmlldyh0aSwgbGVhdmluZ1ZpZXcpIHtcbiAgICBjb25zdCBpbnNlcnRWaWV3cyA9IHRpLmluc2VydFZpZXdzO1xuICAgIGlmIChpbnNlcnRWaWV3cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBncmFiIHRoZSB2ZXJ5IGxhc3QgdmlldyBvZiB0aGUgdmlld3MgdG8gYmUgaW5zZXJ0ZWRcbiAgICAgIC8vIGFuZCBpbml0aWFsaXplIGl0IGFzIHRoZSBuZXcgZW50ZXJpbmcgdmlld1xuICAgICAgcmV0dXJuIGluc2VydFZpZXdzW2luc2VydFZpZXdzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb25zdCByZW1vdmVTdGFydCA9IHRpLnJlbW92ZVN0YXJ0O1xuICAgIGlmIChyZW1vdmVTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB2aWV3cyA9IHRoaXMudmlld3M7XG4gICAgICBjb25zdCByZW1vdmVFbmQgPSByZW1vdmVTdGFydCArIHRpLnJlbW92ZUNvdW50O1xuICAgICAgZm9yIChsZXQgaSA9IHZpZXdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB2aWV3c1tpXTtcbiAgICAgICAgaWYgKChpIDwgcmVtb3ZlU3RhcnQgfHwgaSA+PSByZW1vdmVFbmQpICYmIHZpZXcgIT09IGxlYXZpbmdWaWV3KSB7XG4gICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBwb3N0Vmlld0luaXQoZW50ZXJpbmdWaWV3LCBsZWF2aW5nVmlldywgdGkpIHtcbiAgICBhc3NlcnQobGVhdmluZ1ZpZXcgfHwgZW50ZXJpbmdWaWV3LCAnQm90aCBsZWF2aW5nVmlldyBhbmQgZW50ZXJpbmdWaWV3IGFyZSBudWxsJyk7XG4gICAgYXNzZXJ0KHRpLnJlc29sdmUsICdyZXNvbHZlIG11c3QgYmUgdmFsaWQnKTtcbiAgICBhc3NlcnQodGkucmVqZWN0LCAncmVqZWN0IG11c3QgYmUgdmFsaWQnKTtcbiAgICBjb25zdCBvcHRzID0gdGkub3B0cztcbiAgICBjb25zdCBpbnNlcnRWaWV3cyA9IHRpLmluc2VydFZpZXdzO1xuICAgIGNvbnN0IHJlbW92ZVN0YXJ0ID0gdGkucmVtb3ZlU3RhcnQ7XG4gICAgY29uc3QgcmVtb3ZlQ291bnQgPSB0aS5yZW1vdmVDb3VudDtcbiAgICBsZXQgZGVzdHJveVF1ZXVlO1xuICAgIC8vIHRoZXJlIGFyZSB2aWV3cyB0byByZW1vdmVcbiAgICBpZiAocmVtb3ZlU3RhcnQgIT09IHVuZGVmaW5lZCAmJiByZW1vdmVDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhc3NlcnQocmVtb3ZlU3RhcnQgPj0gMCwgJ3JlbW92ZVN0YXJ0IGNhbiBub3QgYmUgbmVnYXRpdmUnKTtcbiAgICAgIGFzc2VydChyZW1vdmVDb3VudCA+PSAwLCAncmVtb3ZlQ291bnQgY2FuIG5vdCBiZSBuZWdhdGl2ZScpO1xuICAgICAgZGVzdHJveVF1ZXVlID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZUNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMudmlld3NbaSArIHJlbW92ZVN0YXJ0XTtcbiAgICAgICAgaWYgKHZpZXcgJiYgdmlldyAhPT0gZW50ZXJpbmdWaWV3ICYmIHZpZXcgIT09IGxlYXZpbmdWaWV3KSB7XG4gICAgICAgICAgZGVzdHJveVF1ZXVlLnB1c2godmlldyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGRlZmF1bHQgdGhlIGRpcmVjdGlvbiB0byBcImJhY2tcIlxuICAgICAgb3B0cy5kaXJlY3Rpb24gPSBvcHRzLmRpcmVjdGlvbiB8fCAnYmFjayc7XG4gICAgfVxuICAgIGNvbnN0IGZpbmFsQmFsYW5jZSA9IHRoaXMudmlld3MubGVuZ3RoICtcbiAgICAgIChpbnNlcnRWaWV3cyAhPT0gdW5kZWZpbmVkID8gaW5zZXJ0Vmlld3MubGVuZ3RoIDogMCkgLVxuICAgICAgKHJlbW92ZUNvdW50ICE9PSB1bmRlZmluZWQgPyByZW1vdmVDb3VudCA6IDApO1xuICAgIGFzc2VydChmaW5hbEJhbGFuY2UgPj0gMCwgJ2ZpbmFsIGJhbGFuY2UgY2FuIG5vdCBiZSBuZWdhdGl2ZScpO1xuICAgIGlmIChmaW5hbEJhbGFuY2UgPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihgWW91IGNhbid0IHJlbW92ZSBhbGwgdGhlIHBhZ2VzIGluIHRoZSBuYXZpZ2F0aW9uIHN0YWNrLiBuYXYucG9wKCkgaXMgcHJvYmFibHkgY2FsbGVkIHRvbyBtYW55IHRpbWVzLmAsIHRoaXMsIHRoaXMuZWwpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCduYXZpZ2F0aW9uIHN0YWNrIG5lZWRzIGF0IGxlYXN0IG9uZSByb290IHBhZ2UnKTtcbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgdHJhbnNpdGlvbiBjYW4gbm90IGJlIHJlamVjdGVkLCBhbnkgdGhyb3cgc2hvdWxkIGJlIGFuIGVycm9yXG4gICAgLy8gdGhlcmUgYXJlIHZpZXdzIHRvIGluc2VydFxuICAgIGlmIChpbnNlcnRWaWV3cykge1xuICAgICAgLy8gYWRkIHRoZSB2aWV3cyB0byB0aGVcbiAgICAgIGxldCBpbnNlcnRJbmRleCA9IHRpLmluc2VydFN0YXJ0O1xuICAgICAgZm9yIChjb25zdCB2aWV3IG9mIGluc2VydFZpZXdzKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0Vmlld0F0KHZpZXcsIGluc2VydEluZGV4KTtcbiAgICAgICAgaW5zZXJ0SW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmICh0aS5lbnRlcmluZ1JlcXVpcmVzVHJhbnNpdGlvbikge1xuICAgICAgICAvLyBkZWZhdWx0IHRvIGZvcndhcmQgaWYgbm90IGFscmVhZHkgc2V0XG4gICAgICAgIG9wdHMuZGlyZWN0aW9uID0gb3B0cy5kaXJlY3Rpb24gfHwgJ2ZvcndhcmQnO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB0aGUgdmlld3MgdG8gYmUgcmVtb3ZlZCBhcmUgaW4gdGhlIGJlZ2lubmluZyBvciBtaWRkbGVcbiAgICAvLyBhbmQgdGhlcmUgaXMgbm90IGEgdmlldyB0aGF0IG5lZWRzIHRvIHZpc3VhbGx5IHRyYW5zaXRpb24gb3V0XG4gICAgLy8gdGhlbiBqdXN0IGRlc3Ryb3kgdGhlbSBhbmQgZG9uJ3QgdHJhbnNpdGlvbiBhbnl0aGluZ1xuICAgIC8vIGJhdGNoIGFsbCBvZiBsaWZlY3ljbGVzIHRvZ2V0aGVyXG4gICAgLy8gbGV0J3MgbWFrZSBzdXJlLCBjYWxsYmFja3MgYXJlIHpvbmVkXG4gICAgaWYgKGRlc3Ryb3lRdWV1ZSAmJiBkZXN0cm95UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCB2aWV3IG9mIGRlc3Ryb3lRdWV1ZSkge1xuICAgICAgICBsaWZlY3ljbGUodmlldy5lbGVtZW50LCBMSUZFQ1lDTEVfV0lMTF9MRUFWRSk7XG4gICAgICAgIGxpZmVjeWNsZSh2aWV3LmVsZW1lbnQsIExJRkVDWUNMRV9ESURfTEVBVkUpO1xuICAgICAgICBsaWZlY3ljbGUodmlldy5lbGVtZW50LCBMSUZFQ1lDTEVfV0lMTF9VTkxPQUQpO1xuICAgICAgfVxuICAgICAgLy8gb25jZSBhbGwgbGlmZWN5Y2xlIGV2ZW50cyBoYXMgYmVlbiBkZWxpdmVyZWQsIHdlIGNhbiBzYWZlbHkgZGV0cm95IHRoZSB2aWV3c1xuICAgICAgZm9yIChjb25zdCB2aWV3IG9mIGRlc3Ryb3lRdWV1ZSkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lWaWV3KHZpZXcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyB0cmFuc2l0aW9uKGVudGVyaW5nVmlldywgbGVhdmluZ1ZpZXcsIHRpKSB7XG4gICAgLy8gd2Ugc2hvdWxkIGFuaW1hdGUgKGR1cmF0aW9uID4gMCkgaWYgdGhlIHB1c2hlZCBwYWdlIGlzIG5vdCB0aGUgZmlyc3Qgb25lIChzdGFydHVwKVxuICAgIC8vIG9yIGlmIGl0IGlzIGEgcG9ydGFsIChtb2RhbCwgYWN0aW9uc2hlZXQsIGV0Yy4pXG4gICAgY29uc3Qgb3B0cyA9IHRpLm9wdHM7XG4gICAgY29uc3QgcHJvZ3Jlc3NDYWxsYmFjayA9IG9wdHMucHJvZ3Jlc3NBbmltYXRpb25cbiAgICAgID8gKGFuaSkgPT4gdGhpcy5zYkFuaSA9IGFuaVxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgY29uc3QgZW50ZXJpbmdFbCA9IGVudGVyaW5nVmlldy5lbGVtZW50O1xuICAgIGNvbnN0IGxlYXZpbmdFbCA9IGxlYXZpbmdWaWV3ICYmIGxlYXZpbmdWaWV3LmVsZW1lbnQ7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1vZGUsIHNob3dHb0JhY2s6IHRoaXMuY2FuR29CYWNrU3luYyhlbnRlcmluZ1ZpZXcpLCBiYXNlRWw6IHRoaXMuZWwsIHByb2dyZXNzQ2FsbGJhY2ssIGFuaW1hdGVkOiB0aGlzLmFuaW1hdGVkICYmIGNvbmZpZy5nZXRCb29sZWFuKCdhbmltYXRlZCcsIHRydWUpLCBlbnRlcmluZ0VsLFxuICAgICAgbGVhdmluZ0VsIH0sIG9wdHMpLCB7IGFuaW1hdGlvbkJ1aWxkZXI6IG9wdHMuYW5pbWF0aW9uQnVpbGRlciB8fCB0aGlzLmFuaW1hdGlvbiB8fCBjb25maWcuZ2V0KCduYXZBbmltYXRpb24nKSB9KTtcbiAgICBjb25zdCB7IGhhc0NvbXBsZXRlZCB9ID0gYXdhaXQgdHJhbnNpdGlvbihhbmltYXRpb25PcHRzKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uRmluaXNoKGhhc0NvbXBsZXRlZCwgZW50ZXJpbmdWaWV3LCBsZWF2aW5nVmlldywgb3B0cyk7XG4gIH1cbiAgdHJhbnNpdGlvbkZpbmlzaChoYXNDb21wbGV0ZWQsIGVudGVyaW5nVmlldywgbGVhdmluZ1ZpZXcsIG9wdHMpIHtcbiAgICBjb25zdCBjbGVhbnVwVmlldyA9IGhhc0NvbXBsZXRlZCA/IGVudGVyaW5nVmlldyA6IGxlYXZpbmdWaWV3O1xuICAgIGlmIChjbGVhbnVwVmlldykge1xuICAgICAgdGhpcy5jbGVhbnVwKGNsZWFudXBWaWV3KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0NvbXBsZXRlZCxcbiAgICAgIHJlcXVpcmVzVHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgIGVudGVyaW5nVmlldyxcbiAgICAgIGxlYXZpbmdWaWV3LFxuICAgICAgZGlyZWN0aW9uOiBvcHRzLmRpcmVjdGlvblxuICAgIH07XG4gIH1cbiAgaW5zZXJ0Vmlld0F0KHZpZXcsIGluZGV4KSB7XG4gICAgY29uc3Qgdmlld3MgPSB0aGlzLnZpZXdzO1xuICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSB2aWV3cy5pbmRleE9mKHZpZXcpO1xuICAgIGlmIChleGlzdGluZ0luZGV4ID4gLTEpIHtcbiAgICAgIC8vIHRoaXMgdmlldyBpcyBhbHJlYWR5IGluIHRoZSBzdGFjayEhXG4gICAgICAvLyBtb3ZlIGl0IHRvIGl0cyBuZXcgbG9jYXRpb25cbiAgICAgIGFzc2VydCh2aWV3Lm5hdiA9PT0gdGhpcywgJ3ZpZXcgaXMgbm90IHBhcnQgb2YgdGhlIG5hdicpO1xuICAgICAgdmlld3Muc3BsaWNlKGluZGV4LCAwLCB2aWV3cy5zcGxpY2UoZXhpc3RpbmdJbmRleCwgMSlbMF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFzc2VydCghdmlldy5uYXYsICduYXYgaXMgdXNlZCcpO1xuICAgICAgLy8gdGhpcyBpcyBhIG5ldyB2aWV3IHRvIGFkZCB0byB0aGUgc3RhY2tcbiAgICAgIC8vIGNyZWF0ZSB0aGUgbmV3IGVudGVyaW5nIHZpZXdcbiAgICAgIHZpZXcubmF2ID0gdGhpcztcbiAgICAgIC8vIGluc2VydCB0aGUgZW50ZXJpbmcgdmlldyBpbnRvIHRoZSBjb3JyZWN0IGluZGV4IGluIHRoZSBzdGFja1xuICAgICAgdmlld3Muc3BsaWNlKGluZGV4LCAwLCB2aWV3KTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlVmlldyh2aWV3KSB7XG4gICAgYXNzZXJ0KHZpZXcuc3RhdGUgPT09IFZJRVdfU1RBVEVfQVRUQUNIRUQgfHwgdmlldy5zdGF0ZSA9PT0gVklFV19TVEFURV9ERVNUUk9ZRUQsICd2aWV3IHN0YXRlIHNob3VsZCBiZSBsb2FkZWQgb3IgZGVzdHJveWVkJyk7XG4gICAgY29uc3Qgdmlld3MgPSB0aGlzLnZpZXdzO1xuICAgIGNvbnN0IGluZGV4ID0gdmlld3MuaW5kZXhPZih2aWV3KTtcbiAgICBhc3NlcnQoaW5kZXggPiAtMSwgJ3ZpZXcgbXVzdCBiZSBwYXJ0IG9mIHRoZSBzdGFjaycpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2aWV3cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95Vmlldyh2aWV3KSB7XG4gICAgdmlldy5fZGVzdHJveSgpO1xuICAgIHRoaXMucmVtb3ZlVmlldyh2aWV3KTtcbiAgfVxuICAvKipcbiAgICogRE9NIFdSSVRFXG4gICAqL1xuICBjbGVhbnVwKGFjdGl2ZVZpZXcpIHtcbiAgICAvLyBvaywgY2xlYW51cCB0aW1lISEgRGVzdHJveSBhbGwgb2YgdGhlIHZpZXdzIHRoYXQgYXJlXG4gICAgLy8gSU5BQ1RJVkUgYW5kIGNvbWUgYWZ0ZXIgdGhlIGFjdGl2ZSB2aWV3XG4gICAgLy8gb25seSBkbyB0aGlzIGlmIHRoZSB2aWV3cyBleGlzdCwgdGhvdWdoXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZXdzID0gdGhpcy52aWV3cztcbiAgICBjb25zdCBhY3RpdmVWaWV3SW5kZXggPSB2aWV3cy5pbmRleE9mKGFjdGl2ZVZpZXcpO1xuICAgIGZvciAobGV0IGkgPSB2aWV3cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgdmlldyA9IHZpZXdzW2ldO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIGluc2VydGluZyBtdWx0aXBsZSB2aWV3cyB2aWEgaW5zZXJ0UGFnZXNcbiAgICAgICAqIHRoZSBsYXN0IHBhZ2Ugd2lsbCBiZSB0cmFuc2l0aW9uZWQgdG8sIGJ1dCB0aGVcbiAgICAgICAqIG90aGVycyB3aWxsIG5vdCBiZS4gQXMgYSByZXN1bHQsIGEgRE9NIGVsZW1lbnRcbiAgICAgICAqIHdpbGwgb25seSBiZSBjcmVhdGVkIGZvciB0aGUgbGFzdCBwYWdlIGluc2VydGVkLlxuICAgICAgICogQXMgYSByZXN1bHQsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgdmlld3MgaW4gdGhlXG4gICAgICAgKiBzdGFjayB0aGF0IGRvIG5vdCBoYXZlIGB2aWV3LmVsZW1lbnRgIHlldC5cbiAgICAgICAqL1xuICAgICAgY29uc3QgZWxlbWVudCA9IHZpZXcuZWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChpID4gYWN0aXZlVmlld0luZGV4KSB7XG4gICAgICAgICAgLy8gdGhpcyB2aWV3IGNvbWVzIGFmdGVyIHRoZSBhY3RpdmUgdmlld1xuICAgICAgICAgIC8vIGxldCdzIHVubG9hZCBpdFxuICAgICAgICAgIGxpZmVjeWNsZShlbGVtZW50LCBMSUZFQ1lDTEVfV0lMTF9VTkxPQUQpO1xuICAgICAgICAgIHRoaXMuZGVzdHJveVZpZXcodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA8IGFjdGl2ZVZpZXdJbmRleCkge1xuICAgICAgICAgIC8vIHRoaXMgdmlldyBjb21lcyBiZWZvcmUgdGhlIGFjdGl2ZSB2aWV3XG4gICAgICAgICAgLy8gYW5kIGl0IGlzIG5vdCBhIHBvcnRhbCB0aGVuIGVuc3VyZSBpdCBpcyBoaWRkZW5cbiAgICAgICAgICBzZXRQYWdlSGlkZGVuKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhblN0YXJ0KCkge1xuICAgIHJldHVybiAoISF0aGlzLnN3aXBlR2VzdHVyZSAmJlxuICAgICAgIXRoaXMuaXNUcmFuc2l0aW9uaW5nICYmXG4gICAgICB0aGlzLnRyYW5zSW5zdHIubGVuZ3RoID09PSAwICYmXG4gICAgICB0aGlzLmFuaW1hdGlvbkVuYWJsZWQgJiZcbiAgICAgIHRoaXMuY2FuR29CYWNrU3luYygpKTtcbiAgfVxuICBvblN0YXJ0KCkge1xuICAgIHRoaXMucXVldWVUcm5zKHtcbiAgICAgIHJlbW92ZVN0YXJ0OiAtMSxcbiAgICAgIHJlbW92ZUNvdW50OiAxLFxuICAgICAgb3B0czoge1xuICAgICAgICBkaXJlY3Rpb246ICdiYWNrJyxcbiAgICAgICAgcHJvZ3Jlc3NBbmltYXRpb246IHRydWVcbiAgICAgIH1cbiAgICB9LCB1bmRlZmluZWQpO1xuICB9XG4gIG9uTW92ZShzdGVwVmFsdWUpIHtcbiAgICBpZiAodGhpcy5zYkFuaSkge1xuICAgICAgdGhpcy5zYkFuaS5wcm9ncmVzc1N0ZXAoc3RlcFZhbHVlKTtcbiAgICB9XG4gIH1cbiAgb25FbmQoc2hvdWxkQ29tcGxldGUsIHN0ZXBWYWx1ZSwgZHVyKSB7XG4gICAgaWYgKHRoaXMuc2JBbmkpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zYkFuaS5vbkZpbmlzaCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRW5hYmxlZCA9IHRydWU7XG4gICAgICB9LCB7IG9uZVRpbWVDYWxsYmFjazogdHJ1ZSB9KTtcbiAgICAgIC8vIEFjY291bnQgZm9yIHJvdW5kaW5nIGVycm9ycyBpbiBKU1xuICAgICAgbGV0IG5ld1N0ZXBWYWx1ZSA9IChzaG91bGRDb21wbGV0ZSkgPyAtMC4wMDEgOiAwLjAwMTtcbiAgICAgIC8qKlxuICAgICAgICogQW5pbWF0aW9uIHdpbGwgYmUgcmV2ZXJzZWQgaGVyZSwgc28gbmVlZCB0b1xuICAgICAgICogcmV2ZXJzZSB0aGUgZWFzaW5nIGN1cnZlIGFzIHdlbGxcbiAgICAgICAqXG4gICAgICAgKiBBZGRpdGlvbmFsbHksIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHRpbWUgcmVsYXRpdmVcbiAgICAgICAqIHRvIHRoZSBuZXcgZWFzaW5nIGN1cnZlLCBhcyBgc3RlcFZhbHVlYCBpcyBnb2luZyB0byBiZSBnaXZlblxuICAgICAgICogaW4gdGVybXMgb2YgYSBsaW5lYXIgY3VydmUuXG4gICAgICAgKi9cbiAgICAgIGlmICghc2hvdWxkQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5zYkFuaS5lYXNpbmcoJ2N1YmljLWJlemllcigxLCAwLCAwLjY4LCAwLjI4KScpO1xuICAgICAgICBuZXdTdGVwVmFsdWUgKz0gZ2V0VGltZUdpdmVuUHJvZ3Jlc3Npb24oWzAsIDBdLCBbMSwgMF0sIFswLjY4LCAwLjI4XSwgWzEsIDFdLCBzdGVwVmFsdWUpWzBdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1N0ZXBWYWx1ZSArPSBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbihbMCwgMF0sIFswLjMyLCAwLjcyXSwgWzAsIDFdLCBbMSwgMV0sIHN0ZXBWYWx1ZSlbMF07XG4gICAgICB9XG4gICAgICB0aGlzLnNiQW5pLnByb2dyZXNzRW5kKHNob3VsZENvbXBsZXRlID8gMSA6IDAsIG5ld1N0ZXBWYWx1ZSwgZHVyKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoaChcInNsb3RcIiwgbnVsbCkpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcInN3aXBlR2VzdHVyZVwiOiBbXCJzd2lwZUdlc3R1cmVDaGFuZ2VkXCJdLFxuICAgIFwicm9vdFwiOiBbXCJyb290Q2hhbmdlZFwiXVxuICB9OyB9XG59O1xuTmF2LnN0eWxlID0gbmF2Q3NzO1xuXG5jb25zdCBuYXZMaW5rID0gKGVsLCByb3V0ZXJEaXJlY3Rpb24sIGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMsIHJvdXRlckFuaW1hdGlvbikgPT4ge1xuICBjb25zdCBuYXYgPSBlbC5jbG9zZXN0KCdpb24tbmF2Jyk7XG4gIGlmIChuYXYpIHtcbiAgICBpZiAocm91dGVyRGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcbiAgICAgIGlmIChjb21wb25lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmF2LnB1c2goY29tcG9uZW50LCBjb21wb25lbnRQcm9wcywgeyBza2lwSWZCdXN5OiB0cnVlLCBhbmltYXRpb25CdWlsZGVyOiByb3V0ZXJBbmltYXRpb24gfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJvdXRlckRpcmVjdGlvbiA9PT0gJ3Jvb3QnKSB7XG4gICAgICBpZiAoY29tcG9uZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5hdi5zZXRSb290KGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMsIHsgc2tpcElmQnVzeTogdHJ1ZSwgYW5pbWF0aW9uQnVpbGRlcjogcm91dGVyQW5pbWF0aW9uIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyb3V0ZXJEaXJlY3Rpb24gPT09ICdiYWNrJykge1xuICAgICAgcmV0dXJuIG5hdi5wb3AoeyBza2lwSWZCdXN5OiB0cnVlLCBhbmltYXRpb25CdWlsZGVyOiByb3V0ZXJBbmltYXRpb24gfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xufTtcblxubGV0IE5hdkxpbmsgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2l0aW9uIGRpcmVjdGlvbiB3aGVuIG5hdmlnYXRpbmcgdG8gYW5vdGhlciBwYWdlLlxuICAgICAqL1xuICAgIHRoaXMucm91dGVyRGlyZWN0aW9uID0gJ2ZvcndhcmQnO1xuICAgIHRoaXMub25DbGljayA9ICgpID0+IHtcbiAgICAgIHJldHVybiBuYXZMaW5rKHRoaXMuZWwsIHRoaXMucm91dGVyRGlyZWN0aW9uLCB0aGlzLmNvbXBvbmVudCwgdGhpcy5jb21wb25lbnRQcm9wcywgdGhpcy5yb3V0ZXJBbmltYXRpb24pO1xuICAgIH07XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoaChIb3N0LCB7IG9uQ2xpY2s6IHRoaXMub25DbGljayB9KSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcblxuZXhwb3J0IHsgTmF2IGFzIGlvbl9uYXYsIE5hdkxpbmsgYXMgaW9uX25hdl9saW5rIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=