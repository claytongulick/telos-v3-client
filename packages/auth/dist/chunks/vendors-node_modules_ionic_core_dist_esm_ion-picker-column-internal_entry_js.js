"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_ionic_core_dist_esm_ion-picker-column-internal_entry_js"],{

/***/ "../node_modules/@ionic/core/dist/esm/ion-picker-column-internal.entry.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@ionic/core/dist/esm/ion-picker-column-internal.entry.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_picker_column_internal": () => (/* binding */ PickerColumnInternal)
/* harmony export */ });
/* harmony import */ var _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-06cd27b1.js */ "../node_modules/@ionic/core/dist/esm/index-06cd27b1.js");
/* harmony import */ var _ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ionic-global-a049bcbf.js */ "../node_modules/@ionic/core/dist/esm/ionic-global-a049bcbf.js");
/* harmony import */ var _helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers-eed79a2b.js */ "../node_modules/@ionic/core/dist/esm/helpers-eed79a2b.js");
/* harmony import */ var _haptic_9a9aa7ec_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./haptic-9a9aa7ec.js */ "../node_modules/@ionic/core/dist/esm/haptic-9a9aa7ec.js");
/* harmony import */ var _theme_a24ff1ad_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./theme-a24ff1ad.js */ "../node_modules/@ionic/core/dist/esm/theme-a24ff1ad.js");
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */






const pickerColumnInternalIosCss = ":host{padding-left:16px;padding-right:16px;padding-top:0px;padding-bottom:0px;height:200px;outline:none;font-size:22px;-webkit-scroll-snap-type:y mandatory;-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory;overflow-x:hidden;overflow-y:scroll;scrollbar-width:none;text-align:center}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}:host::-webkit-scrollbar{display:none}:host .picker-item{height:34px;line-height:34px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;scroll-snap-align:center}:host .picker-item-empty{scroll-snap-align:none}:host(.picker-column-active) .picker-item.picker-item-active{color:var(--ion-color-base)}@media (any-hover: hover){:host(:focus){outline:none;background:rgba(var(--ion-color-base-rgb), 0.2)}}";

const pickerColumnInternalMdCss = ":host{padding-left:16px;padding-right:16px;padding-top:0px;padding-bottom:0px;height:200px;outline:none;font-size:22px;-webkit-scroll-snap-type:y mandatory;-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory;overflow-x:hidden;overflow-y:scroll;scrollbar-width:none;text-align:center}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}:host::-webkit-scrollbar{display:none}:host .picker-item{height:34px;line-height:34px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;scroll-snap-align:center}:host .picker-item-empty{scroll-snap-align:none}:host(.picker-column-active) .picker-item.picker-item-active{color:var(--ion-color-base)}@media (any-hover: hover){:host(:focus){outline:none;background:rgba(var(--ion-color-base-rgb), 0.2)}}:host .picker-item-active{color:var(--ion-color-base)}";

let PickerColumnInternal = class {
  constructor(hostRef) {
    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.ionChange = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionChange", 7);
    this.hapticsStarted = false;
    this.isColumnVisible = false;
    this.isActive = false;
    /**
     * A list of options to be displayed in the picker
     */
    this.items = [];
    /**
     * The color to use from your application's color palette.
     * Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     * For more information on colors, see [theming](/docs/theming/basics).
     */
    this.color = 'primary';
    /**
     * If `true`, tapping the picker will
     * reveal a number input keyboard that lets
     * the user type in values for each picker
     * column. This is useful when working
     * with time pickers.
     *
     * @internal
     */
    this.numericInput = false;
    this.centerPickerItemInView = (target, smooth = true) => {
      this.el.scroll({
        // (Vertical offset from parent) - (three empty picker rows) + (half the height of the target to ensure the scroll triggers)
        top: target.offsetTop - (3 * target.clientHeight) + (target.clientHeight / 2),
        left: 0,
        behavior: smooth ? 'smooth' : undefined
      });
    };
    /**
     * When ionInputModeChange is emitted, each column
     * needs to check if it is the one being made available
     * for text entry.
     */
    this.inputModeChange = (ev) => {
      if (!this.numericInput) {
        return;
      }
      const { useInputMode, inputModeColumn } = ev.detail;
      /**
       * If inputModeColumn is undefined then this means
       * all numericInput columns are being selected.
       */
      const isColumnActive = inputModeColumn === undefined || inputModeColumn === this.el;
      if (!useInputMode || !isColumnActive) {
        this.isActive = false;
        return;
      }
      this.isActive = true;
    };
    /**
     * When the column scrolls, the component
     * needs to determine which item is centered
     * in the view and will emit an ionChange with
     * the item object.
     */
    this.initializeScrollListener = () => {
      const { el } = this;
      let timeout;
      let activeEl = this.activeItem;
      const scrollCallback = () => {
        (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_2__.r)(() => {
          if (timeout) {
            clearTimeout(timeout);
            timeout = undefined;
          }
          if (!this.hapticsStarted) {
            (0,_haptic_9a9aa7ec_js__WEBPACK_IMPORTED_MODULE_3__.a)();
            this.hapticsStarted = true;
          }
          /**
           * Select item in the center of the column
           * which is the month/year that we want to select
           */
          const bbox = el.getBoundingClientRect();
          const centerX = bbox.x + (bbox.width / 2);
          const centerY = bbox.y + (bbox.height / 2);
          const activeElement = el.shadowRoot.elementFromPoint(centerX, centerY);
          if (activeEl !== null) {
            activeEl.classList.remove(PICKER_COL_ACTIVE);
          }
          /**
           * If we are selecting a new value,
           * we need to run haptics again.
           */
          if (activeElement !== activeEl) {
            (0,_haptic_9a9aa7ec_js__WEBPACK_IMPORTED_MODULE_3__.b)();
          }
          activeEl = activeElement;
          activeElement.classList.add(PICKER_COL_ACTIVE);
          timeout = setTimeout(() => {
            const dataIndex = activeElement.getAttribute('data-index');
            /**
             * If no value it is
             * possible we hit one of the
             * empty padding columns.
             */
            if (dataIndex === null) {
              return;
            }
            const index = parseInt(dataIndex, 10);
            const selectedItem = this.items[index];
            if (selectedItem.value !== this.value) {
              this.value = selectedItem.value;
              (0,_haptic_9a9aa7ec_js__WEBPACK_IMPORTED_MODULE_3__.h)();
              this.hapticsStarted = false;
            }
          }, 250);
        });
      };
      /**
       * Wrap this in an raf so that the scroll callback
       * does not fire when component is initially shown.
       */
      (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_2__.r)(() => {
        el.addEventListener('scroll', scrollCallback);
        this.destroyScrollListener = () => {
          el.removeEventListener('scroll', scrollCallback);
        };
      });
    };
  }
  valueChange() {
    if (this.isColumnVisible) {
      /**
       * Only scroll the active item into view and emit the value
       * change, when the picker column is actively visible to the user.
       */
      const { items, value } = this;
      this.scrollActiveItemIntoView();
      const findItem = items.find(item => item.value === value);
      if (findItem) {
        this.ionChange.emit(findItem);
      }
    }
  }
  /**
   * Only setup scroll listeners
   * when the picker is visible, otherwise
   * the container will have a scroll
   * height of 0px.
   */
  componentWillLoad() {
    const visibleCallback = (entries) => {
      var _a;
      const ev = entries[0];
      if (ev.isIntersecting) {
        /**
         * Because this initial call to scrollActiveItemIntoView has to fire before
         * the scroll listener is set up, we need to manage the active class manually.
         */
        const oldActive = (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.el).querySelector(`.${PICKER_COL_ACTIVE}`);
        oldActive === null || oldActive === void 0 ? void 0 : oldActive.classList.remove(PICKER_COL_ACTIVE);
        this.scrollActiveItemIntoView();
        (_a = this.activeItem) === null || _a === void 0 ? void 0 : _a.classList.add(PICKER_COL_ACTIVE);
        this.initializeScrollListener();
        this.isColumnVisible = true;
      }
      else {
        if (this.destroyScrollListener) {
          this.destroyScrollListener();
          this.destroyScrollListener = undefined;
        }
        this.isColumnVisible = false;
      }
    };
    new IntersectionObserver(visibleCallback, { threshold: 0.01 }).observe(this.el);
    const parentEl = this.el.closest('ion-picker-internal');
    if (parentEl !== null) {
      parentEl.addEventListener('ionInputModeChange', (ev) => this.inputModeChange(ev));
    }
  }
  scrollActiveItemIntoView() {
    const activeEl = this.activeItem;
    if (activeEl) {
      this.centerPickerItemInView(activeEl, false);
    }
  }
  get activeItem() {
    return (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.el).querySelector(`.picker-item[data-value="${this.value}"]`);
  }
  render() {
    const { items, color, isActive, numericInput } = this;
    const mode = (0,_ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_1__.b)(this);
    return ((0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.H, { tabindex: 0, class: (0,_theme_a24ff1ad_js__WEBPACK_IMPORTED_MODULE_4__.c)(color, {
        [mode]: true,
        ['picker-column-active']: isActive,
        ['picker-column-numeric-input']: numericInput
      }) }, (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "picker-item picker-item-empty" }, "\u00A0"), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "picker-item picker-item-empty" }, "\u00A0"), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "picker-item picker-item-empty" }, "\u00A0"), items.map((item, index) => {
      return ((0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "picker-item", "data-value": item.value, "data-index": index, onClick: (ev) => {
          this.centerPickerItemInView(ev.target);
        } }, item.text));
    }), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "picker-item picker-item-empty" }, "\u00A0"), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "picker-item picker-item-empty" }, "\u00A0"), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "picker-item picker-item-empty" }, "\u00A0")));
  }
  get el() { return (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.i)(this); }
  static get watchers() { return {
    "value": ["valueChange"]
  }; }
};
const PICKER_COL_ACTIVE = 'picker-item-active';
PickerColumnInternal.style = {
  ios: pickerColumnInternalIosCss,
  md: pickerColumnInternalMdCss
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfZGlzdF9lc21faW9uLXBpY2tlci1jb2x1bW4taW50ZXJuYWxfZW50cnlfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQzZHO0FBQ2hEO0FBQ1M7QUFDaUQ7QUFDekQ7O0FBRTlELDBDQUEwQyxrQkFBa0IsbUJBQW1CLGdCQUFnQixtQkFBbUIsYUFBYSxhQUFhLGVBQWUscUNBQXFDLGlDQUFpQyw2QkFBNkIsa0JBQWtCLGtCQUFrQixxQkFBcUIsa0JBQWtCLCtGQUErRixNQUFNLG1CQUFtQixvQkFBb0IsMkJBQTJCLDBCQUEwQix5QkFBeUIseUJBQXlCLHlCQUF5QixhQUFhLG1CQUFtQixZQUFZLGlCQUFpQix1QkFBdUIsbUJBQW1CLGdCQUFnQix5QkFBeUIseUJBQXlCLHVCQUF1Qiw2REFBNkQsNEJBQTRCLDBCQUEwQixjQUFjLGFBQWEsaURBQWlEOztBQUVwOUIseUNBQXlDLGtCQUFrQixtQkFBbUIsZ0JBQWdCLG1CQUFtQixhQUFhLGFBQWEsZUFBZSxxQ0FBcUMsaUNBQWlDLDZCQUE2QixrQkFBa0Isa0JBQWtCLHFCQUFxQixrQkFBa0IsK0ZBQStGLE1BQU0sbUJBQW1CLG9CQUFvQiwyQkFBMkIsMEJBQTBCLHlCQUF5Qix5QkFBeUIseUJBQXlCLGFBQWEsbUJBQW1CLFlBQVksaUJBQWlCLHVCQUF1QixtQkFBbUIsZ0JBQWdCLHlCQUF5Qix5QkFBeUIsdUJBQXVCLDZEQUE2RCw0QkFBNEIsMEJBQTBCLGNBQWMsYUFBYSxpREFBaUQsMEJBQTBCLDRCQUE0Qjs7QUFFemdDO0FBQ0E7QUFDQSxJQUFJLHFEQUFnQjtBQUNwQixxQkFBcUIscURBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFrQjtBQUNoQztBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBRztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQWMsNEJBQTRCLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlCQUFpQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFjLG9EQUFvRCxXQUFXO0FBQ3hGO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRCxpQkFBaUIsNERBQVU7QUFDM0IsWUFBWSxxREFBQyxDQUFDLGlEQUFJLElBQUksb0JBQW9CLHFEQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUcsRUFBRSxxREFBQyxVQUFVLHdDQUF3QyxhQUFhLHFEQUFDLFVBQVUsd0NBQXdDLGFBQWEscURBQUMsVUFBVSx3Q0FBd0M7QUFDL0wsY0FBYyxxREFBQyxVQUFVO0FBQ3pCO0FBQ0EsV0FBVztBQUNYLEtBQUssR0FBRyxxREFBQyxVQUFVLHdDQUF3QyxhQUFhLHFEQUFDLFVBQVUsd0NBQXdDLGFBQWEscURBQUMsVUFBVSx3Q0FBd0M7QUFDM0w7QUFDQSxhQUFhLE9BQU8scURBQVU7QUFDOUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS9pb24tcGlja2VyLWNvbHVtbi1pbnRlcm5hbC5lbnRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBlIGFzIGNyZWF0ZUV2ZW50LCBoLCBIIGFzIEhvc3QsIGkgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtMDZjZDI3YjEuanMnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwtYTA0OWJjYmYuanMnO1xuaW1wb3J0IHsgciBhcyByYWYsIGcgYXMgZ2V0RWxlbWVudFJvb3QgfSBmcm9tICcuL2hlbHBlcnMtZWVkNzlhMmIuanMnO1xuaW1wb3J0IHsgYSBhcyBoYXB0aWNTZWxlY3Rpb25TdGFydCwgYiBhcyBoYXB0aWNTZWxlY3Rpb25DaGFuZ2VkLCBoIGFzIGhhcHRpY1NlbGVjdGlvbkVuZCB9IGZyb20gJy4vaGFwdGljLTlhOWFhN2VjLmpzJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlQ29sb3JDbGFzc2VzIH0gZnJvbSAnLi90aGVtZS1hMjRmZjFhZC5qcyc7XG5cbmNvbnN0IHBpY2tlckNvbHVtbkludGVybmFsSW9zQ3NzID0gXCI6aG9zdHtwYWRkaW5nLWxlZnQ6MTZweDtwYWRkaW5nLXJpZ2h0OjE2cHg7cGFkZGluZy10b3A6MHB4O3BhZGRpbmctYm90dG9tOjBweDtoZWlnaHQ6MjAwcHg7b3V0bGluZTpub25lO2ZvbnQtc2l6ZToyMnB4Oy13ZWJraXQtc2Nyb2xsLXNuYXAtdHlwZTp5IG1hbmRhdG9yeTstbXMtc2Nyb2xsLXNuYXAtdHlwZTp5IG1hbmRhdG9yeTtzY3JvbGwtc25hcC10eXBlOnkgbWFuZGF0b3J5O292ZXJmbG93LXg6aGlkZGVuO292ZXJmbG93LXk6c2Nyb2xsO3Njcm9sbGJhci13aWR0aDpub25lO3RleHQtYWxpZ246Y2VudGVyfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3R7cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjE2cHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MTZweDstd2Via2l0LXBhZGRpbmctZW5kOjE2cHg7cGFkZGluZy1pbmxpbmUtZW5kOjE2cHh9fTpob3N0Ojotd2Via2l0LXNjcm9sbGJhcntkaXNwbGF5Om5vbmV9Omhvc3QgLnBpY2tlci1pdGVte2hlaWdodDozNHB4O2xpbmUtaGVpZ2h0OjM0cHg7dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO3Njcm9sbC1zbmFwLWFsaWduOmNlbnRlcn06aG9zdCAucGlja2VyLWl0ZW0tZW1wdHl7c2Nyb2xsLXNuYXAtYWxpZ246bm9uZX06aG9zdCgucGlja2VyLWNvbHVtbi1hY3RpdmUpIC5waWNrZXItaXRlbS5waWNrZXItaXRlbS1hY3RpdmV7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWJhc2UpfUBtZWRpYSAoYW55LWhvdmVyOiBob3Zlcil7Omhvc3QoOmZvY3VzKXtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZDpyZ2JhKHZhcigtLWlvbi1jb2xvci1iYXNlLXJnYiksIDAuMil9fVwiO1xuXG5jb25zdCBwaWNrZXJDb2x1bW5JbnRlcm5hbE1kQ3NzID0gXCI6aG9zdHtwYWRkaW5nLWxlZnQ6MTZweDtwYWRkaW5nLXJpZ2h0OjE2cHg7cGFkZGluZy10b3A6MHB4O3BhZGRpbmctYm90dG9tOjBweDtoZWlnaHQ6MjAwcHg7b3V0bGluZTpub25lO2ZvbnQtc2l6ZToyMnB4Oy13ZWJraXQtc2Nyb2xsLXNuYXAtdHlwZTp5IG1hbmRhdG9yeTstbXMtc2Nyb2xsLXNuYXAtdHlwZTp5IG1hbmRhdG9yeTtzY3JvbGwtc25hcC10eXBlOnkgbWFuZGF0b3J5O292ZXJmbG93LXg6aGlkZGVuO292ZXJmbG93LXk6c2Nyb2xsO3Njcm9sbGJhci13aWR0aDpub25lO3RleHQtYWxpZ246Y2VudGVyfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3R7cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjE2cHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MTZweDstd2Via2l0LXBhZGRpbmctZW5kOjE2cHg7cGFkZGluZy1pbmxpbmUtZW5kOjE2cHh9fTpob3N0Ojotd2Via2l0LXNjcm9sbGJhcntkaXNwbGF5Om5vbmV9Omhvc3QgLnBpY2tlci1pdGVte2hlaWdodDozNHB4O2xpbmUtaGVpZ2h0OjM0cHg7dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO3Njcm9sbC1zbmFwLWFsaWduOmNlbnRlcn06aG9zdCAucGlja2VyLWl0ZW0tZW1wdHl7c2Nyb2xsLXNuYXAtYWxpZ246bm9uZX06aG9zdCgucGlja2VyLWNvbHVtbi1hY3RpdmUpIC5waWNrZXItaXRlbS5waWNrZXItaXRlbS1hY3RpdmV7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWJhc2UpfUBtZWRpYSAoYW55LWhvdmVyOiBob3Zlcil7Omhvc3QoOmZvY3VzKXtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZDpyZ2JhKHZhcigtLWlvbi1jb2xvci1iYXNlLXJnYiksIDAuMil9fTpob3N0IC5waWNrZXItaXRlbS1hY3RpdmV7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWJhc2UpfVwiO1xuXG5sZXQgUGlja2VyQ29sdW1uSW50ZXJuYWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIHRoaXMuaW9uQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25DaGFuZ2VcIiwgNyk7XG4gICAgdGhpcy5oYXB0aWNzU3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNDb2x1bW5WaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBvcHRpb25zIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgcGlja2VyXG4gICAgICovXG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb2xvciB0byB1c2UgZnJvbSB5b3VyIGFwcGxpY2F0aW9uJ3MgY29sb3IgcGFsZXR0ZS5cbiAgICAgKiBEZWZhdWx0IG9wdGlvbnMgYXJlOiBgXCJwcmltYXJ5XCJgLCBgXCJzZWNvbmRhcnlcImAsIGBcInRlcnRpYXJ5XCJgLCBgXCJzdWNjZXNzXCJgLCBgXCJ3YXJuaW5nXCJgLCBgXCJkYW5nZXJcImAsIGBcImxpZ2h0XCJgLCBgXCJtZWRpdW1cImAsIGFuZCBgXCJkYXJrXCJgLlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGNvbG9ycywgc2VlIFt0aGVtaW5nXSgvZG9jcy90aGVtaW5nL2Jhc2ljcykuXG4gICAgICovXG4gICAgdGhpcy5jb2xvciA9ICdwcmltYXJ5JztcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHRhcHBpbmcgdGhlIHBpY2tlciB3aWxsXG4gICAgICogcmV2ZWFsIGEgbnVtYmVyIGlucHV0IGtleWJvYXJkIHRoYXQgbGV0c1xuICAgICAqIHRoZSB1c2VyIHR5cGUgaW4gdmFsdWVzIGZvciBlYWNoIHBpY2tlclxuICAgICAqIGNvbHVtbi4gVGhpcyBpcyB1c2VmdWwgd2hlbiB3b3JraW5nXG4gICAgICogd2l0aCB0aW1lIHBpY2tlcnMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLm51bWVyaWNJbnB1dCA9IGZhbHNlO1xuICAgIHRoaXMuY2VudGVyUGlja2VySXRlbUluVmlldyA9ICh0YXJnZXQsIHNtb290aCA9IHRydWUpID0+IHtcbiAgICAgIHRoaXMuZWwuc2Nyb2xsKHtcbiAgICAgICAgLy8gKFZlcnRpY2FsIG9mZnNldCBmcm9tIHBhcmVudCkgLSAodGhyZWUgZW1wdHkgcGlja2VyIHJvd3MpICsgKGhhbGYgdGhlIGhlaWdodCBvZiB0aGUgdGFyZ2V0IHRvIGVuc3VyZSB0aGUgc2Nyb2xsIHRyaWdnZXJzKVxuICAgICAgICB0b3A6IHRhcmdldC5vZmZzZXRUb3AgLSAoMyAqIHRhcmdldC5jbGllbnRIZWlnaHQpICsgKHRhcmdldC5jbGllbnRIZWlnaHQgLyAyKSxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYmVoYXZpb3I6IHNtb290aCA/ICdzbW9vdGgnIDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gaW9uSW5wdXRNb2RlQ2hhbmdlIGlzIGVtaXR0ZWQsIGVhY2ggY29sdW1uXG4gICAgICogbmVlZHMgdG8gY2hlY2sgaWYgaXQgaXMgdGhlIG9uZSBiZWluZyBtYWRlIGF2YWlsYWJsZVxuICAgICAqIGZvciB0ZXh0IGVudHJ5LlxuICAgICAqL1xuICAgIHRoaXMuaW5wdXRNb2RlQ2hhbmdlID0gKGV2KSA9PiB7XG4gICAgICBpZiAoIXRoaXMubnVtZXJpY0lucHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdXNlSW5wdXRNb2RlLCBpbnB1dE1vZGVDb2x1bW4gfSA9IGV2LmRldGFpbDtcbiAgICAgIC8qKlxuICAgICAgICogSWYgaW5wdXRNb2RlQ29sdW1uIGlzIHVuZGVmaW5lZCB0aGVuIHRoaXMgbWVhbnNcbiAgICAgICAqIGFsbCBudW1lcmljSW5wdXQgY29sdW1ucyBhcmUgYmVpbmcgc2VsZWN0ZWQuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGlzQ29sdW1uQWN0aXZlID0gaW5wdXRNb2RlQ29sdW1uID09PSB1bmRlZmluZWQgfHwgaW5wdXRNb2RlQ29sdW1uID09PSB0aGlzLmVsO1xuICAgICAgaWYgKCF1c2VJbnB1dE1vZGUgfHwgIWlzQ29sdW1uQWN0aXZlKSB7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBjb2x1bW4gc2Nyb2xscywgdGhlIGNvbXBvbmVudFxuICAgICAqIG5lZWRzIHRvIGRldGVybWluZSB3aGljaCBpdGVtIGlzIGNlbnRlcmVkXG4gICAgICogaW4gdGhlIHZpZXcgYW5kIHdpbGwgZW1pdCBhbiBpb25DaGFuZ2Ugd2l0aFxuICAgICAqIHRoZSBpdGVtIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLmluaXRpYWxpemVTY3JvbGxMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZWwgfSA9IHRoaXM7XG4gICAgICBsZXQgdGltZW91dDtcbiAgICAgIGxldCBhY3RpdmVFbCA9IHRoaXMuYWN0aXZlSXRlbTtcbiAgICAgIGNvbnN0IHNjcm9sbENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICByYWYoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuaGFwdGljc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGhhcHRpY1NlbGVjdGlvblN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLmhhcHRpY3NTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogU2VsZWN0IGl0ZW0gaW4gdGhlIGNlbnRlciBvZiB0aGUgY29sdW1uXG4gICAgICAgICAgICogd2hpY2ggaXMgdGhlIG1vbnRoL3llYXIgdGhhdCB3ZSB3YW50IHRvIHNlbGVjdFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0IGJib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBjb25zdCBjZW50ZXJYID0gYmJveC54ICsgKGJib3gud2lkdGggLyAyKTtcbiAgICAgICAgICBjb25zdCBjZW50ZXJZID0gYmJveC55ICsgKGJib3guaGVpZ2h0IC8gMik7XG4gICAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGVsLnNoYWRvd1Jvb3QuZWxlbWVudEZyb21Qb2ludChjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgICBpZiAoYWN0aXZlRWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsLmNsYXNzTGlzdC5yZW1vdmUoUElDS0VSX0NPTF9BQ1RJVkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJZiB3ZSBhcmUgc2VsZWN0aW5nIGEgbmV3IHZhbHVlLFxuICAgICAgICAgICAqIHdlIG5lZWQgdG8gcnVuIGhhcHRpY3MgYWdhaW4uXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgIT09IGFjdGl2ZUVsKSB7XG4gICAgICAgICAgICBoYXB0aWNTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoUElDS0VSX0NPTF9BQ1RJVkUpO1xuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IGFjdGl2ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4Jyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIG5vIHZhbHVlIGl0IGlzXG4gICAgICAgICAgICAgKiBwb3NzaWJsZSB3ZSBoaXQgb25lIG9mIHRoZVxuICAgICAgICAgICAgICogZW1wdHkgcGFkZGluZyBjb2x1bW5zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZGF0YUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoZGF0YUluZGV4LCAxMCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEl0ZW0gPSB0aGlzLml0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEl0ZW0udmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNlbGVjdGVkSXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgaGFwdGljU2VsZWN0aW9uRW5kKCk7XG4gICAgICAgICAgICAgIHRoaXMuaGFwdGljc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAyNTApO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIFdyYXAgdGhpcyBpbiBhbiByYWYgc28gdGhhdCB0aGUgc2Nyb2xsIGNhbGxiYWNrXG4gICAgICAgKiBkb2VzIG5vdCBmaXJlIHdoZW4gY29tcG9uZW50IGlzIGluaXRpYWxseSBzaG93bi5cbiAgICAgICAqL1xuICAgICAgcmFmKCgpID0+IHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsQ2FsbGJhY2spO1xuICAgICAgICB0aGlzLmRlc3Ryb3lTY3JvbGxMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxDYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIHZhbHVlQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmlzQ29sdW1uVmlzaWJsZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBPbmx5IHNjcm9sbCB0aGUgYWN0aXZlIGl0ZW0gaW50byB2aWV3IGFuZCBlbWl0IHRoZSB2YWx1ZVxuICAgICAgICogY2hhbmdlLCB3aGVuIHRoZSBwaWNrZXIgY29sdW1uIGlzIGFjdGl2ZWx5IHZpc2libGUgdG8gdGhlIHVzZXIuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHsgaXRlbXMsIHZhbHVlIH0gPSB0aGlzO1xuICAgICAgdGhpcy5zY3JvbGxBY3RpdmVJdGVtSW50b1ZpZXcoKTtcbiAgICAgIGNvbnN0IGZpbmRJdGVtID0gaXRlbXMuZmluZChpdGVtID0+IGl0ZW0udmFsdWUgPT09IHZhbHVlKTtcbiAgICAgIGlmIChmaW5kSXRlbSkge1xuICAgICAgICB0aGlzLmlvbkNoYW5nZS5lbWl0KGZpbmRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9ubHkgc2V0dXAgc2Nyb2xsIGxpc3RlbmVyc1xuICAgKiB3aGVuIHRoZSBwaWNrZXIgaXMgdmlzaWJsZSwgb3RoZXJ3aXNlXG4gICAqIHRoZSBjb250YWluZXIgd2lsbCBoYXZlIGEgc2Nyb2xsXG4gICAqIGhlaWdodCBvZiAwcHguXG4gICAqL1xuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBjb25zdCB2aXNpYmxlQ2FsbGJhY2sgPSAoZW50cmllcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZXYgPSBlbnRyaWVzWzBdO1xuICAgICAgaWYgKGV2LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWNhdXNlIHRoaXMgaW5pdGlhbCBjYWxsIHRvIHNjcm9sbEFjdGl2ZUl0ZW1JbnRvVmlldyBoYXMgdG8gZmlyZSBiZWZvcmVcbiAgICAgICAgICogdGhlIHNjcm9sbCBsaXN0ZW5lciBpcyBzZXQgdXAsIHdlIG5lZWQgdG8gbWFuYWdlIHRoZSBhY3RpdmUgY2xhc3MgbWFudWFsbHkuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvbGRBY3RpdmUgPSBnZXRFbGVtZW50Um9vdCh0aGlzLmVsKS5xdWVyeVNlbGVjdG9yKGAuJHtQSUNLRVJfQ09MX0FDVElWRX1gKTtcbiAgICAgICAgb2xkQWN0aXZlID09PSBudWxsIHx8IG9sZEFjdGl2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkQWN0aXZlLmNsYXNzTGlzdC5yZW1vdmUoUElDS0VSX0NPTF9BQ1RJVkUpO1xuICAgICAgICB0aGlzLnNjcm9sbEFjdGl2ZUl0ZW1JbnRvVmlldygpO1xuICAgICAgICAoX2EgPSB0aGlzLmFjdGl2ZUl0ZW0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzc0xpc3QuYWRkKFBJQ0tFUl9DT0xfQUNUSVZFKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplU2Nyb2xsTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5pc0NvbHVtblZpc2libGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3lTY3JvbGxMaXN0ZW5lcikge1xuICAgICAgICAgIHRoaXMuZGVzdHJveVNjcm9sbExpc3RlbmVyKCk7XG4gICAgICAgICAgdGhpcy5kZXN0cm95U2Nyb2xsTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NvbHVtblZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcih2aXNpYmxlQ2FsbGJhY2ssIHsgdGhyZXNob2xkOiAwLjAxIH0pLm9ic2VydmUodGhpcy5lbCk7XG4gICAgY29uc3QgcGFyZW50RWwgPSB0aGlzLmVsLmNsb3Nlc3QoJ2lvbi1waWNrZXItaW50ZXJuYWwnKTtcbiAgICBpZiAocGFyZW50RWwgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lvbklucHV0TW9kZUNoYW5nZScsIChldikgPT4gdGhpcy5pbnB1dE1vZGVDaGFuZ2UoZXYpKTtcbiAgICB9XG4gIH1cbiAgc2Nyb2xsQWN0aXZlSXRlbUludG9WaWV3KCkge1xuICAgIGNvbnN0IGFjdGl2ZUVsID0gdGhpcy5hY3RpdmVJdGVtO1xuICAgIGlmIChhY3RpdmVFbCkge1xuICAgICAgdGhpcy5jZW50ZXJQaWNrZXJJdGVtSW5WaWV3KGFjdGl2ZUVsLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGdldCBhY3RpdmVJdGVtKCkge1xuICAgIHJldHVybiBnZXRFbGVtZW50Um9vdCh0aGlzLmVsKS5xdWVyeVNlbGVjdG9yKGAucGlja2VyLWl0ZW1bZGF0YS12YWx1ZT1cIiR7dGhpcy52YWx1ZX1cIl1gKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpdGVtcywgY29sb3IsIGlzQWN0aXZlLCBudW1lcmljSW5wdXQgfSA9IHRoaXM7XG4gICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgdGFiaW5kZXg6IDAsIGNsYXNzOiBjcmVhdGVDb2xvckNsYXNzZXMoY29sb3IsIHtcbiAgICAgICAgW21vZGVdOiB0cnVlLFxuICAgICAgICBbJ3BpY2tlci1jb2x1bW4tYWN0aXZlJ106IGlzQWN0aXZlLFxuICAgICAgICBbJ3BpY2tlci1jb2x1bW4tbnVtZXJpYy1pbnB1dCddOiBudW1lcmljSW5wdXRcbiAgICAgIH0pIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogXCJwaWNrZXItaXRlbSBwaWNrZXItaXRlbS1lbXB0eVwiIH0sIFwiXFx1MDBBMFwiKSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInBpY2tlci1pdGVtIHBpY2tlci1pdGVtLWVtcHR5XCIgfSwgXCJcXHUwMEEwXCIpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwicGlja2VyLWl0ZW0gcGlja2VyLWl0ZW0tZW1wdHlcIiB9LCBcIlxcdTAwQTBcIiksIGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBcInBpY2tlci1pdGVtXCIsIFwiZGF0YS12YWx1ZVwiOiBpdGVtLnZhbHVlLCBcImRhdGEtaW5kZXhcIjogaW5kZXgsIG9uQ2xpY2s6IChldikgPT4ge1xuICAgICAgICAgIHRoaXMuY2VudGVyUGlja2VySXRlbUluVmlldyhldi50YXJnZXQpO1xuICAgICAgICB9IH0sIGl0ZW0udGV4dCkpO1xuICAgIH0pLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwicGlja2VyLWl0ZW0gcGlja2VyLWl0ZW0tZW1wdHlcIiB9LCBcIlxcdTAwQTBcIiksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJwaWNrZXItaXRlbSBwaWNrZXItaXRlbS1lbXB0eVwiIH0sIFwiXFx1MDBBMFwiKSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInBpY2tlci1pdGVtIHBpY2tlci1pdGVtLWVtcHR5XCIgfSwgXCJcXHUwMEEwXCIpKSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwidmFsdWVcIjogW1widmFsdWVDaGFuZ2VcIl1cbiAgfTsgfVxufTtcbmNvbnN0IFBJQ0tFUl9DT0xfQUNUSVZFID0gJ3BpY2tlci1pdGVtLWFjdGl2ZSc7XG5QaWNrZXJDb2x1bW5JbnRlcm5hbC5zdHlsZSA9IHtcbiAgaW9zOiBwaWNrZXJDb2x1bW5JbnRlcm5hbElvc0NzcyxcbiAgbWQ6IHBpY2tlckNvbHVtbkludGVybmFsTWRDc3Ncbn07XG5cbmV4cG9ydCB7IFBpY2tlckNvbHVtbkludGVybmFsIGFzIGlvbl9waWNrZXJfY29sdW1uX2ludGVybmFsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=