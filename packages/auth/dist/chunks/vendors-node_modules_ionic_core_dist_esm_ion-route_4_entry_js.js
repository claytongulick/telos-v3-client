"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_ionic_core_dist_esm_ion-route_4_entry_js"],{

/***/ "../node_modules/@ionic/core/dist/esm/ion-route_4.entry.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@ionic/core/dist/esm/ion-route_4.entry.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_route": () => (/* binding */ Route),
/* harmony export */   "ion_route_redirect": () => (/* binding */ RouteRedirect),
/* harmony export */   "ion_router": () => (/* binding */ Router),
/* harmony export */   "ion_router_link": () => (/* binding */ RouterLink)
/* harmony export */ });
/* harmony import */ var _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-06cd27b1.js */ "../node_modules/@ionic/core/dist/esm/index-06cd27b1.js");
/* harmony import */ var _helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers-eed79a2b.js */ "../node_modules/@ionic/core/dist/esm/helpers-eed79a2b.js");
/* harmony import */ var _ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ionic-global-a049bcbf.js */ "../node_modules/@ionic/core/dist/esm/ionic-global-a049bcbf.js");
/* harmony import */ var _theme_a24ff1ad_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./theme-a24ff1ad.js */ "../node_modules/@ionic/core/dist/esm/theme-a24ff1ad.js");
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */





let Route = class {
  constructor(hostRef) {
    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.ionRouteDataChanged = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionRouteDataChanged", 7);
    /**
     * Relative path that needs to match in order for this route to apply.
     *
     * Accepts paths similar to expressjs so that you can define parameters
     * in the url /foo/:bar where bar would be available in incoming props.
     */
    this.url = '';
  }
  onUpdate(newValue) {
    this.ionRouteDataChanged.emit(newValue);
  }
  onComponentProps(newValue, oldValue) {
    if (newValue === oldValue) {
      return;
    }
    const keys1 = newValue ? Object.keys(newValue) : [];
    const keys2 = oldValue ? Object.keys(oldValue) : [];
    if (keys1.length !== keys2.length) {
      this.onUpdate(newValue);
      return;
    }
    for (const key of keys1) {
      if (newValue[key] !== oldValue[key]) {
        this.onUpdate(newValue);
        return;
      }
    }
  }
  connectedCallback() {
    this.ionRouteDataChanged.emit();
  }
  static get watchers() { return {
    "url": ["onUpdate"],
    "component": ["onUpdate"],
    "componentProps": ["onComponentProps"]
  }; }
};

let RouteRedirect = class {
  constructor(hostRef) {
    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.ionRouteRedirectChanged = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionRouteRedirectChanged", 7);
  }
  propDidChange() {
    this.ionRouteRedirectChanged.emit();
  }
  connectedCallback() {
    this.ionRouteRedirectChanged.emit();
  }
  static get watchers() { return {
    "from": ["propDidChange"],
    "to": ["propDidChange"]
  }; }
};

const ROUTER_INTENT_NONE = 'root';
const ROUTER_INTENT_FORWARD = 'forward';
const ROUTER_INTENT_BACK = 'back';

// Join the non empty segments with "/".
const generatePath = (segments) => {
  const path = segments
    .filter(s => s.length > 0)
    .join('/');
  return '/' + path;
};
const generateUrl = (segments, useHash, queryString) => {
  let url = generatePath(segments);
  if (useHash) {
    url = '#' + url;
  }
  if (queryString !== undefined) {
    url += '?' + queryString;
  }
  return url;
};
const writePath = (history, root, useHash, path, direction, state, queryString) => {
  const url = generateUrl([...parsePath(root).segments, ...path], useHash, queryString);
  if (direction === ROUTER_INTENT_FORWARD) {
    history.pushState(state, '', url);
  }
  else {
    history.replaceState(state, '', url);
  }
};
const chainToPath = (chain) => {
  const path = [];
  for (const route of chain) {
    for (const segment of route.path) {
      if (segment[0] === ':') {
        const param = route.params && route.params[segment.slice(1)];
        if (!param) {
          return null;
        }
        path.push(param);
      }
      else if (segment !== '') {
        path.push(segment);
      }
    }
  }
  return path;
};
// Remove the prefix segments from the path segments.
//
// Return:
// - null when the path segments do not start with the passed prefix,
// - the path segments after the prefix otherwise.
const removePrefix = (prefix, path) => {
  if (prefix.length > path.length) {
    return null;
  }
  if (prefix.length <= 1 && prefix[0] === '') {
    return path;
  }
  for (let i = 0; i < prefix.length; i++) {
    if (prefix[i] !== path[i]) {
      return null;
    }
  }
  if (path.length === prefix.length) {
    return [''];
  }
  return path.slice(prefix.length);
};
const readPath = (loc, root, useHash) => {
  const prefix = parsePath(root).segments;
  const pathname = useHash ? loc.hash.slice(1) : loc.pathname;
  const path = parsePath(pathname).segments;
  return removePrefix(prefix, path);
};
// Parses the path to:
// - segments an array of '/' separated parts,
// - queryString (undefined when no query string).
const parsePath = (path) => {
  let segments = [''];
  let queryString;
  if (path != null) {
    const qsStart = path.indexOf('?');
    if (qsStart > -1) {
      queryString = path.substr(qsStart + 1);
      path = path.substr(0, qsStart);
    }
    segments = path.split('/')
      .map(s => s.trim())
      .filter(s => s.length > 0);
    if (segments.length === 0) {
      segments = [''];
    }
  }
  return { segments, queryString };
};

const printRoutes = (routes) => {
  console.group(`[ion-core] ROUTES[${routes.length}]`);
  for (const chain of routes) {
    const path = [];
    chain.forEach(r => path.push(...r.path));
    const ids = chain.map(r => r.id);
    console.debug(`%c ${generatePath(path)}`, 'font-weight: bold; padding-left: 20px', '=>\t', `(${ids.join(', ')})`);
  }
  console.groupEnd();
};
const printRedirects = (redirects) => {
  console.group(`[ion-core] REDIRECTS[${redirects.length}]`);
  for (const redirect of redirects) {
    if (redirect.to) {
      console.debug('FROM: ', `$c ${generatePath(redirect.from)}`, 'font-weight: bold', ' TO: ', `$c ${generatePath(redirect.to.segments)}`, 'font-weight: bold');
    }
  }
  console.groupEnd();
};

const writeNavState = async (root, chain, direction, index, changed = false, animation) => {
  try {
    // find next navigation outlet in the DOM
    const outlet = searchNavNode(root);
    // make sure we can continue interacting the DOM, otherwise abort
    if (index >= chain.length || !outlet) {
      return changed;
    }
    await new Promise(resolve => (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_1__.c)(outlet, resolve));
    const route = chain[index];
    const result = await outlet.setRouteId(route.id, route.params, direction, animation);
    // if the outlet changed the page, reset navigation to neutral (no direction)
    // this means nested outlets will not animate
    if (result.changed) {
      direction = ROUTER_INTENT_NONE;
      changed = true;
    }
    // recursively set nested outlets
    changed = await writeNavState(result.element, chain, direction, index + 1, changed, animation);
    // once all nested outlets are visible let's make the parent visible too,
    // using markVisible prevents flickering
    if (result.markVisible) {
      await result.markVisible();
    }
    return changed;
  }
  catch (e) {
    console.error(e);
    return false;
  }
};
const readNavState = async (root) => {
  const ids = [];
  let outlet;
  let node = root;
  // tslint:disable-next-line:no-constant-condition
  while (true) {
    outlet = searchNavNode(node);
    if (outlet) {
      const id = await outlet.getRouteId();
      if (id) {
        node = id.element;
        id.element = undefined;
        ids.push(id);
      }
      else {
        break;
      }
    }
    else {
      break;
    }
  }
  return { ids, outlet };
};
const waitUntilNavNode = () => {
  if (searchNavNode(document.body)) {
    return Promise.resolve();
  }
  return new Promise(resolve => {
    window.addEventListener('ionNavWillLoad', resolve, { once: true });
  });
};
const QUERY = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';
const searchNavNode = (root) => {
  if (!root) {
    return undefined;
  }
  if (root.matches(QUERY)) {
    return root;
  }
  const outlet = root.querySelector(QUERY);
  return outlet !== null && outlet !== void 0 ? outlet : undefined;
};

// Returns whether the given redirect matches the given path segments.
//
// A redirect matches when the segments of the path and redirect.from are equal.
// Note that segments are only checked until redirect.from contains a '*' which matches any path segment.
// The path ['some', 'path', 'to', 'page'] matches both ['some', 'path', 'to', 'page'] and ['some', 'path', '*'].
const matchesRedirect = (path, redirect) => {
  const { from, to } = redirect;
  if (to === undefined) {
    return false;
  }
  if (from.length > path.length) {
    return false;
  }
  for (let i = 0; i < from.length; i++) {
    const expected = from[i];
    if (expected === '*') {
      return true;
    }
    if (expected !== path[i]) {
      return false;
    }
  }
  return from.length === path.length;
};
// Returns the first redirect matching the path segments or undefined when no match found.
const findRouteRedirect = (path, redirects) => {
  return redirects.find(redirect => matchesRedirect(path, redirect));
};
const matchesIDs = (ids, chain) => {
  const len = Math.min(ids.length, chain.length);
  let score = 0;
  for (let i = 0; i < len; i++) {
    const routeId = ids[i];
    const routeChain = chain[i];
    // Skip results where the route id does not match the chain at the same index
    if (routeId.id.toLowerCase() !== routeChain.id) {
      break;
    }
    if (routeId.params) {
      const routeIdParams = Object.keys(routeId.params);
      /**
       * Only compare routes with the chain that have the same number of parameters.
       */
      if (routeIdParams.length === routeChain.path.length) {
        /**
         * Maps the route's params into a path based on the path variable names,
         * to compare against the route chain format.
         *
         * Before:
         * ```ts
         * {
         *  params: {
         *    s1: 'a',
         *    s2: 'b'
         *  }
         * }
         * ```
         *
         * After:
         * ```ts
         * [':s1',':s2']
         * ```
         */
        const pathWithParams = routeIdParams.map(key => `:${key}`);
        for (let j = 0; j < pathWithParams.length; j++) {
          // Skip results where the path variable is not a match
          if (pathWithParams[j].toLowerCase() !== routeChain.path[j]) {
            break;
          }
          // Weight path matches for the same index higher.
          score++;
        }
      }
    }
    // Weight id matches
    score++;
  }
  return score;
};
const matchesPath = (inputPath, chain) => {
  const segments = new RouterSegments(inputPath);
  let matchesDefault = false;
  let allparams;
  for (let i = 0; i < chain.length; i++) {
    const path = chain[i].path;
    if (path[0] === '') {
      matchesDefault = true;
    }
    else {
      for (const segment of path) {
        const data = segments.next();
        // data param
        if (segment[0] === ':') {
          if (data === '') {
            return null;
          }
          allparams = allparams || [];
          const params = allparams[i] || (allparams[i] = {});
          params[segment.slice(1)] = data;
        }
        else if (data !== segment) {
          return null;
        }
      }
      matchesDefault = false;
    }
  }
  const matches = (matchesDefault)
    ? matchesDefault === (segments.next() === '')
    : true;
  if (!matches) {
    return null;
  }
  if (allparams) {
    return chain.map((route, i) => ({
      id: route.id,
      path: route.path,
      params: mergeParams(route.params, allparams[i]),
      beforeEnter: route.beforeEnter,
      beforeLeave: route.beforeLeave
    }));
  }
  return chain;
};
// Merges the route parameter objects.
// Returns undefined when both parameters are undefined.
const mergeParams = (a, b) => {
  return a || b ? Object.assign(Object.assign({}, a), b) : undefined;
};
const routerIDsToChain = (ids, chains) => {
  let match = null;
  let maxMatches = 0;
  for (const chain of chains) {
    const score = matchesIDs(ids, chain);
    if (score > maxMatches) {
      match = chain;
      maxMatches = score;
    }
  }
  if (match) {
    return match.map((route, i) => ({
      id: route.id,
      path: route.path,
      params: mergeParams(route.params, ids[i] && ids[i].params)
    }));
  }
  return null;
};
const routerPathToChain = (path, chains) => {
  let match = null;
  let matches = 0;
  for (const chain of chains) {
    const matchedChain = matchesPath(path, chain);
    if (matchedChain !== null) {
      const score = computePriority(matchedChain);
      if (score > matches) {
        matches = score;
        match = matchedChain;
      }
    }
  }
  return match;
};
const computePriority = (chain) => {
  let score = 1;
  let level = 1;
  for (const route of chain) {
    for (const path of route.path) {
      if (path[0] === ':') {
        score += Math.pow(1, level);
      }
      else if (path !== '') {
        score += Math.pow(2, level);
      }
      level++;
    }
  }
  return score;
};
class RouterSegments {
  constructor(path) {
    this.path = path.slice();
  }
  next() {
    if (this.path.length > 0) {
      return this.path.shift();
    }
    return '';
  }
}

const readProp = (el, prop) => {
  if (prop in el) {
    return el[prop];
  }
  if (el.hasAttribute(prop)) {
    return el.getAttribute(prop);
  }
  return null;
};
const readRedirects = (root) => {
  return Array.from(root.children)
    .filter(el => el.tagName === 'ION-ROUTE-REDIRECT')
    .map(el => {
    const to = readProp(el, 'to');
    return {
      from: parsePath(readProp(el, 'from')).segments,
      to: to == null ? undefined : parsePath(to),
    };
  });
};
const readRoutes = (root) => {
  return flattenRouterTree(readRouteNodes(root));
};
const readRouteNodes = (node) => {
  return Array.from(node.children)
    .filter(el => el.tagName === 'ION-ROUTE' && el.component)
    .map(el => {
    const component = readProp(el, 'component');
    return {
      path: parsePath(readProp(el, 'url')).segments,
      id: component.toLowerCase(),
      params: el.componentProps,
      beforeLeave: el.beforeLeave,
      beforeEnter: el.beforeEnter,
      children: readRouteNodes(el)
    };
  });
};
const flattenRouterTree = (nodes) => {
  const chains = [];
  for (const node of nodes) {
    flattenNode([], chains, node);
  }
  return chains;
};
const flattenNode = (chain, chains, node) => {
  chain = chain.slice();
  chain.push({
    id: node.id,
    path: node.path,
    params: node.params,
    beforeLeave: node.beforeLeave,
    beforeEnter: node.beforeEnter
  });
  if (node.children.length === 0) {
    chains.push(chain);
    return;
  }
  for (const child of node.children) {
    flattenNode(chain, chains, child);
  }
};

let Router = class {
  constructor(hostRef) {
    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.ionRouteWillChange = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionRouteWillChange", 7);
    this.ionRouteDidChange = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionRouteDidChange", 7);
    this.previousPath = null;
    this.busy = false;
    this.state = 0;
    this.lastState = 0;
    /**
     * The root path to use when matching URLs. By default, this is set to "/", but you can specify
     * an alternate prefix for all URL paths.
     */
    this.root = '/';
    /**
     * The router can work in two "modes":
     * - With hash: `/index.html#/path/to/page`
     * - Without hash: `/path/to/page`
     *
     * Using one or another might depend in the requirements of your app and/or where it's deployed.
     *
     * Usually "hash-less" navigation works better for SEO and it's more user friendly too, but it might
     * requires additional server-side configuration in order to properly work.
     *
     * On the other side hash-navigation is much easier to deploy, it even works over the file protocol.
     *
     * By default, this property is `true`, change to `false` to allow hash-less URLs.
     */
    this.useHash = true;
  }
  async componentWillLoad() {
    await waitUntilNavNode();
    const canProceed = await this.runGuards(this.getPath());
    if (canProceed !== true) {
      if (typeof canProceed === 'object') {
        const { redirect } = canProceed;
        const path = parsePath(redirect);
        this.setPath(path.segments, ROUTER_INTENT_NONE, path.queryString);
        await this.writeNavStateRoot(path.segments, ROUTER_INTENT_NONE);
      }
    }
    else {
      await this.onRoutesChanged();
    }
  }
  componentDidLoad() {
    window.addEventListener('ionRouteRedirectChanged', (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_1__.o)(this.onRedirectChanged.bind(this), 10));
    window.addEventListener('ionRouteDataChanged', (0,_helpers_eed79a2b_js__WEBPACK_IMPORTED_MODULE_1__.o)(this.onRoutesChanged.bind(this), 100));
  }
  async onPopState() {
    const direction = this.historyDirection();
    let segments = this.getPath();
    const canProceed = await this.runGuards(segments);
    if (canProceed !== true) {
      if (typeof canProceed === 'object') {
        segments = parsePath(canProceed.redirect).segments;
      }
      else {
        return false;
      }
    }
    return this.writeNavStateRoot(segments, direction);
  }
  onBackButton(ev) {
    ev.detail.register(0, processNextHandler => {
      this.back();
      processNextHandler();
    });
  }
  /** @internal */
  async canTransition() {
    const canProceed = await this.runGuards();
    if (canProceed !== true) {
      if (typeof canProceed === 'object') {
        return canProceed.redirect;
      }
      else {
        return false;
      }
    }
    return true;
  }
  /**
   * Navigate to the specified URL.
   *
   * @param url The url to navigate to.
   * @param direction The direction of the animation. Defaults to `"forward"`.
   */
  async push(url, direction = 'forward', animation) {
    if (url.startsWith('.')) {
      url = (new URL(url, window.location.href)).pathname;
    }
    let parsedPath = parsePath(url);
    const canProceed = await this.runGuards(parsedPath.segments);
    if (canProceed !== true) {
      if (typeof canProceed === 'object') {
        parsedPath = parsePath(canProceed.redirect);
      }
      else {
        return false;
      }
    }
    this.setPath(parsedPath.segments, direction, parsedPath.queryString);
    return this.writeNavStateRoot(parsedPath.segments, direction, animation);
  }
  /**
   * Go back to previous page in the window.history.
   */
  back() {
    window.history.back();
    return Promise.resolve(this.waitPromise);
  }
  /** @internal */
  async printDebug() {
    printRoutes(readRoutes(this.el));
    printRedirects(readRedirects(this.el));
  }
  /** @internal */
  async navChanged(direction) {
    if (this.busy) {
      console.warn('[ion-router] router is busy, navChanged was cancelled');
      return false;
    }
    const { ids, outlet } = await readNavState(window.document.body);
    const routes = readRoutes(this.el);
    const chain = routerIDsToChain(ids, routes);
    if (!chain) {
      console.warn('[ion-router] no matching URL for ', ids.map(i => i.id));
      return false;
    }
    const path = chainToPath(chain);
    if (!path) {
      console.warn('[ion-router] router could not match path because some required param is missing');
      return false;
    }
    this.setPath(path, direction);
    await this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, path, null, ids.length);
    return true;
  }
  // This handler gets called when a `ion-route-redirect` component is added to the DOM or if the from or to property of such node changes.
  onRedirectChanged() {
    const path = this.getPath();
    if (path && findRouteRedirect(path, readRedirects(this.el))) {
      this.writeNavStateRoot(path, ROUTER_INTENT_NONE);
    }
  }
  // This handler gets called when a `ion-route` component is added to the DOM or if the from or to property of such node changes.
  onRoutesChanged() {
    return this.writeNavStateRoot(this.getPath(), ROUTER_INTENT_NONE);
  }
  historyDirection() {
    var _a;
    const win = window;
    if (win.history.state === null) {
      this.state++;
      win.history.replaceState(this.state, win.document.title, (_a = win.document.location) === null || _a === void 0 ? void 0 : _a.href);
    }
    const state = win.history.state;
    const lastState = this.lastState;
    this.lastState = state;
    if (state > lastState || (state >= lastState && lastState > 0)) {
      return ROUTER_INTENT_FORWARD;
    }
    if (state < lastState) {
      return ROUTER_INTENT_BACK;
    }
    return ROUTER_INTENT_NONE;
  }
  async writeNavStateRoot(path, direction, animation) {
    if (!path) {
      console.error('[ion-router] URL is not part of the routing set');
      return false;
    }
    // lookup redirect rule
    const redirects = readRedirects(this.el);
    const redirect = findRouteRedirect(path, redirects);
    let redirectFrom = null;
    if (redirect) {
      const { segments, queryString } = redirect.to;
      this.setPath(segments, direction, queryString);
      redirectFrom = redirect.from;
      path = segments;
    }
    // lookup route chain
    const routes = readRoutes(this.el);
    const chain = routerPathToChain(path, routes);
    if (!chain) {
      console.error('[ion-router] the path does not match any route');
      return false;
    }
    // write DOM give
    return this.safeWriteNavState(document.body, chain, direction, path, redirectFrom, 0, animation);
  }
  async safeWriteNavState(node, chain, direction, path, redirectFrom, index = 0, animation) {
    const unlock = await this.lock();
    let changed = false;
    try {
      changed = await this.writeNavState(node, chain, direction, path, redirectFrom, index, animation);
    }
    catch (e) {
      console.error(e);
    }
    unlock();
    return changed;
  }
  async lock() {
    const p = this.waitPromise;
    let resolve;
    this.waitPromise = new Promise(r => resolve = r);
    if (p !== undefined) {
      await p;
    }
    return resolve;
  }
  // Executes the beforeLeave hook of the source route and the beforeEnter hook of the target route if they exist.
  //
  // When the beforeLeave hook does not return true (to allow navigating) then that value is returned early and the beforeEnter is executed.
  // Otherwise the beforeEnterHook hook of the target route is executed.
  async runGuards(to = this.getPath(), from) {
    if (from === undefined) {
      from = parsePath(this.previousPath).segments;
    }
    if (!to || !from) {
      return true;
    }
    const routes = readRoutes(this.el);
    const fromChain = routerPathToChain(from, routes);
    const beforeLeaveHook = fromChain && fromChain[fromChain.length - 1].beforeLeave;
    const canLeave = beforeLeaveHook ? await beforeLeaveHook() : true;
    if (canLeave === false || typeof canLeave === 'object') {
      return canLeave;
    }
    const toChain = routerPathToChain(to, routes);
    const beforeEnterHook = toChain && toChain[toChain.length - 1].beforeEnter;
    return beforeEnterHook ? beforeEnterHook() : true;
  }
  async writeNavState(node, chain, direction, path, redirectFrom, index = 0, animation) {
    if (this.busy) {
      console.warn('[ion-router] router is busy, transition was cancelled');
      return false;
    }
    this.busy = true;
    // generate route event and emit will change
    const routeEvent = this.routeChangeEvent(path, redirectFrom);
    if (routeEvent) {
      this.ionRouteWillChange.emit(routeEvent);
    }
    const changed = await writeNavState(node, chain, direction, index, false, animation);
    this.busy = false;
    // emit did change
    if (routeEvent) {
      this.ionRouteDidChange.emit(routeEvent);
    }
    return changed;
  }
  setPath(path, direction, queryString) {
    this.state++;
    writePath(window.history, this.root, this.useHash, path, direction, this.state, queryString);
  }
  getPath() {
    return readPath(window.location, this.root, this.useHash);
  }
  routeChangeEvent(path, redirectFromPath) {
    const from = this.previousPath;
    const to = generatePath(path);
    this.previousPath = to;
    if (to === from) {
      return null;
    }
    const redirectedFrom = redirectFromPath ? generatePath(redirectFromPath) : null;
    return {
      from,
      redirectedFrom,
      to,
    };
  }
  get el() { return (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.i)(this); }
};

const routerLinkCss = ":host{--background:transparent;--color:var(--ion-color-primary, #3880ff);background:var(--background);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}a{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}";

let RouterLink = class {
  constructor(hostRef) {
    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    /**
     * When using a router, it specifies the transition direction when navigating to
     * another page using `href`.
     */
    this.routerDirection = 'forward';
    this.onClick = (ev) => {
      (0,_theme_a24ff1ad_js__WEBPACK_IMPORTED_MODULE_3__.o)(this.href, ev, this.routerDirection, this.routerAnimation);
    };
  }
  render() {
    const mode = (0,_ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_2__.b)(this);
    const attrs = {
      href: this.href,
      rel: this.rel,
      target: this.target
    };
    return ((0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.H, { onClick: this.onClick, class: (0,_theme_a24ff1ad_js__WEBPACK_IMPORTED_MODULE_3__.c)(this.color, {
        [mode]: true,
        'ion-activatable': true
      }) }, (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("a", Object.assign({}, attrs), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null))));
  }
};
RouterLink.style = routerLinkCss;




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfZGlzdF9lc21faW9uLXJvdXRlXzRfZW50cnlfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDNkc7QUFDaEM7QUFDaEI7QUFDZTs7QUFFNUU7QUFDQTtBQUNBLElBQUkscURBQWdCO0FBQ3BCLCtCQUErQixxREFBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHFEQUFnQjtBQUNwQixtQ0FBbUMscURBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CLHVCQUF1QixpQ0FBaUMsZUFBZTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEIsdUNBQXVDLG1DQUFtQztBQUMxSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVEQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxZQUFZO0FBQ3JFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELElBQUk7QUFDaEUsd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxxREFBZ0I7QUFDcEIsOEJBQThCLHFEQUFXO0FBQ3pDLDZCQUE2QixxREFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx1REFBUTtBQUMvRCxtREFBbUQsdURBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU8scURBQVU7QUFDOUI7O0FBRUEsNkJBQTZCLHlCQUF5QiwwQ0FBMEMsNkJBQTZCLG1CQUFtQixrQkFBa0IsNEJBQTRCLEVBQUUsb0JBQW9CLGtCQUFrQixtQkFBbUIsb0JBQW9CLHVCQUF1Qix3QkFBd0Isb0JBQW9CLHNCQUFzQix1QkFBdUIsbUJBQW1CLG9CQUFvQixjQUFjOztBQUVsYjtBQUNBO0FBQ0EsSUFBSSxxREFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0REFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBQyxDQUFDLGlEQUFJLElBQUksOEJBQThCLHFEQUFrQjtBQUN0RTtBQUNBO0FBQ0EsT0FBTyxHQUFHLEVBQUUscURBQUMsc0JBQXNCLFVBQVUscURBQUM7QUFDOUM7QUFDQTtBQUNBOztBQUV3SCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20vaW9uLXJvdXRlXzQuZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgZSBhcyBjcmVhdGVFdmVudCwgaSBhcyBnZXRFbGVtZW50LCBoLCBIIGFzIEhvc3QgfSBmcm9tICcuL2luZGV4LTA2Y2QyN2IxLmpzJztcbmltcG9ydCB7IGMgYXMgY29tcG9uZW50T25SZWFkeSwgbyBhcyBkZWJvdW5jZSB9IGZyb20gJy4vaGVscGVycy1lZWQ3OWEyYi5qcyc7XG5pbXBvcnQgeyBiIGFzIGdldElvbk1vZGUgfSBmcm9tICcuL2lvbmljLWdsb2JhbC1hMDQ5YmNiZi5qcyc7XG5pbXBvcnQgeyBvIGFzIG9wZW5VUkwsIGMgYXMgY3JlYXRlQ29sb3JDbGFzc2VzIH0gZnJvbSAnLi90aGVtZS1hMjRmZjFhZC5qcyc7XG5cbmxldCBSb3V0ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5pb25Sb3V0ZURhdGFDaGFuZ2VkID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25Sb3V0ZURhdGFDaGFuZ2VkXCIsIDcpO1xuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHBhdGggdGhhdCBuZWVkcyB0byBtYXRjaCBpbiBvcmRlciBmb3IgdGhpcyByb3V0ZSB0byBhcHBseS5cbiAgICAgKlxuICAgICAqIEFjY2VwdHMgcGF0aHMgc2ltaWxhciB0byBleHByZXNzanMgc28gdGhhdCB5b3UgY2FuIGRlZmluZSBwYXJhbWV0ZXJzXG4gICAgICogaW4gdGhlIHVybCAvZm9vLzpiYXIgd2hlcmUgYmFyIHdvdWxkIGJlIGF2YWlsYWJsZSBpbiBpbmNvbWluZyBwcm9wcy5cbiAgICAgKi9cbiAgICB0aGlzLnVybCA9ICcnO1xuICB9XG4gIG9uVXBkYXRlKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5pb25Sb3V0ZURhdGFDaGFuZ2VkLmVtaXQobmV3VmFsdWUpO1xuICB9XG4gIG9uQ29tcG9uZW50UHJvcHMobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgaWYgKG5ld1ZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrZXlzMSA9IG5ld1ZhbHVlID8gT2JqZWN0LmtleXMobmV3VmFsdWUpIDogW107XG4gICAgY29uc3Qga2V5czIgPSBvbGRWYWx1ZSA/IE9iamVjdC5rZXlzKG9sZFZhbHVlKSA6IFtdO1xuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vblVwZGF0ZShuZXdWYWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XG4gICAgICBpZiAobmV3VmFsdWVba2V5XSAhPT0gb2xkVmFsdWVba2V5XSkge1xuICAgICAgICB0aGlzLm9uVXBkYXRlKG5ld1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmlvblJvdXRlRGF0YUNoYW5nZWQuZW1pdCgpO1xuICB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJ1cmxcIjogW1wib25VcGRhdGVcIl0sXG4gICAgXCJjb21wb25lbnRcIjogW1wib25VcGRhdGVcIl0sXG4gICAgXCJjb21wb25lbnRQcm9wc1wiOiBbXCJvbkNvbXBvbmVudFByb3BzXCJdXG4gIH07IH1cbn07XG5cbmxldCBSb3V0ZVJlZGlyZWN0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmlvblJvdXRlUmVkaXJlY3RDaGFuZ2VkID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25Sb3V0ZVJlZGlyZWN0Q2hhbmdlZFwiLCA3KTtcbiAgfVxuICBwcm9wRGlkQ2hhbmdlKCkge1xuICAgIHRoaXMuaW9uUm91dGVSZWRpcmVjdENoYW5nZWQuZW1pdCgpO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuaW9uUm91dGVSZWRpcmVjdENoYW5nZWQuZW1pdCgpO1xuICB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJmcm9tXCI6IFtcInByb3BEaWRDaGFuZ2VcIl0sXG4gICAgXCJ0b1wiOiBbXCJwcm9wRGlkQ2hhbmdlXCJdXG4gIH07IH1cbn07XG5cbmNvbnN0IFJPVVRFUl9JTlRFTlRfTk9ORSA9ICdyb290JztcbmNvbnN0IFJPVVRFUl9JTlRFTlRfRk9SV0FSRCA9ICdmb3J3YXJkJztcbmNvbnN0IFJPVVRFUl9JTlRFTlRfQkFDSyA9ICdiYWNrJztcblxuLy8gSm9pbiB0aGUgbm9uIGVtcHR5IHNlZ21lbnRzIHdpdGggXCIvXCIuXG5jb25zdCBnZW5lcmF0ZVBhdGggPSAoc2VnbWVudHMpID0+IHtcbiAgY29uc3QgcGF0aCA9IHNlZ21lbnRzXG4gICAgLmZpbHRlcihzID0+IHMubGVuZ3RoID4gMClcbiAgICAuam9pbignLycpO1xuICByZXR1cm4gJy8nICsgcGF0aDtcbn07XG5jb25zdCBnZW5lcmF0ZVVybCA9IChzZWdtZW50cywgdXNlSGFzaCwgcXVlcnlTdHJpbmcpID0+IHtcbiAgbGV0IHVybCA9IGdlbmVyYXRlUGF0aChzZWdtZW50cyk7XG4gIGlmICh1c2VIYXNoKSB7XG4gICAgdXJsID0gJyMnICsgdXJsO1xuICB9XG4gIGlmIChxdWVyeVN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJsICs9ICc/JyArIHF1ZXJ5U3RyaW5nO1xuICB9XG4gIHJldHVybiB1cmw7XG59O1xuY29uc3Qgd3JpdGVQYXRoID0gKGhpc3RvcnksIHJvb3QsIHVzZUhhc2gsIHBhdGgsIGRpcmVjdGlvbiwgc3RhdGUsIHF1ZXJ5U3RyaW5nKSA9PiB7XG4gIGNvbnN0IHVybCA9IGdlbmVyYXRlVXJsKFsuLi5wYXJzZVBhdGgocm9vdCkuc2VnbWVudHMsIC4uLnBhdGhdLCB1c2VIYXNoLCBxdWVyeVN0cmluZyk7XG4gIGlmIChkaXJlY3Rpb24gPT09IFJPVVRFUl9JTlRFTlRfRk9SV0FSRCkge1xuICAgIGhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCAnJywgdXJsKTtcbiAgfVxuICBlbHNlIHtcbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgJycsIHVybCk7XG4gIH1cbn07XG5jb25zdCBjaGFpblRvUGF0aCA9IChjaGFpbikgPT4ge1xuICBjb25zdCBwYXRoID0gW107XG4gIGZvciAoY29uc3Qgcm91dGUgb2YgY2hhaW4pIHtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygcm91dGUucGF0aCkge1xuICAgICAgaWYgKHNlZ21lbnRbMF0gPT09ICc6Jykge1xuICAgICAgICBjb25zdCBwYXJhbSA9IHJvdXRlLnBhcmFtcyAmJiByb3V0ZS5wYXJhbXNbc2VnbWVudC5zbGljZSgxKV07XG4gICAgICAgIGlmICghcGFyYW0pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwYXRoLnB1c2gocGFyYW0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VnbWVudCAhPT0gJycpIHtcbiAgICAgICAgcGF0aC5wdXNoKHNlZ21lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG4vLyBSZW1vdmUgdGhlIHByZWZpeCBzZWdtZW50cyBmcm9tIHRoZSBwYXRoIHNlZ21lbnRzLlxuLy9cbi8vIFJldHVybjpcbi8vIC0gbnVsbCB3aGVuIHRoZSBwYXRoIHNlZ21lbnRzIGRvIG5vdCBzdGFydCB3aXRoIHRoZSBwYXNzZWQgcHJlZml4LFxuLy8gLSB0aGUgcGF0aCBzZWdtZW50cyBhZnRlciB0aGUgcHJlZml4IG90aGVyd2lzZS5cbmNvbnN0IHJlbW92ZVByZWZpeCA9IChwcmVmaXgsIHBhdGgpID0+IHtcbiAgaWYgKHByZWZpeC5sZW5ndGggPiBwYXRoLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwcmVmaXgubGVuZ3RoIDw9IDEgJiYgcHJlZml4WzBdID09PSAnJykge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHByZWZpeFtpXSAhPT0gcGF0aFtpXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gcHJlZml4Lmxlbmd0aCkge1xuICAgIHJldHVybiBbJyddO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKHByZWZpeC5sZW5ndGgpO1xufTtcbmNvbnN0IHJlYWRQYXRoID0gKGxvYywgcm9vdCwgdXNlSGFzaCkgPT4ge1xuICBjb25zdCBwcmVmaXggPSBwYXJzZVBhdGgocm9vdCkuc2VnbWVudHM7XG4gIGNvbnN0IHBhdGhuYW1lID0gdXNlSGFzaCA/IGxvYy5oYXNoLnNsaWNlKDEpIDogbG9jLnBhdGhuYW1lO1xuICBjb25zdCBwYXRoID0gcGFyc2VQYXRoKHBhdGhuYW1lKS5zZWdtZW50cztcbiAgcmV0dXJuIHJlbW92ZVByZWZpeChwcmVmaXgsIHBhdGgpO1xufTtcbi8vIFBhcnNlcyB0aGUgcGF0aCB0bzpcbi8vIC0gc2VnbWVudHMgYW4gYXJyYXkgb2YgJy8nIHNlcGFyYXRlZCBwYXJ0cyxcbi8vIC0gcXVlcnlTdHJpbmcgKHVuZGVmaW5lZCB3aGVuIG5vIHF1ZXJ5IHN0cmluZykuXG5jb25zdCBwYXJzZVBhdGggPSAocGF0aCkgPT4ge1xuICBsZXQgc2VnbWVudHMgPSBbJyddO1xuICBsZXQgcXVlcnlTdHJpbmc7XG4gIGlmIChwYXRoICE9IG51bGwpIHtcbiAgICBjb25zdCBxc1N0YXJ0ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKHFzU3RhcnQgPiAtMSkge1xuICAgICAgcXVlcnlTdHJpbmcgPSBwYXRoLnN1YnN0cihxc1N0YXJ0ICsgMSk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcXNTdGFydCk7XG4gICAgfVxuICAgIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpXG4gICAgICAubWFwKHMgPT4gcy50cmltKCkpXG4gICAgICAuZmlsdGVyKHMgPT4gcy5sZW5ndGggPiAwKTtcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZWdtZW50cyA9IFsnJ107XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHNlZ21lbnRzLCBxdWVyeVN0cmluZyB9O1xufTtcblxuY29uc3QgcHJpbnRSb3V0ZXMgPSAocm91dGVzKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXAoYFtpb24tY29yZV0gUk9VVEVTWyR7cm91dGVzLmxlbmd0aH1dYCk7XG4gIGZvciAoY29uc3QgY2hhaW4gb2Ygcm91dGVzKSB7XG4gICAgY29uc3QgcGF0aCA9IFtdO1xuICAgIGNoYWluLmZvckVhY2gociA9PiBwYXRoLnB1c2goLi4uci5wYXRoKSk7XG4gICAgY29uc3QgaWRzID0gY2hhaW4ubWFwKHIgPT4gci5pZCk7XG4gICAgY29uc29sZS5kZWJ1ZyhgJWMgJHtnZW5lcmF0ZVBhdGgocGF0aCl9YCwgJ2ZvbnQtd2VpZ2h0OiBib2xkOyBwYWRkaW5nLWxlZnQ6IDIwcHgnLCAnPT5cXHQnLCBgKCR7aWRzLmpvaW4oJywgJyl9KWApO1xuICB9XG4gIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbn07XG5jb25zdCBwcmludFJlZGlyZWN0cyA9IChyZWRpcmVjdHMpID0+IHtcbiAgY29uc29sZS5ncm91cChgW2lvbi1jb3JlXSBSRURJUkVDVFNbJHtyZWRpcmVjdHMubGVuZ3RofV1gKTtcbiAgZm9yIChjb25zdCByZWRpcmVjdCBvZiByZWRpcmVjdHMpIHtcbiAgICBpZiAocmVkaXJlY3QudG8pIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoJ0ZST006ICcsIGAkYyAke2dlbmVyYXRlUGF0aChyZWRpcmVjdC5mcm9tKX1gLCAnZm9udC13ZWlnaHQ6IGJvbGQnLCAnIFRPOiAnLCBgJGMgJHtnZW5lcmF0ZVBhdGgocmVkaXJlY3QudG8uc2VnbWVudHMpfWAsICdmb250LXdlaWdodDogYm9sZCcpO1xuICAgIH1cbiAgfVxuICBjb25zb2xlLmdyb3VwRW5kKCk7XG59O1xuXG5jb25zdCB3cml0ZU5hdlN0YXRlID0gYXN5bmMgKHJvb3QsIGNoYWluLCBkaXJlY3Rpb24sIGluZGV4LCBjaGFuZ2VkID0gZmFsc2UsIGFuaW1hdGlvbikgPT4ge1xuICB0cnkge1xuICAgIC8vIGZpbmQgbmV4dCBuYXZpZ2F0aW9uIG91dGxldCBpbiB0aGUgRE9NXG4gICAgY29uc3Qgb3V0bGV0ID0gc2VhcmNoTmF2Tm9kZShyb290KTtcbiAgICAvLyBtYWtlIHN1cmUgd2UgY2FuIGNvbnRpbnVlIGludGVyYWN0aW5nIHRoZSBET00sIG90aGVyd2lzZSBhYm9ydFxuICAgIGlmIChpbmRleCA+PSBjaGFpbi5sZW5ndGggfHwgIW91dGxldCkge1xuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gY29tcG9uZW50T25SZWFkeShvdXRsZXQsIHJlc29sdmUpKTtcbiAgICBjb25zdCByb3V0ZSA9IGNoYWluW2luZGV4XTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvdXRsZXQuc2V0Um91dGVJZChyb3V0ZS5pZCwgcm91dGUucGFyYW1zLCBkaXJlY3Rpb24sIGFuaW1hdGlvbik7XG4gICAgLy8gaWYgdGhlIG91dGxldCBjaGFuZ2VkIHRoZSBwYWdlLCByZXNldCBuYXZpZ2F0aW9uIHRvIG5ldXRyYWwgKG5vIGRpcmVjdGlvbilcbiAgICAvLyB0aGlzIG1lYW5zIG5lc3RlZCBvdXRsZXRzIHdpbGwgbm90IGFuaW1hdGVcbiAgICBpZiAocmVzdWx0LmNoYW5nZWQpIHtcbiAgICAgIGRpcmVjdGlvbiA9IFJPVVRFUl9JTlRFTlRfTk9ORTtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyByZWN1cnNpdmVseSBzZXQgbmVzdGVkIG91dGxldHNcbiAgICBjaGFuZ2VkID0gYXdhaXQgd3JpdGVOYXZTdGF0ZShyZXN1bHQuZWxlbWVudCwgY2hhaW4sIGRpcmVjdGlvbiwgaW5kZXggKyAxLCBjaGFuZ2VkLCBhbmltYXRpb24pO1xuICAgIC8vIG9uY2UgYWxsIG5lc3RlZCBvdXRsZXRzIGFyZSB2aXNpYmxlIGxldCdzIG1ha2UgdGhlIHBhcmVudCB2aXNpYmxlIHRvbyxcbiAgICAvLyB1c2luZyBtYXJrVmlzaWJsZSBwcmV2ZW50cyBmbGlja2VyaW5nXG4gICAgaWYgKHJlc3VsdC5tYXJrVmlzaWJsZSkge1xuICAgICAgYXdhaXQgcmVzdWx0Lm1hcmtWaXNpYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5jb25zdCByZWFkTmF2U3RhdGUgPSBhc3luYyAocm9vdCkgPT4ge1xuICBjb25zdCBpZHMgPSBbXTtcbiAgbGV0IG91dGxldDtcbiAgbGV0IG5vZGUgPSByb290O1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc3RhbnQtY29uZGl0aW9uXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgb3V0bGV0ID0gc2VhcmNoTmF2Tm9kZShub2RlKTtcbiAgICBpZiAob3V0bGV0KSB7XG4gICAgICBjb25zdCBpZCA9IGF3YWl0IG91dGxldC5nZXRSb3V0ZUlkKCk7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgbm9kZSA9IGlkLmVsZW1lbnQ7XG4gICAgICAgIGlkLmVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlkcy5wdXNoKGlkKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaWRzLCBvdXRsZXQgfTtcbn07XG5jb25zdCB3YWl0VW50aWxOYXZOb2RlID0gKCkgPT4ge1xuICBpZiAoc2VhcmNoTmF2Tm9kZShkb2N1bWVudC5ib2R5KSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2lvbk5hdldpbGxMb2FkJywgcmVzb2x2ZSwgeyBvbmNlOiB0cnVlIH0pO1xuICB9KTtcbn07XG5jb25zdCBRVUVSWSA9ICc6bm90KFtuby1yb3V0ZXJdKSBpb24tbmF2LCA6bm90KFtuby1yb3V0ZXJdKSBpb24tdGFicywgOm5vdChbbm8tcm91dGVyXSkgaW9uLXJvdXRlci1vdXRsZXQnO1xuY29uc3Qgc2VhcmNoTmF2Tm9kZSA9IChyb290KSA9PiB7XG4gIGlmICghcm9vdCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHJvb3QubWF0Y2hlcyhRVUVSWSkpIHtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuICBjb25zdCBvdXRsZXQgPSByb290LnF1ZXJ5U2VsZWN0b3IoUVVFUlkpO1xuICByZXR1cm4gb3V0bGV0ICE9PSBudWxsICYmIG91dGxldCAhPT0gdm9pZCAwID8gb3V0bGV0IDogdW5kZWZpbmVkO1xufTtcblxuLy8gUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiByZWRpcmVjdCBtYXRjaGVzIHRoZSBnaXZlbiBwYXRoIHNlZ21lbnRzLlxuLy9cbi8vIEEgcmVkaXJlY3QgbWF0Y2hlcyB3aGVuIHRoZSBzZWdtZW50cyBvZiB0aGUgcGF0aCBhbmQgcmVkaXJlY3QuZnJvbSBhcmUgZXF1YWwuXG4vLyBOb3RlIHRoYXQgc2VnbWVudHMgYXJlIG9ubHkgY2hlY2tlZCB1bnRpbCByZWRpcmVjdC5mcm9tIGNvbnRhaW5zIGEgJyonIHdoaWNoIG1hdGNoZXMgYW55IHBhdGggc2VnbWVudC5cbi8vIFRoZSBwYXRoIFsnc29tZScsICdwYXRoJywgJ3RvJywgJ3BhZ2UnXSBtYXRjaGVzIGJvdGggWydzb21lJywgJ3BhdGgnLCAndG8nLCAncGFnZSddIGFuZCBbJ3NvbWUnLCAncGF0aCcsICcqJ10uXG5jb25zdCBtYXRjaGVzUmVkaXJlY3QgPSAocGF0aCwgcmVkaXJlY3QpID0+IHtcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gcmVkaXJlY3Q7XG4gIGlmICh0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmcm9tLmxlbmd0aCA+IHBhdGgubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZnJvbS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGV4cGVjdGVkID0gZnJvbVtpXTtcbiAgICBpZiAoZXhwZWN0ZWQgPT09ICcqJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChleHBlY3RlZCAhPT0gcGF0aFtpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbS5sZW5ndGggPT09IHBhdGgubGVuZ3RoO1xufTtcbi8vIFJldHVybnMgdGhlIGZpcnN0IHJlZGlyZWN0IG1hdGNoaW5nIHRoZSBwYXRoIHNlZ21lbnRzIG9yIHVuZGVmaW5lZCB3aGVuIG5vIG1hdGNoIGZvdW5kLlxuY29uc3QgZmluZFJvdXRlUmVkaXJlY3QgPSAocGF0aCwgcmVkaXJlY3RzKSA9PiB7XG4gIHJldHVybiByZWRpcmVjdHMuZmluZChyZWRpcmVjdCA9PiBtYXRjaGVzUmVkaXJlY3QocGF0aCwgcmVkaXJlY3QpKTtcbn07XG5jb25zdCBtYXRjaGVzSURzID0gKGlkcywgY2hhaW4pID0+IHtcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oaWRzLmxlbmd0aCwgY2hhaW4ubGVuZ3RoKTtcbiAgbGV0IHNjb3JlID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHJvdXRlSWQgPSBpZHNbaV07XG4gICAgY29uc3Qgcm91dGVDaGFpbiA9IGNoYWluW2ldO1xuICAgIC8vIFNraXAgcmVzdWx0cyB3aGVyZSB0aGUgcm91dGUgaWQgZG9lcyBub3QgbWF0Y2ggdGhlIGNoYWluIGF0IHRoZSBzYW1lIGluZGV4XG4gICAgaWYgKHJvdXRlSWQuaWQudG9Mb3dlckNhc2UoKSAhPT0gcm91dGVDaGFpbi5pZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChyb3V0ZUlkLnBhcmFtcykge1xuICAgICAgY29uc3Qgcm91dGVJZFBhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlSWQucGFyYW1zKTtcbiAgICAgIC8qKlxuICAgICAgICogT25seSBjb21wYXJlIHJvdXRlcyB3aXRoIHRoZSBjaGFpbiB0aGF0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHBhcmFtZXRlcnMuXG4gICAgICAgKi9cbiAgICAgIGlmIChyb3V0ZUlkUGFyYW1zLmxlbmd0aCA9PT0gcm91dGVDaGFpbi5wYXRoLmxlbmd0aCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwcyB0aGUgcm91dGUncyBwYXJhbXMgaW50byBhIHBhdGggYmFzZWQgb24gdGhlIHBhdGggdmFyaWFibGUgbmFtZXMsXG4gICAgICAgICAqIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgcm91dGUgY2hhaW4gZm9ybWF0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBCZWZvcmU6XG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIHtcbiAgICAgICAgICogIHBhcmFtczoge1xuICAgICAgICAgKiAgICBzMTogJ2EnLFxuICAgICAgICAgKiAgICBzMjogJ2InXG4gICAgICAgICAqICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEFmdGVyOlxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBbJzpzMScsJzpzMiddXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcGF0aFdpdGhQYXJhbXMgPSByb3V0ZUlkUGFyYW1zLm1hcChrZXkgPT4gYDoke2tleX1gKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXRoV2l0aFBhcmFtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIC8vIFNraXAgcmVzdWx0cyB3aGVyZSB0aGUgcGF0aCB2YXJpYWJsZSBpcyBub3QgYSBtYXRjaFxuICAgICAgICAgIGlmIChwYXRoV2l0aFBhcmFtc1tqXS50b0xvd2VyQ2FzZSgpICE9PSByb3V0ZUNoYWluLnBhdGhbal0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBXZWlnaHQgcGF0aCBtYXRjaGVzIGZvciB0aGUgc2FtZSBpbmRleCBoaWdoZXIuXG4gICAgICAgICAgc2NvcmUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZWlnaHQgaWQgbWF0Y2hlc1xuICAgIHNjb3JlKys7XG4gIH1cbiAgcmV0dXJuIHNjb3JlO1xufTtcbmNvbnN0IG1hdGNoZXNQYXRoID0gKGlucHV0UGF0aCwgY2hhaW4pID0+IHtcbiAgY29uc3Qgc2VnbWVudHMgPSBuZXcgUm91dGVyU2VnbWVudHMoaW5wdXRQYXRoKTtcbiAgbGV0IG1hdGNoZXNEZWZhdWx0ID0gZmFsc2U7XG4gIGxldCBhbGxwYXJhbXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhaW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwYXRoID0gY2hhaW5baV0ucGF0aDtcbiAgICBpZiAocGF0aFswXSA9PT0gJycpIHtcbiAgICAgIG1hdGNoZXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aCkge1xuICAgICAgICBjb25zdCBkYXRhID0gc2VnbWVudHMubmV4dCgpO1xuICAgICAgICAvLyBkYXRhIHBhcmFtXG4gICAgICAgIGlmIChzZWdtZW50WzBdID09PSAnOicpIHtcbiAgICAgICAgICBpZiAoZGF0YSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhbGxwYXJhbXMgPSBhbGxwYXJhbXMgfHwgW107XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gYWxscGFyYW1zW2ldIHx8IChhbGxwYXJhbXNbaV0gPSB7fSk7XG4gICAgICAgICAgcGFyYW1zW3NlZ21lbnQuc2xpY2UoMSldID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBzZWdtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hdGNoZXNEZWZhdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSAobWF0Y2hlc0RlZmF1bHQpXG4gICAgPyBtYXRjaGVzRGVmYXVsdCA9PT0gKHNlZ21lbnRzLm5leHQoKSA9PT0gJycpXG4gICAgOiB0cnVlO1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoYWxscGFyYW1zKSB7XG4gICAgcmV0dXJuIGNoYWluLm1hcCgocm91dGUsIGkpID0+ICh7XG4gICAgICBpZDogcm91dGUuaWQsXG4gICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgcGFyYW1zOiBtZXJnZVBhcmFtcyhyb3V0ZS5wYXJhbXMsIGFsbHBhcmFtc1tpXSksXG4gICAgICBiZWZvcmVFbnRlcjogcm91dGUuYmVmb3JlRW50ZXIsXG4gICAgICBiZWZvcmVMZWF2ZTogcm91dGUuYmVmb3JlTGVhdmVcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIGNoYWluO1xufTtcbi8vIE1lcmdlcyB0aGUgcm91dGUgcGFyYW1ldGVyIG9iamVjdHMuXG4vLyBSZXR1cm5zIHVuZGVmaW5lZCB3aGVuIGJvdGggcGFyYW1ldGVycyBhcmUgdW5kZWZpbmVkLlxuY29uc3QgbWVyZ2VQYXJhbXMgPSAoYSwgYikgPT4ge1xuICByZXR1cm4gYSB8fCBiID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhKSwgYikgOiB1bmRlZmluZWQ7XG59O1xuY29uc3Qgcm91dGVySURzVG9DaGFpbiA9IChpZHMsIGNoYWlucykgPT4ge1xuICBsZXQgbWF0Y2ggPSBudWxsO1xuICBsZXQgbWF4TWF0Y2hlcyA9IDA7XG4gIGZvciAoY29uc3QgY2hhaW4gb2YgY2hhaW5zKSB7XG4gICAgY29uc3Qgc2NvcmUgPSBtYXRjaGVzSURzKGlkcywgY2hhaW4pO1xuICAgIGlmIChzY29yZSA+IG1heE1hdGNoZXMpIHtcbiAgICAgIG1hdGNoID0gY2hhaW47XG4gICAgICBtYXhNYXRjaGVzID0gc2NvcmU7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaCkge1xuICAgIHJldHVybiBtYXRjaC5tYXAoKHJvdXRlLCBpKSA9PiAoe1xuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgIHBhcmFtczogbWVyZ2VQYXJhbXMocm91dGUucGFyYW1zLCBpZHNbaV0gJiYgaWRzW2ldLnBhcmFtcylcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3Qgcm91dGVyUGF0aFRvQ2hhaW4gPSAocGF0aCwgY2hhaW5zKSA9PiB7XG4gIGxldCBtYXRjaCA9IG51bGw7XG4gIGxldCBtYXRjaGVzID0gMDtcbiAgZm9yIChjb25zdCBjaGFpbiBvZiBjaGFpbnMpIHtcbiAgICBjb25zdCBtYXRjaGVkQ2hhaW4gPSBtYXRjaGVzUGF0aChwYXRoLCBjaGFpbik7XG4gICAgaWYgKG1hdGNoZWRDaGFpbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2NvcmUgPSBjb21wdXRlUHJpb3JpdHkobWF0Y2hlZENoYWluKTtcbiAgICAgIGlmIChzY29yZSA+IG1hdGNoZXMpIHtcbiAgICAgICAgbWF0Y2hlcyA9IHNjb3JlO1xuICAgICAgICBtYXRjaCA9IG1hdGNoZWRDaGFpbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoO1xufTtcbmNvbnN0IGNvbXB1dGVQcmlvcml0eSA9IChjaGFpbikgPT4ge1xuICBsZXQgc2NvcmUgPSAxO1xuICBsZXQgbGV2ZWwgPSAxO1xuICBmb3IgKGNvbnN0IHJvdXRlIG9mIGNoYWluKSB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHJvdXRlLnBhdGgpIHtcbiAgICAgIGlmIChwYXRoWzBdID09PSAnOicpIHtcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5wb3coMSwgbGV2ZWwpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocGF0aCAhPT0gJycpIHtcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5wb3coMiwgbGV2ZWwpO1xuICAgICAgfVxuICAgICAgbGV2ZWwrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjb3JlO1xufTtcbmNsYXNzIFJvdXRlclNlZ21lbnRzIHtcbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHRoaXMucGF0aCA9IHBhdGguc2xpY2UoKTtcbiAgfVxuICBuZXh0KCkge1xuICAgIGlmICh0aGlzLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aC5zaGlmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuY29uc3QgcmVhZFByb3AgPSAoZWwsIHByb3ApID0+IHtcbiAgaWYgKHByb3AgaW4gZWwpIHtcbiAgICByZXR1cm4gZWxbcHJvcF07XG4gIH1cbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZShwcm9wKSkge1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUocHJvcCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgcmVhZFJlZGlyZWN0cyA9IChyb290KSA9PiB7XG4gIHJldHVybiBBcnJheS5mcm9tKHJvb3QuY2hpbGRyZW4pXG4gICAgLmZpbHRlcihlbCA9PiBlbC50YWdOYW1lID09PSAnSU9OLVJPVVRFLVJFRElSRUNUJylcbiAgICAubWFwKGVsID0+IHtcbiAgICBjb25zdCB0byA9IHJlYWRQcm9wKGVsLCAndG8nKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbTogcGFyc2VQYXRoKHJlYWRQcm9wKGVsLCAnZnJvbScpKS5zZWdtZW50cyxcbiAgICAgIHRvOiB0byA9PSBudWxsID8gdW5kZWZpbmVkIDogcGFyc2VQYXRoKHRvKSxcbiAgICB9O1xuICB9KTtcbn07XG5jb25zdCByZWFkUm91dGVzID0gKHJvb3QpID0+IHtcbiAgcmV0dXJuIGZsYXR0ZW5Sb3V0ZXJUcmVlKHJlYWRSb3V0ZU5vZGVzKHJvb3QpKTtcbn07XG5jb25zdCByZWFkUm91dGVOb2RlcyA9IChub2RlKSA9PiB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5vZGUuY2hpbGRyZW4pXG4gICAgLmZpbHRlcihlbCA9PiBlbC50YWdOYW1lID09PSAnSU9OLVJPVVRFJyAmJiBlbC5jb21wb25lbnQpXG4gICAgLm1hcChlbCA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gcmVhZFByb3AoZWwsICdjb21wb25lbnQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGFyc2VQYXRoKHJlYWRQcm9wKGVsLCAndXJsJykpLnNlZ21lbnRzLFxuICAgICAgaWQ6IGNvbXBvbmVudC50b0xvd2VyQ2FzZSgpLFxuICAgICAgcGFyYW1zOiBlbC5jb21wb25lbnRQcm9wcyxcbiAgICAgIGJlZm9yZUxlYXZlOiBlbC5iZWZvcmVMZWF2ZSxcbiAgICAgIGJlZm9yZUVudGVyOiBlbC5iZWZvcmVFbnRlcixcbiAgICAgIGNoaWxkcmVuOiByZWFkUm91dGVOb2RlcyhlbClcbiAgICB9O1xuICB9KTtcbn07XG5jb25zdCBmbGF0dGVuUm91dGVyVHJlZSA9IChub2RlcykgPT4ge1xuICBjb25zdCBjaGFpbnMgPSBbXTtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgZmxhdHRlbk5vZGUoW10sIGNoYWlucywgbm9kZSk7XG4gIH1cbiAgcmV0dXJuIGNoYWlucztcbn07XG5jb25zdCBmbGF0dGVuTm9kZSA9IChjaGFpbiwgY2hhaW5zLCBub2RlKSA9PiB7XG4gIGNoYWluID0gY2hhaW4uc2xpY2UoKTtcbiAgY2hhaW4ucHVzaCh7XG4gICAgaWQ6IG5vZGUuaWQsXG4gICAgcGF0aDogbm9kZS5wYXRoLFxuICAgIHBhcmFtczogbm9kZS5wYXJhbXMsXG4gICAgYmVmb3JlTGVhdmU6IG5vZGUuYmVmb3JlTGVhdmUsXG4gICAgYmVmb3JlRW50ZXI6IG5vZGUuYmVmb3JlRW50ZXJcbiAgfSk7XG4gIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgIGNoYWlucy5wdXNoKGNoYWluKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgZmxhdHRlbk5vZGUoY2hhaW4sIGNoYWlucywgY2hpbGQpO1xuICB9XG59O1xuXG5sZXQgUm91dGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmlvblJvdXRlV2lsbENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiaW9uUm91dGVXaWxsQ2hhbmdlXCIsIDcpO1xuICAgIHRoaXMuaW9uUm91dGVEaWRDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvblJvdXRlRGlkQ2hhbmdlXCIsIDcpO1xuICAgIHRoaXMucHJldmlvdXNQYXRoID0gbnVsbDtcbiAgICB0aGlzLmJ1c3kgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gMDtcbiAgICB0aGlzLmxhc3RTdGF0ZSA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIHJvb3QgcGF0aCB0byB1c2Ugd2hlbiBtYXRjaGluZyBVUkxzLiBCeSBkZWZhdWx0LCB0aGlzIGlzIHNldCB0byBcIi9cIiwgYnV0IHlvdSBjYW4gc3BlY2lmeVxuICAgICAqIGFuIGFsdGVybmF0ZSBwcmVmaXggZm9yIGFsbCBVUkwgcGF0aHMuXG4gICAgICovXG4gICAgdGhpcy5yb290ID0gJy8nO1xuICAgIC8qKlxuICAgICAqIFRoZSByb3V0ZXIgY2FuIHdvcmsgaW4gdHdvIFwibW9kZXNcIjpcbiAgICAgKiAtIFdpdGggaGFzaDogYC9pbmRleC5odG1sIy9wYXRoL3RvL3BhZ2VgXG4gICAgICogLSBXaXRob3V0IGhhc2g6IGAvcGF0aC90by9wYWdlYFxuICAgICAqXG4gICAgICogVXNpbmcgb25lIG9yIGFub3RoZXIgbWlnaHQgZGVwZW5kIGluIHRoZSByZXF1aXJlbWVudHMgb2YgeW91ciBhcHAgYW5kL29yIHdoZXJlIGl0J3MgZGVwbG95ZWQuXG4gICAgICpcbiAgICAgKiBVc3VhbGx5IFwiaGFzaC1sZXNzXCIgbmF2aWdhdGlvbiB3b3JrcyBiZXR0ZXIgZm9yIFNFTyBhbmQgaXQncyBtb3JlIHVzZXIgZnJpZW5kbHkgdG9vLCBidXQgaXQgbWlnaHRcbiAgICAgKiByZXF1aXJlcyBhZGRpdGlvbmFsIHNlcnZlci1zaWRlIGNvbmZpZ3VyYXRpb24gaW4gb3JkZXIgdG8gcHJvcGVybHkgd29yay5cbiAgICAgKlxuICAgICAqIE9uIHRoZSBvdGhlciBzaWRlIGhhc2gtbmF2aWdhdGlvbiBpcyBtdWNoIGVhc2llciB0byBkZXBsb3ksIGl0IGV2ZW4gd29ya3Mgb3ZlciB0aGUgZmlsZSBwcm90b2NvbC5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgLCBjaGFuZ2UgdG8gYGZhbHNlYCB0byBhbGxvdyBoYXNoLWxlc3MgVVJMcy5cbiAgICAgKi9cbiAgICB0aGlzLnVzZUhhc2ggPSB0cnVlO1xuICB9XG4gIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIGF3YWl0IHdhaXRVbnRpbE5hdk5vZGUoKTtcbiAgICBjb25zdCBjYW5Qcm9jZWVkID0gYXdhaXQgdGhpcy5ydW5HdWFyZHModGhpcy5nZXRQYXRoKCkpO1xuICAgIGlmIChjYW5Qcm9jZWVkICE9PSB0cnVlKSB7XG4gICAgICBpZiAodHlwZW9mIGNhblByb2NlZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHsgcmVkaXJlY3QgfSA9IGNhblByb2NlZWQ7XG4gICAgICAgIGNvbnN0IHBhdGggPSBwYXJzZVBhdGgocmVkaXJlY3QpO1xuICAgICAgICB0aGlzLnNldFBhdGgocGF0aC5zZWdtZW50cywgUk9VVEVSX0lOVEVOVF9OT05FLCBwYXRoLnF1ZXJ5U3RyaW5nKTtcbiAgICAgICAgYXdhaXQgdGhpcy53cml0ZU5hdlN0YXRlUm9vdChwYXRoLnNlZ21lbnRzLCBST1VURVJfSU5URU5UX05PTkUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMub25Sb3V0ZXNDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2lvblJvdXRlUmVkaXJlY3RDaGFuZ2VkJywgZGVib3VuY2UodGhpcy5vblJlZGlyZWN0Q2hhbmdlZC5iaW5kKHRoaXMpLCAxMCkpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpb25Sb3V0ZURhdGFDaGFuZ2VkJywgZGVib3VuY2UodGhpcy5vblJvdXRlc0NoYW5nZWQuYmluZCh0aGlzKSwgMTAwKSk7XG4gIH1cbiAgYXN5bmMgb25Qb3BTdGF0ZSgpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmhpc3RvcnlEaXJlY3Rpb24oKTtcbiAgICBsZXQgc2VnbWVudHMgPSB0aGlzLmdldFBhdGgoKTtcbiAgICBjb25zdCBjYW5Qcm9jZWVkID0gYXdhaXQgdGhpcy5ydW5HdWFyZHMoc2VnbWVudHMpO1xuICAgIGlmIChjYW5Qcm9jZWVkICE9PSB0cnVlKSB7XG4gICAgICBpZiAodHlwZW9mIGNhblByb2NlZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHNlZ21lbnRzID0gcGFyc2VQYXRoKGNhblByb2NlZWQucmVkaXJlY3QpLnNlZ21lbnRzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud3JpdGVOYXZTdGF0ZVJvb3Qoc2VnbWVudHMsIGRpcmVjdGlvbik7XG4gIH1cbiAgb25CYWNrQnV0dG9uKGV2KSB7XG4gICAgZXYuZGV0YWlsLnJlZ2lzdGVyKDAsIHByb2Nlc3NOZXh0SGFuZGxlciA9PiB7XG4gICAgICB0aGlzLmJhY2soKTtcbiAgICAgIHByb2Nlc3NOZXh0SGFuZGxlcigpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgY2FuVHJhbnNpdGlvbigpIHtcbiAgICBjb25zdCBjYW5Qcm9jZWVkID0gYXdhaXQgdGhpcy5ydW5HdWFyZHMoKTtcbiAgICBpZiAoY2FuUHJvY2VlZCAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYW5Qcm9jZWVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gY2FuUHJvY2VlZC5yZWRpcmVjdDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byB0aGUgc3BlY2lmaWVkIFVSTC5cbiAgICpcbiAgICogQHBhcmFtIHVybCBUaGUgdXJsIHRvIG5hdmlnYXRlIHRvLlxuICAgKiBAcGFyYW0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi4gRGVmYXVsdHMgdG8gYFwiZm9yd2FyZFwiYC5cbiAgICovXG4gIGFzeW5jIHB1c2godXJsLCBkaXJlY3Rpb24gPSAnZm9yd2FyZCcsIGFuaW1hdGlvbikge1xuICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICB1cmwgPSAobmV3IFVSTCh1cmwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKSkucGF0aG5hbWU7XG4gICAgfVxuICAgIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHVybCk7XG4gICAgY29uc3QgY2FuUHJvY2VlZCA9IGF3YWl0IHRoaXMucnVuR3VhcmRzKHBhcnNlZFBhdGguc2VnbWVudHMpO1xuICAgIGlmIChjYW5Qcm9jZWVkICE9PSB0cnVlKSB7XG4gICAgICBpZiAodHlwZW9mIGNhblByb2NlZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHBhcnNlZFBhdGggPSBwYXJzZVBhdGgoY2FuUHJvY2VlZC5yZWRpcmVjdCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldFBhdGgocGFyc2VkUGF0aC5zZWdtZW50cywgZGlyZWN0aW9uLCBwYXJzZWRQYXRoLnF1ZXJ5U3RyaW5nKTtcbiAgICByZXR1cm4gdGhpcy53cml0ZU5hdlN0YXRlUm9vdChwYXJzZWRQYXRoLnNlZ21lbnRzLCBkaXJlY3Rpb24sIGFuaW1hdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIEdvIGJhY2sgdG8gcHJldmlvdXMgcGFnZSBpbiB0aGUgd2luZG93Lmhpc3RvcnkuXG4gICAqL1xuICBiYWNrKCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMud2FpdFByb21pc2UpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgcHJpbnREZWJ1ZygpIHtcbiAgICBwcmludFJvdXRlcyhyZWFkUm91dGVzKHRoaXMuZWwpKTtcbiAgICBwcmludFJlZGlyZWN0cyhyZWFkUmVkaXJlY3RzKHRoaXMuZWwpKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIG5hdkNoYW5nZWQoZGlyZWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuYnVzeSkge1xuICAgICAgY29uc29sZS53YXJuKCdbaW9uLXJvdXRlcl0gcm91dGVyIGlzIGJ1c3ksIG5hdkNoYW5nZWQgd2FzIGNhbmNlbGxlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IGlkcywgb3V0bGV0IH0gPSBhd2FpdCByZWFkTmF2U3RhdGUod2luZG93LmRvY3VtZW50LmJvZHkpO1xuICAgIGNvbnN0IHJvdXRlcyA9IHJlYWRSb3V0ZXModGhpcy5lbCk7XG4gICAgY29uc3QgY2hhaW4gPSByb3V0ZXJJRHNUb0NoYWluKGlkcywgcm91dGVzKTtcbiAgICBpZiAoIWNoYWluKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tpb24tcm91dGVyXSBubyBtYXRjaGluZyBVUkwgZm9yICcsIGlkcy5tYXAoaSA9PiBpLmlkKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBjaGFpblRvUGF0aChjaGFpbik7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tpb24tcm91dGVyXSByb3V0ZXIgY291bGQgbm90IG1hdGNoIHBhdGggYmVjYXVzZSBzb21lIHJlcXVpcmVkIHBhcmFtIGlzIG1pc3NpbmcnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zZXRQYXRoKHBhdGgsIGRpcmVjdGlvbik7XG4gICAgYXdhaXQgdGhpcy5zYWZlV3JpdGVOYXZTdGF0ZShvdXRsZXQsIGNoYWluLCBST1VURVJfSU5URU5UX05PTkUsIHBhdGgsIG51bGwsIGlkcy5sZW5ndGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIFRoaXMgaGFuZGxlciBnZXRzIGNhbGxlZCB3aGVuIGEgYGlvbi1yb3V0ZS1yZWRpcmVjdGAgY29tcG9uZW50IGlzIGFkZGVkIHRvIHRoZSBET00gb3IgaWYgdGhlIGZyb20gb3IgdG8gcHJvcGVydHkgb2Ygc3VjaCBub2RlIGNoYW5nZXMuXG4gIG9uUmVkaXJlY3RDaGFuZ2VkKCkge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLmdldFBhdGgoKTtcbiAgICBpZiAocGF0aCAmJiBmaW5kUm91dGVSZWRpcmVjdChwYXRoLCByZWFkUmVkaXJlY3RzKHRoaXMuZWwpKSkge1xuICAgICAgdGhpcy53cml0ZU5hdlN0YXRlUm9vdChwYXRoLCBST1VURVJfSU5URU5UX05PTkUpO1xuICAgIH1cbiAgfVxuICAvLyBUaGlzIGhhbmRsZXIgZ2V0cyBjYWxsZWQgd2hlbiBhIGBpb24tcm91dGVgIGNvbXBvbmVudCBpcyBhZGRlZCB0byB0aGUgRE9NIG9yIGlmIHRoZSBmcm9tIG9yIHRvIHByb3BlcnR5IG9mIHN1Y2ggbm9kZSBjaGFuZ2VzLlxuICBvblJvdXRlc0NoYW5nZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMud3JpdGVOYXZTdGF0ZVJvb3QodGhpcy5nZXRQYXRoKCksIFJPVVRFUl9JTlRFTlRfTk9ORSk7XG4gIH1cbiAgaGlzdG9yeURpcmVjdGlvbigpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgd2luID0gd2luZG93O1xuICAgIGlmICh3aW4uaGlzdG9yeS5zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGF0ZSsrO1xuICAgICAgd2luLmhpc3RvcnkucmVwbGFjZVN0YXRlKHRoaXMuc3RhdGUsIHdpbi5kb2N1bWVudC50aXRsZSwgKF9hID0gd2luLmRvY3VtZW50LmxvY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHJlZik7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gd2luLmhpc3Rvcnkuc3RhdGU7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gdGhpcy5sYXN0U3RhdGU7XG4gICAgdGhpcy5sYXN0U3RhdGUgPSBzdGF0ZTtcbiAgICBpZiAoc3RhdGUgPiBsYXN0U3RhdGUgfHwgKHN0YXRlID49IGxhc3RTdGF0ZSAmJiBsYXN0U3RhdGUgPiAwKSkge1xuICAgICAgcmV0dXJuIFJPVVRFUl9JTlRFTlRfRk9SV0FSRDtcbiAgICB9XG4gICAgaWYgKHN0YXRlIDwgbGFzdFN0YXRlKSB7XG4gICAgICByZXR1cm4gUk9VVEVSX0lOVEVOVF9CQUNLO1xuICAgIH1cbiAgICByZXR1cm4gUk9VVEVSX0lOVEVOVF9OT05FO1xuICB9XG4gIGFzeW5jIHdyaXRlTmF2U3RhdGVSb290KHBhdGgsIGRpcmVjdGlvbiwgYW5pbWF0aW9uKSB7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbaW9uLXJvdXRlcl0gVVJMIGlzIG5vdCBwYXJ0IG9mIHRoZSByb3V0aW5nIHNldCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBsb29rdXAgcmVkaXJlY3QgcnVsZVxuICAgIGNvbnN0IHJlZGlyZWN0cyA9IHJlYWRSZWRpcmVjdHModGhpcy5lbCk7XG4gICAgY29uc3QgcmVkaXJlY3QgPSBmaW5kUm91dGVSZWRpcmVjdChwYXRoLCByZWRpcmVjdHMpO1xuICAgIGxldCByZWRpcmVjdEZyb20gPSBudWxsO1xuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgY29uc3QgeyBzZWdtZW50cywgcXVlcnlTdHJpbmcgfSA9IHJlZGlyZWN0LnRvO1xuICAgICAgdGhpcy5zZXRQYXRoKHNlZ21lbnRzLCBkaXJlY3Rpb24sIHF1ZXJ5U3RyaW5nKTtcbiAgICAgIHJlZGlyZWN0RnJvbSA9IHJlZGlyZWN0LmZyb207XG4gICAgICBwYXRoID0gc2VnbWVudHM7XG4gICAgfVxuICAgIC8vIGxvb2t1cCByb3V0ZSBjaGFpblxuICAgIGNvbnN0IHJvdXRlcyA9IHJlYWRSb3V0ZXModGhpcy5lbCk7XG4gICAgY29uc3QgY2hhaW4gPSByb3V0ZXJQYXRoVG9DaGFpbihwYXRoLCByb3V0ZXMpO1xuICAgIGlmICghY2hhaW4pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tpb24tcm91dGVyXSB0aGUgcGF0aCBkb2VzIG5vdCBtYXRjaCBhbnkgcm91dGUnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gd3JpdGUgRE9NIGdpdmVcbiAgICByZXR1cm4gdGhpcy5zYWZlV3JpdGVOYXZTdGF0ZShkb2N1bWVudC5ib2R5LCBjaGFpbiwgZGlyZWN0aW9uLCBwYXRoLCByZWRpcmVjdEZyb20sIDAsIGFuaW1hdGlvbik7XG4gIH1cbiAgYXN5bmMgc2FmZVdyaXRlTmF2U3RhdGUobm9kZSwgY2hhaW4sIGRpcmVjdGlvbiwgcGF0aCwgcmVkaXJlY3RGcm9tLCBpbmRleCA9IDAsIGFuaW1hdGlvbikge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMubG9jaygpO1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNoYW5nZWQgPSBhd2FpdCB0aGlzLndyaXRlTmF2U3RhdGUobm9kZSwgY2hhaW4sIGRpcmVjdGlvbiwgcGF0aCwgcmVkaXJlY3RGcm9tLCBpbmRleCwgYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICAgIHVubG9jaygpO1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIGFzeW5jIGxvY2soKSB7XG4gICAgY29uc3QgcCA9IHRoaXMud2FpdFByb21pc2U7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgdGhpcy53YWl0UHJvbWlzZSA9IG5ldyBQcm9taXNlKHIgPT4gcmVzb2x2ZSA9IHIpO1xuICAgIGlmIChwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGF3YWl0IHA7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlO1xuICB9XG4gIC8vIEV4ZWN1dGVzIHRoZSBiZWZvcmVMZWF2ZSBob29rIG9mIHRoZSBzb3VyY2Ugcm91dGUgYW5kIHRoZSBiZWZvcmVFbnRlciBob29rIG9mIHRoZSB0YXJnZXQgcm91dGUgaWYgdGhleSBleGlzdC5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYmVmb3JlTGVhdmUgaG9vayBkb2VzIG5vdCByZXR1cm4gdHJ1ZSAodG8gYWxsb3cgbmF2aWdhdGluZykgdGhlbiB0aGF0IHZhbHVlIGlzIHJldHVybmVkIGVhcmx5IGFuZCB0aGUgYmVmb3JlRW50ZXIgaXMgZXhlY3V0ZWQuXG4gIC8vIE90aGVyd2lzZSB0aGUgYmVmb3JlRW50ZXJIb29rIGhvb2sgb2YgdGhlIHRhcmdldCByb3V0ZSBpcyBleGVjdXRlZC5cbiAgYXN5bmMgcnVuR3VhcmRzKHRvID0gdGhpcy5nZXRQYXRoKCksIGZyb20pIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcGFyc2VQYXRoKHRoaXMucHJldmlvdXNQYXRoKS5zZWdtZW50cztcbiAgICB9XG4gICAgaWYgKCF0byB8fCAhZnJvbSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHJvdXRlcyA9IHJlYWRSb3V0ZXModGhpcy5lbCk7XG4gICAgY29uc3QgZnJvbUNoYWluID0gcm91dGVyUGF0aFRvQ2hhaW4oZnJvbSwgcm91dGVzKTtcbiAgICBjb25zdCBiZWZvcmVMZWF2ZUhvb2sgPSBmcm9tQ2hhaW4gJiYgZnJvbUNoYWluW2Zyb21DaGFpbi5sZW5ndGggLSAxXS5iZWZvcmVMZWF2ZTtcbiAgICBjb25zdCBjYW5MZWF2ZSA9IGJlZm9yZUxlYXZlSG9vayA/IGF3YWl0IGJlZm9yZUxlYXZlSG9vaygpIDogdHJ1ZTtcbiAgICBpZiAoY2FuTGVhdmUgPT09IGZhbHNlIHx8IHR5cGVvZiBjYW5MZWF2ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBjYW5MZWF2ZTtcbiAgICB9XG4gICAgY29uc3QgdG9DaGFpbiA9IHJvdXRlclBhdGhUb0NoYWluKHRvLCByb3V0ZXMpO1xuICAgIGNvbnN0IGJlZm9yZUVudGVySG9vayA9IHRvQ2hhaW4gJiYgdG9DaGFpblt0b0NoYWluLmxlbmd0aCAtIDFdLmJlZm9yZUVudGVyO1xuICAgIHJldHVybiBiZWZvcmVFbnRlckhvb2sgPyBiZWZvcmVFbnRlckhvb2soKSA6IHRydWU7XG4gIH1cbiAgYXN5bmMgd3JpdGVOYXZTdGF0ZShub2RlLCBjaGFpbiwgZGlyZWN0aW9uLCBwYXRoLCByZWRpcmVjdEZyb20sIGluZGV4ID0gMCwgYW5pbWF0aW9uKSB7XG4gICAgaWYgKHRoaXMuYnVzeSkge1xuICAgICAgY29uc29sZS53YXJuKCdbaW9uLXJvdXRlcl0gcm91dGVyIGlzIGJ1c3ksIHRyYW5zaXRpb24gd2FzIGNhbmNlbGxlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmJ1c3kgPSB0cnVlO1xuICAgIC8vIGdlbmVyYXRlIHJvdXRlIGV2ZW50IGFuZCBlbWl0IHdpbGwgY2hhbmdlXG4gICAgY29uc3Qgcm91dGVFdmVudCA9IHRoaXMucm91dGVDaGFuZ2VFdmVudChwYXRoLCByZWRpcmVjdEZyb20pO1xuICAgIGlmIChyb3V0ZUV2ZW50KSB7XG4gICAgICB0aGlzLmlvblJvdXRlV2lsbENoYW5nZS5lbWl0KHJvdXRlRXZlbnQpO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gYXdhaXQgd3JpdGVOYXZTdGF0ZShub2RlLCBjaGFpbiwgZGlyZWN0aW9uLCBpbmRleCwgZmFsc2UsIGFuaW1hdGlvbik7XG4gICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgLy8gZW1pdCBkaWQgY2hhbmdlXG4gICAgaWYgKHJvdXRlRXZlbnQpIHtcbiAgICAgIHRoaXMuaW9uUm91dGVEaWRDaGFuZ2UuZW1pdChyb3V0ZUV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgc2V0UGF0aChwYXRoLCBkaXJlY3Rpb24sIHF1ZXJ5U3RyaW5nKSB7XG4gICAgdGhpcy5zdGF0ZSsrO1xuICAgIHdyaXRlUGF0aCh3aW5kb3cuaGlzdG9yeSwgdGhpcy5yb290LCB0aGlzLnVzZUhhc2gsIHBhdGgsIGRpcmVjdGlvbiwgdGhpcy5zdGF0ZSwgcXVlcnlTdHJpbmcpO1xuICB9XG4gIGdldFBhdGgoKSB7XG4gICAgcmV0dXJuIHJlYWRQYXRoKHdpbmRvdy5sb2NhdGlvbiwgdGhpcy5yb290LCB0aGlzLnVzZUhhc2gpO1xuICB9XG4gIHJvdXRlQ2hhbmdlRXZlbnQocGF0aCwgcmVkaXJlY3RGcm9tUGF0aCkge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLnByZXZpb3VzUGF0aDtcbiAgICBjb25zdCB0byA9IGdlbmVyYXRlUGF0aChwYXRoKTtcbiAgICB0aGlzLnByZXZpb3VzUGF0aCA9IHRvO1xuICAgIGlmICh0byA9PT0gZnJvbSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0ZWRGcm9tID0gcmVkaXJlY3RGcm9tUGF0aCA/IGdlbmVyYXRlUGF0aChyZWRpcmVjdEZyb21QYXRoKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb20sXG4gICAgICByZWRpcmVjdGVkRnJvbSxcbiAgICAgIHRvLFxuICAgIH07XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcblxuY29uc3Qgcm91dGVyTGlua0NzcyA9IFwiOmhvc3R7LS1iYWNrZ3JvdW5kOnRyYW5zcGFyZW50Oy0tY29sb3I6dmFyKC0taW9uLWNvbG9yLXByaW1hcnksICMzODgwZmYpO2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZCk7Y29sb3I6dmFyKC0tY29sb3IpfTpob3N0KC5pb24tY29sb3Ipe2NvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKX1he2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7Zm9udC1zdHlsZTppbmhlcml0O2ZvbnQtd2VpZ2h0OmluaGVyaXQ7bGV0dGVyLXNwYWNpbmc6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246aW5oZXJpdDt0ZXh0LWluZGVudDppbmhlcml0O3RleHQtb3ZlcmZsb3c6aW5oZXJpdDt0ZXh0LXRyYW5zZm9ybTppbmhlcml0O3RleHQtYWxpZ246aW5oZXJpdDt3aGl0ZS1zcGFjZTppbmhlcml0O2NvbG9yOmluaGVyaXR9XCI7XG5cbmxldCBSb3V0ZXJMaW5rID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIGEgcm91dGVyLCBpdCBzcGVjaWZpZXMgdGhlIHRyYW5zaXRpb24gZGlyZWN0aW9uIHdoZW4gbmF2aWdhdGluZyB0b1xuICAgICAqIGFub3RoZXIgcGFnZSB1c2luZyBgaHJlZmAuXG4gICAgICovXG4gICAgdGhpcy5yb3V0ZXJEaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG4gICAgdGhpcy5vbkNsaWNrID0gKGV2KSA9PiB7XG4gICAgICBvcGVuVVJMKHRoaXMuaHJlZiwgZXYsIHRoaXMucm91dGVyRGlyZWN0aW9uLCB0aGlzLnJvdXRlckFuaW1hdGlvbik7XG4gICAgfTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgY29uc3QgYXR0cnMgPSB7XG4gICAgICBocmVmOiB0aGlzLmhyZWYsXG4gICAgICByZWw6IHRoaXMucmVsLFxuICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldFxuICAgIH07XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgb25DbGljazogdGhpcy5vbkNsaWNrLCBjbGFzczogY3JlYXRlQ29sb3JDbGFzc2VzKHRoaXMuY29sb3IsIHtcbiAgICAgICAgW21vZGVdOiB0cnVlLFxuICAgICAgICAnaW9uLWFjdGl2YXRhYmxlJzogdHJ1ZVxuICAgICAgfSkgfSwgaChcImFcIiwgT2JqZWN0LmFzc2lnbih7fSwgYXR0cnMpLCBoKFwic2xvdFwiLCBudWxsKSkpKTtcbiAgfVxufTtcblJvdXRlckxpbmsuc3R5bGUgPSByb3V0ZXJMaW5rQ3NzO1xuXG5leHBvcnQgeyBSb3V0ZSBhcyBpb25fcm91dGUsIFJvdXRlUmVkaXJlY3QgYXMgaW9uX3JvdXRlX3JlZGlyZWN0LCBSb3V0ZXIgYXMgaW9uX3JvdXRlciwgUm91dGVyTGluayBhcyBpb25fcm91dGVyX2xpbmsgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==